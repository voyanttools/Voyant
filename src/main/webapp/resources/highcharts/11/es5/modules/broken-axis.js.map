{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v11.4.8 (2024-08-29)\n *\n * (c) 2009-2024 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/broken-axis', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                Highcharts.win.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Core/Axis/BrokenAxis.js', [_modules['Core/Axis/Stacking/StackItem.js'], _modules['Core/Utilities.js']], function (StackItem, U) {\n        /* *\n         *\n         *  (c) 2009-2024 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var addEvent = U.addEvent, find = U.find, fireEvent = U.fireEvent, isArray = U.isArray, isNumber = U.isNumber, pick = U.pick;\n        /* *\n         *\n         *  Composition\n         *\n         * */\n        /**\n         * Axis with support of broken data rows.\n         * @private\n         */\n        var BrokenAxis;\n        (function (BrokenAxis) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Adds support for broken axes.\n             * @private\n             */\n            function compose(AxisClass, SeriesClass) {\n                if (!AxisClass.keepProps.includes('brokenAxis')) {\n                    AxisClass.keepProps.push('brokenAxis');\n                    addEvent(AxisClass, 'init', onAxisInit);\n                    addEvent(AxisClass, 'afterInit', onAxisAfterInit);\n                    addEvent(AxisClass, 'afterSetTickPositions', onAxisAfterSetTickPositions);\n                    addEvent(AxisClass, 'afterSetOptions', onAxisAfterSetOptions);\n                    var seriesProto = SeriesClass.prototype;\n                    seriesProto.drawBreaks = seriesDrawBreaks;\n                    seriesProto.gappedPath = seriesGappedPath;\n                    addEvent(SeriesClass, 'afterGeneratePoints', onSeriesAfterGeneratePoints);\n                    addEvent(SeriesClass, 'afterRender', onSeriesAfterRender);\n                }\n                return AxisClass;\n            }\n            BrokenAxis.compose = compose;\n            /**\n             * @private\n             */\n            function onAxisAfterInit() {\n                if (typeof this.brokenAxis !== 'undefined') {\n                    this.brokenAxis.setBreaks(this.options.breaks, false);\n                }\n            }\n            /**\n             * Force Axis to be not-ordinal when breaks are defined.\n             * @private\n             */\n            function onAxisAfterSetOptions() {\n                var _a;\n                var axis = this;\n                if ((_a = axis.brokenAxis) === null || _a === void 0 ? void 0 : _a.hasBreaks) {\n                    axis.options.ordinal = false;\n                }\n            }\n            /**\n             * @private\n             */\n            function onAxisAfterSetTickPositions() {\n                var axis = this, brokenAxis = axis.brokenAxis;\n                if (brokenAxis === null || brokenAxis === void 0 ? void 0 : brokenAxis.hasBreaks) {\n                    var tickPositions = axis.tickPositions, info = axis.tickPositions.info, newPositions = [];\n                    for (var i = 0; i < tickPositions.length; i++) {\n                        if (!brokenAxis.isInAnyBreak(tickPositions[i])) {\n                            newPositions.push(tickPositions[i]);\n                        }\n                    }\n                    axis.tickPositions = newPositions;\n                    axis.tickPositions.info = info;\n                }\n            }\n            /**\n             * @private\n             */\n            function onAxisInit() {\n                var axis = this;\n                if (!axis.brokenAxis) {\n                    axis.brokenAxis = new Additions(axis);\n                }\n            }\n            /**\n             * @private\n             */\n            function onSeriesAfterGeneratePoints() {\n                var _a, _b;\n                var _c = this, isDirty = _c.isDirty, connectNulls = _c.options.connectNulls, points = _c.points, xAxis = _c.xAxis, yAxis = _c.yAxis;\n                // Set, or reset visibility of the points. Axis.setBreaks marks\n                // the series as isDirty\n                if (isDirty) {\n                    var i = points.length;\n                    while (i--) {\n                        var point = points[i];\n                        // Respect nulls inside the break (#4275)\n                        var nullGap = point.y === null && connectNulls === false;\n                        var isPointInBreak = (!nullGap && (((_a = xAxis === null || xAxis === void 0 ? void 0 : xAxis.brokenAxis) === null || _a === void 0 ? void 0 : _a.isInAnyBreak(point.x, true)) ||\n                            ((_b = yAxis === null || yAxis === void 0 ? void 0 : yAxis.brokenAxis) === null || _b === void 0 ? void 0 : _b.isInAnyBreak(point.y, true))));\n                        // Set point.visible if in any break.\n                        // If not in break, reset visible to original value.\n                        point.visible = isPointInBreak ?\n                            false :\n                            point.options.visible !== false;\n                    }\n                }\n            }\n            /**\n             * @private\n             */\n            function onSeriesAfterRender() {\n                this.drawBreaks(this.xAxis, ['x']);\n                this.drawBreaks(this.yAxis, pick(this.pointArrayMap, ['y']));\n            }\n            /**\n             * @private\n             */\n            function seriesDrawBreaks(axis, keys) {\n                var _a;\n                var series = this, points = series.points;\n                var breaks, threshold, y;\n                if ((_a = axis === null || axis === void 0 ? void 0 : axis.brokenAxis) === null || _a === void 0 ? void 0 : _a.hasBreaks) {\n                    var brokenAxis_1 = axis.brokenAxis;\n                    keys.forEach(function (key) {\n                        var _a, _b;\n                        breaks = (brokenAxis_1 === null || brokenAxis_1 === void 0 ? void 0 : brokenAxis_1.breakArray) || [];\n                        threshold = axis.isXAxis ?\n                            axis.min :\n                            pick(series.options.threshold, axis.min);\n                        // Array of breaks that have been \"zoomed-out\" which means that\n                        // they were shown previously, but now after zoom, they are not\n                        // (#19885).\n                        var breaksOutOfRange = (_b = (_a = axis === null || axis === void 0 ? void 0 : axis.options) === null || _a === void 0 ? void 0 : _a.breaks) === null || _b === void 0 ? void 0 : _b.filter(function (brk) {\n                            var isOut = true;\n                            // Iterate to see if \"brk\" is in axis range\n                            for (var i = 0; i < breaks.length; i++) {\n                                var otherBreak = breaks[i];\n                                if (otherBreak.from === brk.from &&\n                                    otherBreak.to === brk.to) {\n                                    isOut = false;\n                                    break;\n                                }\n                            }\n                            return isOut;\n                        });\n                        points.forEach(function (point) {\n                            y = pick(point['stack' + key.toUpperCase()], point[key]);\n                            breaks.forEach(function (brk) {\n                                if (isNumber(threshold) && isNumber(y)) {\n                                    var eventName = '';\n                                    if ((threshold < brk.from && y > brk.to) ||\n                                        (threshold > brk.from && y < brk.from)) {\n                                        eventName = 'pointBreak';\n                                    }\n                                    else if ((threshold < brk.from &&\n                                        y > brk.from &&\n                                        y < brk.to) || (threshold > brk.from &&\n                                        y > brk.to &&\n                                        y < brk.from)) {\n                                        eventName = 'pointInBreak';\n                                    }\n                                    if (eventName) {\n                                        fireEvent(axis, eventName, { point: point, brk: brk });\n                                    }\n                                }\n                            });\n                            breaksOutOfRange === null || breaksOutOfRange === void 0 ? void 0 : breaksOutOfRange.forEach(function (brk) {\n                                fireEvent(axis, 'pointOutsideOfBreak', { point: point, brk: brk });\n                            });\n                        });\n                    });\n                }\n            }\n            /**\n             * Extend getGraphPath by identifying gaps in the data so that we\n             * can draw a gap in the line or area. This was moved from ordinal\n             * axis module to broken axis module as of #5045.\n             *\n             * @private\n             * @function Highcharts.Series#gappedPath\n             *\n             * @return {Highcharts.SVGPathArray}\n             * Gapped path\n             */\n            function seriesGappedPath() {\n                var currentDataGrouping = this.currentDataGrouping, groupingSize = currentDataGrouping === null || currentDataGrouping === void 0 ? void 0 : currentDataGrouping.gapSize, points = this.points.slice(), yAxis = this.yAxis;\n                var gapSize = this.options.gapSize, i = points.length - 1, stack;\n                /**\n                 * Defines when to display a gap in the graph, together with the\n                 * [gapUnit](plotOptions.series.gapUnit) option.\n                 *\n                 * In case when `dataGrouping` is enabled, points can be grouped\n                 * into a larger time span. This can make the grouped points to\n                 * have a greater distance than the absolute value of `gapSize`\n                 * property, which will result in disappearing graph completely.\n                 * To prevent this situation the mentioned distance between\n                 * grouped points is used instead of previously defined\n                 * `gapSize`.\n                 *\n                 * In practice, this option is most often used to visualize gaps\n                 * in time series. In a stock chart, intraday data is available\n                 * for daytime hours, while gaps will appear in nights and\n                 * weekends.\n                 *\n                 * @see [gapUnit](plotOptions.series.gapUnit)\n                 * @see [xAxis.breaks](#xAxis.breaks)\n                 *\n                 * @sample {highstock} stock/plotoptions/series-gapsize/\n                 * Setting the gap size to 2 introduces gaps for weekends in\n                 * daily datasets.\n                 *\n                 * @type      {number}\n                 * @default   0\n                 * @product   highstock\n                 * @requires  modules/broken-axis\n                 * @apioption plotOptions.series.gapSize\n                 */\n                /**\n                 * Together with [gapSize](plotOptions.series.gapSize), this\n                 * option defines where to draw gaps in the graph.\n                 *\n                 * When the `gapUnit` is `\"relative\"` (default), a gap size of 5\n                 * means that if the distance between two points is greater than\n                 * 5 times that of the two closest points, the graph will be\n                 * broken.\n                 *\n                 * When the `gapUnit` is `\"value\"`, the gap is based on absolute\n                 * axis values, which on a datetime axis is milliseconds. This\n                 * also applies to the navigator series that inherits gap\n                 * options from the base series.\n                 *\n                 * @see [gapSize](plotOptions.series.gapSize)\n                 *\n                 * @type       {string}\n                 * @default    relative\n                 * @since      5.0.13\n                 * @product    highstock\n                 * @validvalue [\"relative\", \"value\"]\n                 * @requires   modules/broken-axis\n                 * @apioption  plotOptions.series.gapUnit\n                 */\n                if (gapSize && i > 0) { // #5008\n                    // Gap unit is relative\n                    if (this.options.gapUnit !== 'value') {\n                        gapSize *= this.basePointRange;\n                    }\n                    // Setting a new gapSize in case dataGrouping is enabled\n                    // (#7686)\n                    if (groupingSize &&\n                        groupingSize > gapSize &&\n                        // Except when DG is forced (e.g. from other series)\n                        // and has lower granularity than actual points (#11351)\n                        groupingSize >= this.basePointRange) {\n                        gapSize = groupingSize;\n                    }\n                    // Extension for ordinal breaks\n                    var current = void 0, next = void 0;\n                    while (i--) {\n                        // Reassign next if it is not visible\n                        if (!(next && next.visible !== false)) {\n                            next = points[i + 1];\n                        }\n                        current = points[i];\n                        // Skip iteration if one of the points is not visible\n                        if (next.visible === false || current.visible === false) {\n                            continue;\n                        }\n                        if (next.x - current.x > gapSize) {\n                            var xRange = (current.x + next.x) / 2;\n                            points.splice(// Insert after this one\n                            i + 1, 0, {\n                                isNull: true,\n                                x: xRange\n                            });\n                            // For stacked chart generate empty stack items, #6546\n                            if (yAxis.stacking && this.options.stacking) {\n                                stack = yAxis.stacking.stacks[this.stackKey][xRange] = new StackItem(yAxis, yAxis.options.stackLabels, false, xRange, this.stack);\n                                stack.total = 0;\n                            }\n                        }\n                        // Assign current to next for the upcoming iteration\n                        next = current;\n                    }\n                }\n                // Call base method\n                return this.getGraphPath(points);\n            }\n            /* *\n             *\n             *  Class\n             *\n             * */\n            /**\n             * Provides support for broken axes.\n             * @private\n             * @class\n             */\n            var Additions = /** @class */ (function () {\n                /* *\n                 *\n                 *  Constructors\n                 *\n                 * */\n                function Additions(axis) {\n                    this.hasBreaks = false;\n                    this.axis = axis;\n                }\n                /* *\n                 *\n                 *  Static Functions\n                 *\n                 * */\n                /**\n                 * @private\n                 */\n                Additions.isInBreak = function (brk, val) {\n                    var repeat = brk.repeat || Infinity, from = brk.from, length = brk.to - brk.from, test = (val >= from ?\n                        (val - from) % repeat :\n                        repeat - ((from - val) % repeat));\n                    var ret;\n                    if (!brk.inclusive) {\n                        ret = test < length && test !== 0;\n                    }\n                    else {\n                        ret = test <= length;\n                    }\n                    return ret;\n                };\n                /**\n                 * @private\n                 */\n                Additions.lin2Val = function (val) {\n                    var axis = this;\n                    var brokenAxis = axis.brokenAxis;\n                    var breakArray = brokenAxis && brokenAxis.breakArray;\n                    if (!breakArray || !isNumber(val)) {\n                        return val;\n                    }\n                    var nval = val, brk, i;\n                    for (i = 0; i < breakArray.length; i++) {\n                        brk = breakArray[i];\n                        if (brk.from >= nval) {\n                            break;\n                        }\n                        else if (brk.to < nval) {\n                            nval += brk.len;\n                        }\n                        else if (Additions.isInBreak(brk, nval)) {\n                            nval += brk.len;\n                        }\n                    }\n                    return nval;\n                };\n                /**\n                 * @private\n                 */\n                Additions.val2Lin = function (val) {\n                    var axis = this;\n                    var brokenAxis = axis.brokenAxis;\n                    var breakArray = brokenAxis && brokenAxis.breakArray;\n                    if (!breakArray || !isNumber(val)) {\n                        return val;\n                    }\n                    var nval = val, brk, i;\n                    for (i = 0; i < breakArray.length; i++) {\n                        brk = breakArray[i];\n                        if (brk.to <= val) {\n                            nval -= brk.len;\n                        }\n                        else if (brk.from >= val) {\n                            break;\n                        }\n                        else if (Additions.isInBreak(brk, val)) {\n                            nval -= (val - brk.from);\n                            break;\n                        }\n                    }\n                    return nval;\n                };\n                /* *\n                 *\n                 *  Functions\n                 *\n                 * */\n                /**\n                 * Returns the first break found where the x is larger then break.from\n                 * and smaller then break.to.\n                 *\n                 * @param {number} x\n                 * The number which should be within a break.\n                 *\n                 * @param {Array<Highcharts.XAxisBreaksOptions>} breaks\n                 * The array of breaks to search within.\n                 *\n                 * @return {Highcharts.XAxisBreaksOptions|undefined}\n                 * Returns the first break found that matches, returns false if no break\n                 * is found.\n                 */\n                Additions.prototype.findBreakAt = function (x, breaks) {\n                    return find(breaks, function (b) {\n                        return b.from < x && x < b.to;\n                    });\n                };\n                /**\n                 * @private\n                 */\n                Additions.prototype.isInAnyBreak = function (val, testKeep) {\n                    var brokenAxis = this, axis = brokenAxis.axis, breaks = axis.options.breaks || [];\n                    var i = breaks.length, inbrk, keep, ret;\n                    if (i && isNumber(val)) {\n                        while (i--) {\n                            if (Additions.isInBreak(breaks[i], val)) {\n                                inbrk = true;\n                                if (!keep) {\n                                    keep = pick(breaks[i].showPoints, !axis.isXAxis);\n                                }\n                            }\n                        }\n                        if (inbrk && testKeep) {\n                            ret = inbrk && !keep;\n                        }\n                        else {\n                            ret = inbrk;\n                        }\n                    }\n                    return ret;\n                };\n                /**\n                 * Dynamically set or unset breaks in an axis. This function in lighter\n                 * than using Axis.update, and it also preserves animation.\n                 *\n                 * @private\n                 * @function Highcharts.Axis#setBreaks\n                 *\n                 * @param {Array<Highcharts.XAxisBreaksOptions>} [breaks]\n                 * The breaks to add. When `undefined` it removes existing breaks.\n                 *\n                 * @param {boolean} [redraw=true]\n                 * Whether to redraw the chart immediately.\n                 */\n                Additions.prototype.setBreaks = function (breaks, redraw) {\n                    var brokenAxis = this;\n                    var axis = brokenAxis.axis;\n                    var hasBreaks = isArray(breaks) &&\n                        !!breaks.length &&\n                        !!Object.keys(breaks[0]).length; // Check for [{}], #16368.\n                    axis.isDirty = brokenAxis.hasBreaks !== hasBreaks;\n                    brokenAxis.hasBreaks = hasBreaks;\n                    if (breaks !== axis.options.breaks) {\n                        axis.options.breaks = axis.userOptions.breaks = breaks;\n                    }\n                    axis.forceRedraw = true; // Force recalculation in setScale\n                    // Recalculate series related to the axis.\n                    axis.series.forEach(function (series) {\n                        series.isDirty = true;\n                    });\n                    if (!hasBreaks && axis.val2lin === Additions.val2Lin) {\n                        // Revert to prototype functions\n                        delete axis.val2lin;\n                        delete axis.lin2val;\n                    }\n                    if (hasBreaks) {\n                        axis.userOptions.ordinal = false;\n                        axis.lin2val = Additions.lin2Val;\n                        axis.val2lin = Additions.val2Lin;\n                        axis.setExtremes = function (newMin, newMax, redraw, animation, eventArguments) {\n                            // If trying to set extremes inside a break, extend min to\n                            // after, and max to before the break ( #3857 )\n                            if (brokenAxis.hasBreaks) {\n                                var breaks_1 = (this.options.breaks || []);\n                                var axisBreak = void 0;\n                                while ((axisBreak = brokenAxis.findBreakAt(newMin, breaks_1))) {\n                                    newMin = axisBreak.to;\n                                }\n                                while ((axisBreak = brokenAxis.findBreakAt(newMax, breaks_1))) {\n                                    newMax = axisBreak.from;\n                                }\n                                // If both min and max is within the same break.\n                                if (newMax < newMin) {\n                                    newMax = newMin;\n                                }\n                            }\n                            axis.constructor.prototype.setExtremes.call(this, newMin, newMax, redraw, animation, eventArguments);\n                        };\n                        axis.setAxisTranslation = function () {\n                            axis.constructor.prototype.setAxisTranslation.call(this);\n                            brokenAxis.unitLength = void 0;\n                            if (brokenAxis.hasBreaks) {\n                                var breaks_2 = axis.options.breaks || [], \n                                // Temporary one:\n                                breakArrayT_1 = [], breakArray_1 = [], pointRangePadding = pick(axis.pointRangePadding, 0);\n                                var length_1 = 0, inBrk_1, repeat_1, min_1 = axis.userMin || axis.min, max_1 = axis.userMax || axis.max, start_1, i_1;\n                                // Min & max check (#4247)\n                                breaks_2.forEach(function (brk) {\n                                    repeat_1 = brk.repeat || Infinity;\n                                    if (isNumber(min_1) && isNumber(max_1)) {\n                                        if (Additions.isInBreak(brk, min_1)) {\n                                            min_1 += ((brk.to % repeat_1) -\n                                                (min_1 % repeat_1));\n                                        }\n                                        if (Additions.isInBreak(brk, max_1)) {\n                                            max_1 -= ((max_1 % repeat_1) -\n                                                (brk.from % repeat_1));\n                                        }\n                                    }\n                                });\n                                // Construct an array holding all breaks in the axis\n                                breaks_2.forEach(function (brk) {\n                                    start_1 = brk.from;\n                                    repeat_1 = brk.repeat || Infinity;\n                                    if (isNumber(min_1) && isNumber(max_1)) {\n                                        while (start_1 - repeat_1 > min_1) {\n                                            start_1 -= repeat_1;\n                                        }\n                                        while (start_1 < min_1) {\n                                            start_1 += repeat_1;\n                                        }\n                                        for (i_1 = start_1; i_1 < max_1; i_1 += repeat_1) {\n                                            breakArrayT_1.push({\n                                                value: i_1,\n                                                move: 'in'\n                                            });\n                                            breakArrayT_1.push({\n                                                value: i_1 + brk.to - brk.from,\n                                                move: 'out',\n                                                size: brk.breakSize\n                                            });\n                                        }\n                                    }\n                                });\n                                breakArrayT_1.sort(function (a, b) {\n                                    return ((a.value === b.value) ?\n                                        ((a.move === 'in' ? 0 : 1) -\n                                            (b.move === 'in' ? 0 : 1)) :\n                                        a.value - b.value);\n                                });\n                                // Simplify the breaks\n                                inBrk_1 = 0;\n                                start_1 = min_1;\n                                breakArrayT_1.forEach(function (brk) {\n                                    inBrk_1 += (brk.move === 'in' ? 1 : -1);\n                                    if (inBrk_1 === 1 && brk.move === 'in') {\n                                        start_1 = brk.value;\n                                    }\n                                    if (inBrk_1 === 0 && isNumber(start_1)) {\n                                        breakArray_1.push({\n                                            from: start_1,\n                                            to: brk.value,\n                                            len: brk.value - start_1 - (brk.size || 0)\n                                        });\n                                        length_1 += (brk.value -\n                                            start_1 -\n                                            (brk.size || 0));\n                                    }\n                                });\n                                brokenAxis.breakArray = breakArray_1;\n                                // Used with staticScale, and below the actual axis\n                                // length, when breaks are subtracted.\n                                if (isNumber(min_1) &&\n                                    isNumber(max_1) &&\n                                    isNumber(axis.min)) {\n                                    brokenAxis.unitLength = max_1 - min_1 - length_1 +\n                                        pointRangePadding;\n                                    fireEvent(axis, 'afterBreaks');\n                                    if (axis.staticScale) {\n                                        axis.transA = axis.staticScale;\n                                    }\n                                    else if (brokenAxis.unitLength) {\n                                        axis.transA *=\n                                            (max_1 - axis.min + pointRangePadding) /\n                                                brokenAxis.unitLength;\n                                    }\n                                    if (pointRangePadding) {\n                                        axis.minPixelPadding =\n                                            axis.transA * (axis.minPointOffset || 0);\n                                    }\n                                    axis.min = min_1;\n                                    axis.max = max_1;\n                                }\n                            }\n                        };\n                    }\n                    if (pick(redraw, true)) {\n                        axis.chart.redraw();\n                    }\n                };\n                return Additions;\n            }());\n            BrokenAxis.Additions = Additions;\n        })(BrokenAxis || (BrokenAxis = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return BrokenAxis;\n    });\n    _registerModule(_modules, 'masters/modules/broken-axis.src.js', [_modules['Core/Globals.js'], _modules['Core/Axis/BrokenAxis.js']], function (Highcharts, BrokenAxis) {\n\n        var G = Highcharts;\n        G.BrokenAxis = G.BrokenAxis || BrokenAxis;\n        G.BrokenAxis.compose(G.Axis, G.Series);\n\n        return Highcharts;\n    });\n}));\n"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","win","dispatchEvent","detail","StackItem","U","BrokenAxis","addEvent","find","fireEvent","isArray","isNumber","pick","onAxisAfterInit","brokenAxis","setBreaks","options","breaks","onAxisAfterSetOptions","_a","axis","hasBreaks","ordinal","onAxisAfterSetTickPositions","tickPositions","info","newPositions","i","length","isInAnyBreak","push","onAxisInit","Additions","onSeriesAfterGeneratePoints","_b","isDirty","_c","connectNulls","points","xAxis","yAxis","point","isPointInBreak","y","x","visible","onSeriesAfterRender","drawBreaks","pointArrayMap","seriesDrawBreaks","keys","threshold","series","brokenAxis_1","forEach","key","breakArray","isXAxis","min","breaksOutOfRange","filter","brk","isOut","otherBreak","from","to","toUpperCase","eventName","seriesGappedPath","currentDataGrouping","groupingSize","gapSize","slice","gapUnit","basePointRange","current","next","xRange","splice","isNull","stacking","stack","stacks","stackKey","stackLabels","total","getGraphPath","compose","AxisClass","SeriesClass","keepProps","includes","seriesProto","prototype","gappedPath","isInBreak","val","repeat","Infinity","test","inclusive","lin2Val","nval","len","val2Lin","findBreakAt","b","testKeep","inbrk","keep","ret","showPoints","redraw","Object","userOptions","forceRedraw","val2lin","lin2val","setExtremes","newMin","newMax","animation","eventArguments","breaks_1","axisBreak","constructor","call","setAxisTranslation","unitLength","inBrk_1","repeat_1","start_1","i_1","breaks_2","breakArrayT_1","breakArray_1","pointRangePadding","length_1","min_1","userMin","max_1","userMax","max","value","move","size","breakSize","sort","a","staticScale","transA","minPixelPadding","minPointOffset","chart","G","Axis","Series"],"mappings":"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"}
{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v11.4.8 (2024-08-29)\n *\n * (c) 2016-2024 Highsoft AS\n * Authors: Jon Arild Nygard\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/wordcloud', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                Highcharts.win.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Series/DrawPointUtilities.js', [], function () {\n        /* *\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __assign = (this && this.__assign) || function () {\n            __assign = Object.assign || function(t) {\n                for (var s, i = 1, n = arguments.length; i < n; i++) {\n                    s = arguments[i];\n                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                        t[p] = s[p];\n                }\n                return t;\n            };\n            return __assign.apply(this, arguments);\n        };\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Handles the drawing of a component.\n         * Can be used for any type of component that reserves the graphic property,\n         * and provides a shouldDraw on its context.\n         *\n         * @private\n         *\n         * @todo add type checking.\n         * @todo export this function to enable usage\n         */\n        function draw(point, params) {\n            var animatableAttribs = params.animatableAttribs, onComplete = params.onComplete, css = params.css, renderer = params.renderer;\n            var animation = (point.series && point.series.chart.hasRendered) ?\n                // Chart-level animation on updates\n                void 0 :\n                // Series-level animation on new points\n                (point.series &&\n                    point.series.options.animation);\n            var graphic = point.graphic;\n            params.attribs = __assign(__assign({}, params.attribs), { 'class': point.getClassName() }) || {};\n            if ((point.shouldDraw())) {\n                if (!graphic) {\n                    if (params.shapeType === 'text') {\n                        graphic = renderer.text();\n                    }\n                    else if (params.shapeType === 'image') {\n                        graphic = renderer.image(params.imageUrl || '')\n                            .attr(params.shapeArgs || {});\n                    }\n                    else {\n                        graphic = renderer[params.shapeType](params.shapeArgs || {});\n                    }\n                    point.graphic = graphic;\n                    graphic.add(params.group);\n                }\n                if (css) {\n                    graphic.css(css);\n                }\n                graphic\n                    .attr(params.attribs)\n                    .animate(animatableAttribs, params.isNew ? false : animation, onComplete);\n            }\n            else if (graphic) {\n                var destroy_1 = function () {\n                    point.graphic = graphic = (graphic && graphic.destroy());\n                    if (typeof onComplete === 'function') {\n                        onComplete();\n                    }\n                };\n                // Animate only runs complete callback if something was animated.\n                if (Object.keys(animatableAttribs).length) {\n                    graphic.animate(animatableAttribs, void 0, function () { return destroy_1(); });\n                }\n                else {\n                    destroy_1();\n                }\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        var DrawPointUtilities = {\n            draw: draw\n        };\n\n        return DrawPointUtilities;\n    });\n    _registerModule(_modules, 'Series/Wordcloud/WordcloudPoint.js', [_modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (SeriesRegistry, U) {\n        /* *\n         *\n         *  Experimental Highcharts module which enables visualization of a word cloud.\n         *\n         *  (c) 2016-2024 Highsoft AS\n         *  Authors: Jon Arild Nygard\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         * */\n        var __extends = (this && this.__extends) || (function () {\n            var extendStatics = function (d, b) {\n                extendStatics = Object.setPrototypeOf ||\n                    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                    function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                if (typeof b !== \"function\" && b !== null)\n                    throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var ColumnPoint = SeriesRegistry.seriesTypes.column.prototype.pointClass;\n        var extend = U.extend;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        var WordcloudPoint = /** @class */ (function (_super) {\n            __extends(WordcloudPoint, _super);\n            function WordcloudPoint() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            WordcloudPoint.prototype.isValid = function () {\n                return true;\n            };\n            return WordcloudPoint;\n        }(ColumnPoint));\n        extend(WordcloudPoint.prototype, {\n            weight: 1\n        });\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return WordcloudPoint;\n    });\n    _registerModule(_modules, 'Series/Wordcloud/WordcloudSeriesDefaults.js', [], function () {\n        /* *\n         *\n         *  Experimental Highcharts module which enables visualization of a word cloud.\n         *\n         *  (c) 2016-2024 Highsoft AS\n         *  Authors: Jon Arild Nygard\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * A word cloud is a visualization of a set of words, where the size and\n         * placement of a word is determined by how it is weighted.\n         *\n         * @sample highcharts/demo/wordcloud Word Cloud chart\n         *\n         * @extends      plotOptions.column\n         * @excluding    allAreas, boostThreshold, clip, colorAxis, compare,\n         *               compareBase, crisp, cropThreshold, dataGrouping,\n         *               dataLabels, depth, dragDrop, edgeColor, findNearestPointBy,\n         *               getExtremesFromAll, grouping, groupPadding, groupZPadding,\n         *               joinBy, maxPointWidth, minPointLength, navigatorOptions,\n         *               negativeColor, pointInterval, pointIntervalUnit,\n         *               pointPadding, pointPlacement, pointRange, pointStart,\n         *               pointWidth, pointStart, pointWidth, shadow, showCheckbox,\n         *               showInNavigator, softThreshold, stacking, threshold,\n         *               zoneAxis, zones, dataSorting, boostBlending\n         * @product      highcharts\n         * @since        6.0.0\n         * @requires     modules/wordcloud\n         * @optionparent plotOptions.wordcloud\n         */\n        var WordcloudSeriesDefaults = {\n            /**\n             * If there is no space for a word on the playing field, then this\n             * option will allow the playing field to be extended to fit the word.\n             * If false then the word will be dropped from the visualization.\n             *\n             * NB! This option is currently not decided to be published in the API,\n             * and is therefore marked as private.\n             *\n             * @ignore-option\n             */\n            allowExtendPlayingField: true,\n            animation: {\n                /** @internal */\n                duration: 500\n            },\n            borderWidth: 0,\n            /**\n             * @ignore-option\n             */\n            clip: false, // Something goes wrong with clip. // @todo fix this\n            colorByPoint: true,\n            cropThreshold: Infinity,\n            /**\n             * A threshold determining the minimum font size that can be applied to\n             * a word.\n             */\n            minFontSize: 1,\n            /**\n             * The word with the largest weight will have a font size equal to this\n             * value. The font size of a word is the ratio between its weight and\n             * the largest occuring weight, multiplied with the value of\n             * maxFontSize.\n             */\n            maxFontSize: 25,\n            /**\n             * This option decides which algorithm is used for placement, and\n             * rotation of a word. The choice of algorith is therefore a crucial\n             * part of the resulting layout of the wordcloud. It is possible for\n             * users to add their own custom placement strategies for use in word\n             * cloud. Read more about it in our\n             * [documentation](https://www.highcharts.com/docs/chart-and-series-types/word-cloud-series#custom-placement-strategies)\n             *\n             * @validvalue [\"center\", \"random\"]\n             */\n            placementStrategy: 'center',\n            /**\n             * Rotation options for the words in the wordcloud.\n             *\n             * @sample highcharts/plotoptions/wordcloud-rotation\n             *         Word cloud with rotation\n             */\n            rotation: {\n                /**\n                 * The smallest degree of rotation for a word.\n                 */\n                from: 0,\n                /**\n                 * The number of possible orientations for a word, within the range\n                 * of `rotation.from` and `rotation.to`. Must be a number larger\n                 * than 0.\n                 */\n                orientations: 2,\n                /**\n                 * The largest degree of rotation for a word.\n                 */\n                to: 90\n            },\n            showInLegend: false,\n            /**\n             * Spiral used for placing a word after the initial position\n             * experienced a collision with either another word or the borders.\n             * It is possible for users to add their own custom spiralling\n             * algorithms for use in word cloud. Read more about it in our\n             * [documentation](https://www.highcharts.com/docs/chart-and-series-types/word-cloud-series#custom-spiralling-algorithm)\n             *\n             * @validvalue [\"archimedean\", \"rectangular\", \"square\"]\n             */\n            spiral: 'rectangular',\n            /**\n             * CSS styles for the words.\n             *\n             * @type    {Highcharts.CSSObject}\n             * @default {\"fontFamily\":\"sans-serif\", \"fontWeight\": \"900\"}\n             */\n            style: {\n                /** @ignore-option */\n                fontFamily: 'sans-serif',\n                /** @ignore-option */\n                fontWeight: '900',\n                /** @ignore-option */\n                whiteSpace: 'nowrap'\n            },\n            tooltip: {\n                followPointer: true,\n                pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.weight}</b><br/>'\n            }\n        };\n        /**\n         * A `wordcloud` series. If the [type](#series.wordcloud.type) option is not\n         * specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.wordcloud\n         * @exclude   dataSorting, boostThreshold, boostBlending\n         * @product   highcharts\n         * @requires  modules/wordcloud\n         * @apioption series.wordcloud\n         */\n        /**\n         * An array of data points for the series. For the `wordcloud` series type,\n         * points can be given in the following ways:\n         *\n         * 1. An array of arrays with 2 values. In this case, the values correspond to\n         *    `name,weight`.\n         *    ```js\n         *    data: [\n         *        ['Lorem', 4],\n         *        ['Ipsum', 1]\n         *    ]\n         *    ```\n         *\n         * 2. An array of objects with named values. The following snippet shows only a\n         *    few settings, see the complete options set below. If the total number of\n         *    data points exceeds the series'\n         *    [turboThreshold](#series.arearange.turboThreshold), this option is not\n         *    available.\n         *    ```js\n         *    data: [{\n         *        name: \"Lorem\",\n         *        weight: 4\n         *    }, {\n         *        name: \"Ipsum\",\n         *        weight: 1\n         *    }]\n         *    ```\n         *\n         * @type      {Array<Array<string,number>|*>}\n         * @extends   series.line.data\n         * @excluding drilldown, marker, x, y\n         * @product   highcharts\n         * @apioption series.wordcloud.data\n         */\n        /**\n         * The name decides the text for a word.\n         *\n         * @type      {string}\n         * @since     6.0.0\n         * @product   highcharts\n         * @apioption series.wordcloud.data.name\n         */\n        /**\n         * The weighting of a word. The weight decides the relative size of a word\n         * compared to the rest of the collection.\n         *\n         * @type      {number}\n         * @since     6.0.0\n         * @product   highcharts\n         * @apioption series.wordcloud.data.weight\n         */\n        ''; // Detach doclets above\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return WordcloudSeriesDefaults;\n    });\n    _registerModule(_modules, 'Series/Wordcloud/WordcloudUtils.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  Experimental Highcharts module which enables visualization of a word cloud.\n         *\n         *  (c) 2016-2024 Highsoft AS\n         *  Authors: Jon Arild Nygard\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         * */\n        var deg2rad = H.deg2rad;\n        var extend = U.extend, find = U.find, isNumber = U.isNumber, isObject = U.isObject, merge = U.merge;\n        /* *\n         *\n         * Functions\n         *\n         * */\n        /**\n         * Detects if there is a collision between two rectangles.\n         *\n         * @private\n         * @function isRectanglesIntersecting\n         *\n         * @param {Highcharts.PolygonBoxObject} r1\n         * First rectangle.\n         *\n         * @param {Highcharts.PolygonBoxObject} r2\n         * Second rectangle.\n         *\n         * @return {boolean}\n         * Returns true if the rectangles overlap.\n         */\n        function isRectanglesIntersecting(r1, r2) {\n            return !(r2.left > r1.right ||\n                r2.right < r1.left ||\n                r2.top > r1.bottom ||\n                r2.bottom < r1.top);\n        }\n        /**\n         * Calculates the normals to a line between two points.\n         *\n         * @private\n         * @function getNormals\n         * @param {Highcharts.PolygonPointObject} p1\n         *        Start point for the line. Array of x and y value.\n         * @param {Highcharts.PolygonPointObject} p2\n         *        End point for the line. Array of x and y value.\n         * @return {Highcharts.PolygonObject}\n         *         Returns the two normals in an array.\n         */\n        function getNormals(p1, p2) {\n            var dx = p2[0] - p1[0], // X2 - x1\n            dy = p2[1] - p1[1]; // Y2 - y1\n            return [\n                [-dy, dx],\n                [dy, -dx]\n            ];\n        }\n        /**\n         * @private\n         */\n        function getAxesFromPolygon(polygon) {\n            var points, axes = polygon.axes || [];\n            if (!axes.length) {\n                axes = [];\n                points = points = polygon.concat([polygon[0]]);\n                points.reduce(function (p1, p2) {\n                    var normals = getNormals(p1, p2), axis = normals[0]; // Use the left normal as axis.\n                    // Check that the axis is unique.\n                    if (!find(axes, function (existing) {\n                        return existing[0] === axis[0] &&\n                            existing[1] === axis[1];\n                    })) {\n                        axes.push(axis);\n                    }\n                    // Return p2 to be used as p1 in next iteration.\n                    return p2;\n                });\n                polygon.axes = axes;\n            }\n            return axes;\n        }\n        /**\n         * Projects a polygon onto a coordinate.\n         *\n         * @private\n         * @function project\n         * @param {Highcharts.PolygonObject} polygon\n         * Array of points in a polygon.\n         * @param {Highcharts.PolygonPointObject} target\n         * The coordinate of pr\n         */\n        function project(polygon, target) {\n            var products = polygon.map(function (point) {\n                var ax = point[0], ay = point[1], bx = target[0], by = target[1];\n                return ax * bx + ay * by;\n            });\n            return {\n                min: Math.min.apply(this, products),\n                max: Math.max.apply(this, products)\n            };\n        }\n        /**\n         * @private\n         */\n        function isPolygonsOverlappingOnAxis(axis, polygon1, polygon2) {\n            var projection1 = project(polygon1, axis), projection2 = project(polygon2, axis), isOverlapping = !(projection2.min > projection1.max ||\n                projection2.max < projection1.min);\n            return !isOverlapping;\n        }\n        /**\n         * Checks whether two convex polygons are colliding by using the Separating\n         * Axis Theorem.\n         *\n         * @private\n         * @function isPolygonsColliding\n         * @param {Highcharts.PolygonObject} polygon1\n         *        First polygon.\n         *\n         * @param {Highcharts.PolygonObject} polygon2\n         *        Second polygon.\n         *\n         * @return {boolean}\n         *         Returns true if they are colliding, otherwise false.\n         */\n        function isPolygonsColliding(polygon1, polygon2) {\n            // Get the axis from both polygons.\n            var axes1 = getAxesFromPolygon(polygon1), axes2 = getAxesFromPolygon(polygon2), axes = axes1.concat(axes2), overlappingOnAllAxes = !find(axes, function (axis) { return isPolygonsOverlappingOnAxis(axis, polygon1, polygon2); });\n            return overlappingOnAllAxes;\n        }\n        /**\n         * Detects if a word collides with any previously placed words.\n         *\n         * @private\n         * @function intersectsAnyWord\n         *\n         * @param {Highcharts.Point} point\n         * Point which the word is connected to.\n         *\n         * @param {Array<Highcharts.Point>} points\n         * Previously placed points to check against.\n         *\n         * @return {boolean}\n         * Returns true if there is collision.\n         */\n        function intersectsAnyWord(point, points) {\n            var rect = point.rect, polygon = point.polygon, lastCollidedWith = point.lastCollidedWith, isIntersecting = function (p) {\n                var result = isRectanglesIntersecting(rect, p.rect);\n                if (result &&\n                    (point.rotation % 90 || p.rotation % 90)) {\n                    result = isPolygonsColliding(polygon, p.polygon);\n                }\n                return result;\n            };\n            var intersects = false;\n            // If the point has already intersected a different point, chances are\n            // they are still intersecting. So as an enhancement we check this\n            // first.\n            if (lastCollidedWith) {\n                intersects = isIntersecting(lastCollidedWith);\n                // If they no longer intersects, remove the cache from the point.\n                if (!intersects) {\n                    delete point.lastCollidedWith;\n                }\n            }\n            // If not already found, then check if we can find a point that is\n            // intersecting.\n            if (!intersects) {\n                intersects = !!find(points, function (p) {\n                    var result = isIntersecting(p);\n                    if (result) {\n                        point.lastCollidedWith = p;\n                    }\n                    return result;\n                });\n            }\n            return intersects;\n        }\n        /**\n         * Gives a set of cordinates for an Archimedian Spiral.\n         *\n         * @private\n         * @function archimedeanSpiral\n         *\n         * @param {number} attempt\n         * How far along the spiral we have traversed.\n         *\n         * @param {Highcharts.WordcloudSpiralParamsObject} [params]\n         * Additional parameters.\n         *\n         * @return {boolean|Highcharts.PositionObject}\n         * Resulting coordinates, x and y. False if the word should be dropped from\n         * the visualization.\n         */\n        function archimedeanSpiral(attempt, params) {\n            var field = params.field, maxDelta = (field.width * field.width) + (field.height * field.height), t = attempt * 0.8; // 0.2 * 4 = 0.8. Enlarging the spiral.\n            var result = false;\n            // Emergency brake. TODO make spiralling logic more foolproof.\n            if (attempt <= 10000) {\n                result = {\n                    x: t * Math.cos(t),\n                    y: t * Math.sin(t)\n                };\n                if (!(Math.min(Math.abs(result.x), Math.abs(result.y)) < maxDelta)) {\n                    result = false;\n                }\n            }\n            return result;\n        }\n        /**\n         * Gives a set of coordinates for an rectangular spiral.\n         *\n         * @private\n         * @function squareSpiral\n         *\n         * @param {number} attempt\n         * How far along the spiral we have traversed.\n         *\n         * @param {Highcharts.WordcloudSpiralParamsObject} [params]\n         * Additional parameters.\n         *\n         * @return {boolean|Highcharts.PositionObject}\n         * Resulting coordinates, x and y. False if the word should be dropped from\n         * the visualization.\n         */\n        function squareSpiral(attempt, \n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        params) {\n            var a = attempt * 4, k = Math.ceil((Math.sqrt(a) - 1) / 2), isBoolean = function (x) { return (typeof x === 'boolean'); };\n            var t = 2 * k + 1, m = Math.pow(t, 2), result = false;\n            t -= 1;\n            if (attempt <= 10000) {\n                if (isBoolean(result) && a >= m - t) {\n                    result = {\n                        x: k - (m - a),\n                        y: -k\n                    };\n                }\n                m -= t;\n                if (isBoolean(result) && a >= m - t) {\n                    result = {\n                        x: -k,\n                        y: -k + (m - a)\n                    };\n                }\n                m -= t;\n                if (isBoolean(result)) {\n                    if (a >= m - t) {\n                        result = {\n                            x: -k + (m - a),\n                            y: k\n                        };\n                    }\n                    else {\n                        result = {\n                            x: k,\n                            y: k - (m - a - t)\n                        };\n                    }\n                }\n                result.x *= 5;\n                result.y *= 5;\n            }\n            return result;\n        }\n        /**\n         * Gives a set of coordinates for an rectangular spiral.\n         *\n         * @private\n         * @function rectangularSpiral\n         *\n         * @param {number} attempt\n         * How far along the spiral we have traversed.\n         *\n         * @param {Highcharts.WordcloudSpiralParamsObject} [params]\n         * Additional parameters.\n         *\n         * @return {boolean|Higcharts.PositionObject}\n         * Resulting coordinates, x and y. False if the word should be dropped from\n         * the visualization.\n         */\n        function rectangularSpiral(attempt, params) {\n            var result = squareSpiral(attempt, params), field = params.field;\n            if (result) {\n                result.x *= field.ratioX;\n                result.y *= field.ratioY;\n            }\n            return result;\n        }\n        /**\n         * @private\n         * @function getRandomPosition\n         *\n         * @param {number} size\n         * Random factor.\n         *\n         * @return {number}\n         * Random position.\n         */\n        function getRandomPosition(size) {\n            return Math.round((size * (Math.random() + 0.5)) / 2);\n        }\n        /**\n         * Calculates the proper scale to fit the cloud inside the plotting area.\n         *\n         * @private\n         * @function getScale\n         *\n         * @param {number} targetWidth\n         * Width of target area.\n         *\n         * @param {number} targetHeight\n         * Height of target area.\n         *\n         * @param {Object} field\n         * The playing field.\n         *\n         * @return {number}\n         * Returns the value to scale the playing field up to the size of the target\n         * area.\n         */\n        function getScale(targetWidth, targetHeight, field) {\n            var height = Math.max(Math.abs(field.top), Math.abs(field.bottom)) * 2, width = Math.max(Math.abs(field.left), Math.abs(field.right)) * 2, scaleX = width > 0 ? 1 / width * targetWidth : 1, scaleY = height > 0 ? 1 / height * targetHeight : 1;\n            return Math.min(scaleX, scaleY);\n        }\n        /**\n         * Calculates what is called the playing field. The field is the area which\n         * all the words are allowed to be positioned within. The area is\n         * proportioned to match the target aspect ratio.\n         *\n         * @private\n         * @function getPlayingField\n         *\n         * @param {number} targetWidth\n         * Width of the target area.\n         *\n         * @param {number} targetHeight\n         * Height of the target area.\n         *\n         * @param {Array<Highcharts.Point>} data\n         * Array of points.\n         *\n         * @param {Object} data.dimensions\n         * The height and width of the word.\n         *\n         * @return {Object}\n         * The width and height of the playing field.\n         */\n        function getPlayingField(targetWidth, targetHeight, data) {\n            var info = data.reduce(function (obj, point) {\n                var dimensions = point.dimensions, x = Math.max(dimensions.width, dimensions.height);\n                // Find largest height.\n                obj.maxHeight = Math.max(obj.maxHeight, dimensions.height);\n                // Find largest width.\n                obj.maxWidth = Math.max(obj.maxWidth, dimensions.width);\n                // Sum up the total maximum area of all the words.\n                obj.area += x * x;\n                return obj;\n            }, {\n                maxHeight: 0,\n                maxWidth: 0,\n                area: 0\n            }), \n            /**\n             * Use largest width, largest height, or root of total area to give\n             * size to the playing field.\n             */\n            x = Math.max(info.maxHeight, // Have enough space for the tallest word\n            info.maxWidth, // Have enough space for the broadest word\n            // Adjust 15% to account for close packing of words\n            Math.sqrt(info.area) * 0.85), ratioX = targetWidth > targetHeight ? targetWidth / targetHeight : 1, ratioY = targetHeight > targetWidth ? targetHeight / targetWidth : 1;\n            return {\n                width: x * ratioX,\n                height: x * ratioY,\n                ratioX: ratioX,\n                ratioY: ratioY\n            };\n        }\n        /**\n         * Calculates a number of degrees to rotate, based upon a number of\n         * orientations within a range from-to.\n         *\n         * @private\n         * @function getRotation\n         *\n         * @param {number} [orientations]\n         * Number of orientations.\n         *\n         * @param {number} [index]\n         * Index of point, used to decide orientation.\n         *\n         * @param {number} [from]\n         * The smallest degree of rotation.\n         *\n         * @param {number} [to]\n         * The largest degree of rotation.\n         *\n         * @return {boolean|number}\n         * Returns the resulting rotation for the word. Returns false if invalid\n         * input parameters.\n         */\n        function getRotation(orientations, index, from, to) {\n            var result = false, // Default to false\n            range, intervals, orientation;\n            // Check if we have valid input parameters.\n            if (isNumber(orientations) &&\n                isNumber(index) &&\n                isNumber(from) &&\n                isNumber(to) &&\n                orientations > 0 &&\n                index > -1 &&\n                to > from) {\n                range = to - from;\n                intervals = range / (orientations - 1 || 1);\n                orientation = index % orientations;\n                result = from + (orientation * intervals);\n            }\n            return result;\n        }\n        /**\n         * Calculates the spiral positions and store them in scope for quick access.\n         *\n         * @private\n         * @function getSpiral\n         *\n         * @param {Function} fn\n         * The spiral function.\n         *\n         * @param {Object} params\n         * Additional parameters for the spiral.\n         *\n         * @return {Function}\n         * Function with access to spiral positions.\n         */\n        function getSpiral(fn, params) {\n            var length = 10000, arr = [];\n            for (var i = 1; i < length; i++) {\n                // @todo unnecessary amount of precalculation\n                arr.push(fn(i, params));\n            }\n            return function (attempt) { return (attempt <= length ? arr[attempt - 1] : false); };\n        }\n        /**\n         * Detects if a word is placed outside the playing field.\n         *\n         * @private\n         * @function outsidePlayingField\n         *\n         * @param {Highcharts.PolygonBoxObject} rect\n         * The word box.\n         *\n         * @param {Highcharts.WordcloudFieldObject} field\n         * The width and height of the playing field.\n         *\n         * @return {boolean}\n         * Returns true if the word is placed outside the field.\n         */\n        function outsidePlayingField(rect, field) {\n            var playingField = {\n                left: -(field.width / 2),\n                right: field.width / 2,\n                top: -(field.height / 2),\n                bottom: field.height / 2\n            };\n            return !(playingField.left < rect.left &&\n                playingField.right > rect.right &&\n                playingField.top < rect.top &&\n                playingField.bottom > rect.bottom);\n        }\n        /**\n         * @private\n         */\n        function movePolygon(deltaX, deltaY, polygon) {\n            return polygon.map(function (point) {\n                return [\n                    point[0] + deltaX,\n                    point[1] + deltaY\n                ];\n            });\n        }\n        /**\n         * Check if a point intersects with previously placed words, or if it goes\n         * outside the field boundaries. If a collision, then try to adjusts the\n         * position.\n         *\n         * @private\n         * @function intersectionTesting\n         *\n         * @param {Highcharts.Point} point\n         * Point to test for intersections.\n         *\n         * @param {Highcharts.WordcloudTestOptionsObject} options\n         * Options object.\n         *\n         * @return {boolean|Highcharts.PositionObject}\n         * Returns an object with how much to correct the positions. Returns false\n         * if the word should not be placed at all.\n         */\n        function intersectionTesting(point, options) {\n            var placed = options.placed, field = options.field, rectangle = options.rectangle, polygon = options.polygon, spiral = options.spiral, \n            // Make a copy to update values during intersection testing.\n            rect = point.rect = extend({}, rectangle);\n            var attempt = 1, delta = {\n                x: 0,\n                y: 0\n            };\n            point.polygon = polygon;\n            point.rotation = options.rotation;\n            /* While w intersects any previously placed words:\n                do {\n                move w a little bit along a spiral path\n                } while any part of w is outside the playing field and\n                        the spiral radius is still smallish */\n            while (delta !== false &&\n                (intersectsAnyWord(point, placed) ||\n                    outsidePlayingField(rect, field))) {\n                delta = spiral(attempt);\n                if (isObject(delta)) {\n                    // Update the DOMRect with new positions.\n                    rect.left = rectangle.left + delta.x;\n                    rect.right = rectangle.right + delta.x;\n                    rect.top = rectangle.top + delta.y;\n                    rect.bottom = rectangle.bottom + delta.y;\n                    point.polygon = movePolygon(delta.x, delta.y, polygon);\n                }\n                attempt++;\n            }\n            return delta;\n        }\n        /**\n         * Extends the playing field to have enough space to fit a given word.\n         *\n         * @private\n         * @function extendPlayingField\n         *\n         * @param {Highcharts.WordcloudFieldObject} field\n         * The width, height and ratios of a playing field.\n         *\n         * @param {Highcharts.PolygonBoxObject} rectangle\n         * The bounding box of the word to add space for.\n         *\n         * @return {Highcharts.WordcloudFieldObject}\n         * Returns the extended playing field with updated height and width.\n         */\n        function extendPlayingField(field, rectangle) {\n            var height, width, ratioX, ratioY, x, extendWidth, extendHeight, result;\n            if (isObject(field) && isObject(rectangle)) {\n                height = (rectangle.bottom - rectangle.top);\n                width = (rectangle.right - rectangle.left);\n                ratioX = field.ratioX;\n                ratioY = field.ratioY;\n                // Use the same variable to extend both the height and width.\n                x = ((width * ratioX) > (height * ratioY)) ? width : height;\n                // Multiply variable with ratios to preserve aspect ratio.\n                extendWidth = x * ratioX;\n                extendHeight = x * ratioY;\n                // Calculate the size of the new field after adding\n                // space for the word.\n                result = merge(field, {\n                    // Add space on the left and right.\n                    width: field.width + (extendWidth * 2),\n                    // Add space on the top and bottom.\n                    height: field.height + (extendHeight * 2)\n                });\n            }\n            else {\n                result = field;\n            }\n            // Return the new extended field.\n            return result;\n        }\n        /**\n         * If a rectangle is outside a give field, then the boundaries of the field\n         * is adjusted accordingly. Modifies the field object which is passed as the\n         * first parameter.\n         *\n         * @private\n         * @function updateFieldBoundaries\n         *\n         * @param {Highcharts.WordcloudFieldObject} field\n         * The bounding box of a playing field.\n         *\n         * @param {Highcharts.PolygonBoxObject} rectangle\n         * The bounding box for a placed point.\n         *\n         * @return {Highcharts.WordcloudFieldObject}\n         * Returns a modified field object.\n         */\n        function updateFieldBoundaries(field, rectangle) {\n            // @todo improve type checking.\n            if (!isNumber(field.left) || field.left > rectangle.left) {\n                field.left = rectangle.left;\n            }\n            if (!isNumber(field.right) || field.right < rectangle.right) {\n                field.right = rectangle.right;\n            }\n            if (!isNumber(field.top) || field.top > rectangle.top) {\n                field.top = rectangle.top;\n            }\n            if (!isNumber(field.bottom) || field.bottom < rectangle.bottom) {\n                field.bottom = rectangle.bottom;\n            }\n            return field;\n        }\n        /**\n         * Alternative solution to correctFloat.\n         * E.g Highcharts.correctFloat(123, 2) returns 120, when it should be 123.\n         *\n         * @private\n         * @function correctFloat\n         */\n        function correctFloat(number, precision) {\n            var p = isNumber(precision) ? precision : 14, magnitude = Math.pow(10, p);\n            return Math.round(number * magnitude) / magnitude;\n        }\n        /**\n         * @private\n         */\n        function getBoundingBoxFromPolygon(points) {\n            return points.reduce(function (obj, point) {\n                var x = point[0], y = point[1];\n                obj.left = Math.min(x, obj.left);\n                obj.right = Math.max(x, obj.right);\n                obj.bottom = Math.max(y, obj.bottom);\n                obj.top = Math.min(y, obj.top);\n                return obj;\n            }, {\n                left: Number.MAX_VALUE,\n                right: -Number.MAX_VALUE,\n                bottom: -Number.MAX_VALUE,\n                top: Number.MAX_VALUE\n            });\n        }\n        /**\n         * @private\n         */\n        function getPolygon(x, y, width, height, rotation) {\n            var origin = [x, y], left = x - (width / 2), right = x + (width / 2), top = y - (height / 2), bottom = y + (height / 2), polygon = [\n                [left, top],\n                [right, top],\n                [right, bottom],\n                [left, bottom]\n            ];\n            return polygon.map(function (point) {\n                return rotate2DToPoint(point, origin, -rotation);\n            });\n        }\n        /**\n         * Rotates a point clockwise around the origin.\n         *\n         * @private\n         * @function rotate2DToOrigin\n         * @param {Highcharts.PolygonPointObject} point\n         *        The x and y coordinates for the point.\n         * @param {number} angle\n         *        The angle of rotation.\n         * @return {Highcharts.PolygonPointObject}\n         *         The x and y coordinate for the rotated point.\n         */\n        function rotate2DToOrigin(point, angle) {\n            var x = point[0], y = point[1], rad = deg2rad * -angle, cosAngle = Math.cos(rad), sinAngle = Math.sin(rad);\n            return [\n                correctFloat(x * cosAngle - y * sinAngle),\n                correctFloat(x * sinAngle + y * cosAngle)\n            ];\n        }\n        /**\n         * Rotate a point clockwise around another point.\n         *\n         * @private\n         * @function rotate2DToPoint\n         * @param {Highcharts.PolygonPointObject} point\n         *        The x and y coordinates for the point.\n         * @param {Highcharts.PolygonPointObject} origin\n         *        The point to rotate around.\n         * @param {number} angle\n         *        The angle of rotation.\n         * @return {Highcharts.PolygonPointObject}\n         *         The x and y coordinate for the rotated point.\n         */\n        function rotate2DToPoint(point, origin, angle) {\n            var x = point[0] - origin[0], y = point[1] - origin[1], rotated = rotate2DToOrigin([x, y], angle);\n            return [\n                rotated[0] + origin[0],\n                rotated[1] + origin[1]\n            ];\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        var WordcloudUtils = {\n            archimedeanSpiral: archimedeanSpiral,\n            extendPlayingField: extendPlayingField,\n            getBoundingBoxFromPolygon: getBoundingBoxFromPolygon,\n            getPlayingField: getPlayingField,\n            getPolygon: getPolygon,\n            getRandomPosition: getRandomPosition,\n            getRotation: getRotation,\n            getScale: getScale,\n            getSpiral: getSpiral,\n            intersectionTesting: intersectionTesting,\n            isPolygonsColliding: isPolygonsColliding,\n            isRectanglesIntersecting: isRectanglesIntersecting,\n            rectangularSpiral: rectangularSpiral,\n            rotate2DToOrigin: rotate2DToOrigin,\n            rotate2DToPoint: rotate2DToPoint,\n            squareSpiral: squareSpiral,\n            updateFieldBoundaries: updateFieldBoundaries\n        };\n\n        return WordcloudUtils;\n    });\n    _registerModule(_modules, 'Series/Wordcloud/WordcloudSeries.js', [_modules['Series/DrawPointUtilities.js'], _modules['Core/Globals.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js'], _modules['Series/Wordcloud/WordcloudPoint.js'], _modules['Series/Wordcloud/WordcloudSeriesDefaults.js'], _modules['Series/Wordcloud/WordcloudUtils.js']], function (DPU, H, SeriesRegistry, U, WordcloudPoint, WordcloudSeriesDefaults, WU) {\n        /* *\n         *\n         *  Experimental Highcharts module which enables visualization of a word cloud.\n         *\n         *  (c) 2016-2024 Highsoft AS\n         *  Authors: Jon Arild Nygard\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         * */\n        var __extends = (this && this.__extends) || (function () {\n            var extendStatics = function (d, b) {\n                extendStatics = Object.setPrototypeOf ||\n                    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                    function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                if (typeof b !== \"function\" && b !== null)\n                    throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var noop = H.noop;\n        var ColumnSeries = SeriesRegistry.seriesTypes.column;\n        var extend = U.extend, isArray = U.isArray, isNumber = U.isNumber, isObject = U.isObject, merge = U.merge;\n        var archimedeanSpiral = WU.archimedeanSpiral, extendPlayingField = WU.extendPlayingField, getBoundingBoxFromPolygon = WU.getBoundingBoxFromPolygon, getPlayingField = WU.getPlayingField, getPolygon = WU.getPolygon, getRandomPosition = WU.getRandomPosition, getRotation = WU.getRotation, getScale = WU.getScale, getSpiral = WU.getSpiral, intersectionTesting = WU.intersectionTesting, isPolygonsColliding = WU.isPolygonsColliding, rectangularSpiral = WU.rectangularSpiral, rotate2DToOrigin = WU.rotate2DToOrigin, rotate2DToPoint = WU.rotate2DToPoint, squareSpiral = WU.squareSpiral, updateFieldBoundaries = WU.updateFieldBoundaries;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.wordcloud\n         *\n         * @augments Highcharts.Series\n         */\n        var WordcloudSeries = /** @class */ (function (_super) {\n            __extends(WordcloudSeries, _super);\n            function WordcloudSeries() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            /**\n             *\n             * Functions\n             *\n             */\n            WordcloudSeries.prototype.pointAttribs = function (point, state) {\n                var attribs = H.seriesTypes.column.prototype\n                    .pointAttribs.call(this, point, state);\n                delete attribs.stroke;\n                delete attribs['stroke-width'];\n                return attribs;\n            };\n            /**\n             * Calculates the fontSize of a word based on its weight.\n             *\n             * @private\n             * @function Highcharts.Series#deriveFontSize\n             *\n             * @param {number} [relativeWeight=0]\n             * The weight of the word, on a scale 0-1.\n             *\n             * @param {number} [maxFontSize=1]\n             * The maximum font size of a word.\n             *\n             * @param {number} [minFontSize=1]\n             * The minimum font size of a word.\n             *\n             * @return {number}\n             * Returns the resulting fontSize of a word. If minFontSize is larger then\n             * maxFontSize the result will equal minFontSize.\n             */\n            WordcloudSeries.prototype.deriveFontSize = function (relativeWeight, maxFontSize, minFontSize) {\n                var weight = isNumber(relativeWeight) ? relativeWeight : 0, max = isNumber(maxFontSize) ? maxFontSize : 1, min = isNumber(minFontSize) ? minFontSize : 1;\n                return Math.floor(Math.max(min, weight * max));\n            };\n            WordcloudSeries.prototype.drawPoints = function () {\n                var series = this, hasRendered = series.hasRendered, xAxis = series.xAxis, yAxis = series.yAxis, chart = series.chart, group = series.group, options = series.options, animation = options.animation, allowExtendPlayingField = options.allowExtendPlayingField, renderer = chart.renderer, placed = [], placementStrategy = series.placementStrategy[options.placementStrategy], rotation = options.rotation, weights = series.points.map(function (p) {\n                    return p.weight;\n                }), maxWeight = Math.max.apply(null, weights), \n                // `concat()` prevents from sorting the original array.\n                points = series.points.concat().sort(function (a, b) { return (b.weight - a.weight // Sort descending\n                ); });\n                var testElement = renderer.text().add(group), field;\n                // Reset the scale before finding the dimensions (#11993).\n                // SVGGRaphicsElement.getBBox() (used in SVGElement.getBBox(boolean))\n                // returns slightly different values for the same element depending on\n                // whether it is rendered in a group which has already defined scale\n                // (e.g. 6) or in the group without a scale (scale = 1).\n                series.group.attr({\n                    scaleX: 1,\n                    scaleY: 1\n                });\n                // Get the dimensions for each word.\n                // Used in calculating the playing field.\n                for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n                    var point = points_1[_i];\n                    var relativeWeight = 1 / maxWeight * point.weight, fontSize = series.deriveFontSize(relativeWeight, options.maxFontSize, options.minFontSize), css = extend({\n                        fontSize: fontSize + 'px'\n                    }, options.style);\n                    testElement.css(css).attr({\n                        x: 0,\n                        y: 0,\n                        text: point.name\n                    });\n                    var bBox = testElement.getBBox(true);\n                    point.dimensions = {\n                        height: bBox.height,\n                        width: bBox.width\n                    };\n                }\n                // Calculate the playing field.\n                field = getPlayingField(xAxis.len, yAxis.len, points);\n                var spiral = getSpiral(series.spirals[options.spiral], {\n                    field: field\n                });\n                // Draw all the points.\n                for (var _a = 0, points_2 = points; _a < points_2.length; _a++) {\n                    var point = points_2[_a];\n                    var relativeWeight = 1 / maxWeight * point.weight, fontSize = series.deriveFontSize(relativeWeight, options.maxFontSize, options.minFontSize), css = extend({\n                        fontSize: fontSize + 'px'\n                    }, options.style), placement = placementStrategy(point, {\n                        data: points,\n                        field: field,\n                        placed: placed,\n                        rotation: rotation\n                    }), attr = extend(series.pointAttribs(point, (point.selected && 'select')), {\n                        align: 'center',\n                        'alignment-baseline': 'middle',\n                        'dominant-baseline': 'middle', // #15973: Firefox\n                        x: placement.x,\n                        y: placement.y,\n                        text: point.name,\n                        rotation: isNumber(placement.rotation) ?\n                            placement.rotation :\n                            void 0\n                    }), polygon = getPolygon(placement.x, placement.y, point.dimensions.width, point.dimensions.height, placement.rotation), rectangle = getBoundingBoxFromPolygon(polygon);\n                    var delta = intersectionTesting(point, {\n                        rectangle: rectangle,\n                        polygon: polygon,\n                        field: field,\n                        placed: placed,\n                        spiral: spiral,\n                        rotation: placement.rotation\n                    }), animate = void 0;\n                    // If there is no space for the word, extend the playing field.\n                    if (!delta && allowExtendPlayingField) {\n                        // Extend the playing field to fit the word.\n                        field = extendPlayingField(field, rectangle);\n                        // Run intersection testing one more time to place the word.\n                        delta = intersectionTesting(point, {\n                            rectangle: rectangle,\n                            polygon: polygon,\n                            field: field,\n                            placed: placed,\n                            spiral: spiral,\n                            rotation: placement.rotation\n                        });\n                    }\n                    // Check if point was placed, if so delete it, otherwise place it\n                    // on the correct positions.\n                    if (isObject(delta)) {\n                        attr.x = (attr.x || 0) + delta.x;\n                        attr.y = (attr.y || 0) + delta.y;\n                        rectangle.left += delta.x;\n                        rectangle.right += delta.x;\n                        rectangle.top += delta.y;\n                        rectangle.bottom += delta.y;\n                        field = updateFieldBoundaries(field, rectangle);\n                        placed.push(point);\n                        point.isNull = false;\n                        point.isInside = true; // #15447\n                    }\n                    else {\n                        point.isNull = true;\n                    }\n                    if (animation) {\n                        // Animate to new positions\n                        animate = {\n                            x: attr.x,\n                            y: attr.y\n                        };\n                        // Animate from center of chart\n                        if (!hasRendered) {\n                            attr.x = 0;\n                            attr.y = 0;\n                            // Or animate from previous position\n                        }\n                        else {\n                            delete attr.x;\n                            delete attr.y;\n                        }\n                    }\n                    DPU.draw(point, {\n                        animatableAttribs: animate,\n                        attribs: attr,\n                        css: css,\n                        group: group,\n                        renderer: renderer,\n                        shapeArgs: void 0,\n                        shapeType: 'text'\n                    });\n                }\n                // Destroy the element after use.\n                testElement = testElement.destroy();\n                // Scale the series group to fit within the plotArea.\n                var scale = getScale(xAxis.len, yAxis.len, field);\n                series.group.attr({\n                    scaleX: scale,\n                    scaleY: scale\n                });\n            };\n            WordcloudSeries.prototype.hasData = function () {\n                var series = this;\n                return (isObject(series) &&\n                    series.visible === true &&\n                    isArray(series.points) &&\n                    series.points.length > 0);\n            };\n            WordcloudSeries.prototype.getPlotBox = function () {\n                var series = this, chart = series.chart, inverted = chart.inverted, \n                // Swap axes for inverted (#2339)\n                xAxis = series[(inverted ? 'yAxis' : 'xAxis')], yAxis = series[(inverted ? 'xAxis' : 'yAxis')], width = xAxis ? xAxis.len : chart.plotWidth, height = yAxis ? yAxis.len : chart.plotHeight, x = xAxis ? xAxis.left : chart.plotLeft, y = yAxis ? yAxis.top : chart.plotTop;\n                return {\n                    translateX: x + (width / 2),\n                    translateY: y + (height / 2),\n                    scaleX: 1, // #1623\n                    scaleY: 1\n                };\n            };\n            /* *\n             *\n             *  Static properties\n             *\n             * */\n            WordcloudSeries.defaultOptions = merge(ColumnSeries.defaultOptions, WordcloudSeriesDefaults);\n            return WordcloudSeries;\n        }(ColumnSeries));\n        extend(WordcloudSeries.prototype, {\n            animate: noop,\n            animateDrilldown: noop,\n            animateDrillupFrom: noop,\n            isCartesian: false,\n            pointClass: WordcloudPoint,\n            setClip: noop,\n            // Strategies used for deciding rotation and initial position of a word. To\n            // implement a custom strategy, have a look at the function random for\n            // example.\n            placementStrategy: {\n                random: function (point, options) {\n                    var field = options.field, r = options.rotation;\n                    return {\n                        x: getRandomPosition(field.width) - (field.width / 2),\n                        y: getRandomPosition(field.height) - (field.height / 2),\n                        rotation: getRotation(r.orientations, point.index, r.from, r.to)\n                    };\n                },\n                center: function (point, options) {\n                    var r = options.rotation;\n                    return {\n                        x: 0,\n                        y: 0,\n                        rotation: getRotation(r.orientations, point.index, r.from, r.to)\n                    };\n                }\n            },\n            pointArrayMap: ['weight'],\n            // Spirals used for placing a word after the initial position experienced a\n            // collision with either another word or the borders. To implement a custom\n            // spiral, look at the function archimedeanSpiral for example.\n            spirals: {\n                'archimedean': archimedeanSpiral,\n                'rectangular': rectangularSpiral,\n                'square': squareSpiral\n            },\n            utils: {\n                extendPlayingField: extendPlayingField,\n                getRotation: getRotation,\n                isPolygonsColliding: isPolygonsColliding,\n                rotate2DToOrigin: rotate2DToOrigin,\n                rotate2DToPoint: rotate2DToPoint\n            }\n        });\n        SeriesRegistry.registerSeriesType('wordcloud', WordcloudSeries);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return WordcloudSeries;\n    });\n    _registerModule(_modules, 'masters/modules/wordcloud.src.js', [_modules['Core/Globals.js']], function (Highcharts) {\n\n\n        return Highcharts;\n    });\n}));\n"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","win","dispatchEvent","detail","__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","call","draw","point","params","animatableAttribs","onComplete","css","renderer","animation","series","chart","hasRendered","options","graphic","attribs","getClassName","shouldDraw","shapeType","text","image","imageUrl","attr","shapeArgs","add","group","animate","isNew","destroy_1","destroy","keys","SeriesRegistry","U","extendStatics","__extends","d","b","setPrototypeOf","__proto__","Array","TypeError","String","__","constructor","create","ColumnPoint","seriesTypes","column","pointClass","extend","WordcloudPoint","_super","isValid","weight","allowExtendPlayingField","duration","borderWidth","clip","colorByPoint","cropThreshold","Infinity","minFontSize","maxFontSize","placementStrategy","rotation","from","orientations","to","showInLegend","spiral","style","fontFamily","fontWeight","whiteSpace","tooltip","followPointer","pointFormat","H","deg2rad","find","isNumber","isObject","merge","isRectanglesIntersecting","r1","r2","left","right","top","bottom","getAxesFromPolygon","polygon","points","axes","concat","reduce","p1","p2","dx","dy","axis","normals","existing","push","project","target","products","map","ax","ay","min","Math","max","isPolygonsColliding","polygon1","polygon2","axes1","axes2","projection1","projection2","squareSpiral","attempt","a","k","ceil","sqrt","isBoolean","x","m","pow","result","y","correctFloat","number","precision","magnitude","round","rotate2DToOrigin","angle","rad","cosAngle","cos","sinAngle","sin","rotate2DToPoint","origin","rotated","archimedeanSpiral","field","maxDelta","width","height","abs","extendPlayingField","rectangle","ratioX","ratioY","extendWidth","extendHeight","getBoundingBoxFromPolygon","Number","MAX_VALUE","getPlayingField","targetWidth","targetHeight","data","info","dimensions","maxHeight","maxWidth","area","getPolygon","getRandomPosition","size","random","getRotation","index","intervals","range","orientation","getScale","getSpiral","arr","intersectionTesting","rect","lastCollidedWith","isIntersecting","intersects","playingField","placed","delta","intersectsAnyWord","movePolygon","deltaX","deltaY","rectangularSpiral","updateFieldBoundaries","DPU","WordcloudSeriesDefaults","WU","noop","ColumnSeries","isArray","WordcloudSeries","pointAttribs","state","stroke","deriveFontSize","relativeWeight","floor","drawPoints","xAxis","yAxis","weights","maxWeight","sort","testElement","scaleX","scaleY","_i","points_1","fontSize","name","bBox","getBBox","len","spirals","_a","points_2","placement","selected","align","isNull","isInside","scale","hasData","visible","getPlotBox","inverted","plotWidth","plotHeight","translateX","plotLeft","translateY","plotTop","defaultOptions","animateDrilldown","animateDrillupFrom","isCartesian","setClip","r","center","pointArrayMap","utils","registerSeriesType"],"mappings":"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"}
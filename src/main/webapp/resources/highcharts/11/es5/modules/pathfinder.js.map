{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts Gantt JS v11.4.8 (2024-08-29)\n *\n * Pathfinder\n *\n * (c) 2016-2024 Øystein Moseng\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/pathfinder', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                Highcharts.win.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Gantt/Connection.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Authors: Øystein Moseng, Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var defined = U.defined, error = U.error, merge = U.merge, objectEach = U.objectEach;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        var deg2rad = H.deg2rad, max = Math.max, min = Math.min;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The Connection class. Used internally to represent a connection between two\n         * points.\n         *\n         * @private\n         * @class\n         * @name Highcharts.Connection\n         *\n         * @param {Highcharts.Point} from\n         *        Connection runs from this Point.\n         *\n         * @param {Highcharts.Point} to\n         *        Connection runs to this Point.\n         *\n         * @param {Highcharts.ConnectorsOptions} [options]\n         *        Connection options.\n         */\n        var Connection = /** @class */ (function () {\n            function Connection(from, to, options) {\n                this.init(from, to, options);\n            }\n            /**\n             * Initialize the Connection object. Used as constructor only.\n             *\n             * @function Highcharts.Connection#init\n             *\n             * @param {Highcharts.Point} from\n             *        Connection runs from this Point.\n             *\n             * @param {Highcharts.Point} to\n             *        Connection runs to this Point.\n             *\n             * @param {Highcharts.ConnectorsOptions} [options]\n             *        Connection options.\n             */\n            Connection.prototype.init = function (from, to, options) {\n                this.fromPoint = from;\n                this.toPoint = to;\n                this.options = options;\n                this.chart = from.series.chart;\n                this.pathfinder = this.chart.pathfinder;\n            };\n            /**\n             * Add (or update) this connection's path on chart. Stores reference to the\n             * created element on this.graphics.path.\n             *\n             * @function Highcharts.Connection#renderPath\n             *\n             * @param {Highcharts.SVGPathArray} path\n             *        Path to render, in array format. E.g. ['M', 0, 0, 'L', 10, 10]\n             *\n             * @param {Highcharts.SVGAttributes} [attribs]\n             *        SVG attributes for the path.\n             *\n             * @param {Partial<Highcharts.AnimationOptionsObject>} [animation]\n             *        Animation options for the rendering.\n             */\n            Connection.prototype.renderPath = function (path, attribs) {\n                var connection = this, chart = this.chart, styledMode = chart.styledMode, pathfinder = this.pathfinder, anim = {};\n                var pathGraphic = connection.graphics && connection.graphics.path;\n                // Add the SVG element of the pathfinder group if it doesn't exist\n                if (!pathfinder.group) {\n                    pathfinder.group = chart.renderer.g()\n                        .addClass('highcharts-pathfinder-group')\n                        .attr({ zIndex: -1 })\n                        .add(chart.seriesGroup);\n                }\n                // Shift the group to compensate for plot area.\n                // Note: Do this always (even when redrawing a path) to avoid issues\n                // when updating chart in a way that changes plot metrics.\n                pathfinder.group.translate(chart.plotLeft, chart.plotTop);\n                // Create path if does not exist\n                if (!(pathGraphic && pathGraphic.renderer)) {\n                    pathGraphic = chart.renderer.path()\n                        .add(pathfinder.group);\n                    if (!styledMode) {\n                        pathGraphic.attr({\n                            opacity: 0\n                        });\n                    }\n                }\n                // Set path attribs and animate to the new path\n                pathGraphic.attr(attribs);\n                anim.d = path;\n                if (!styledMode) {\n                    anim.opacity = 1;\n                }\n                pathGraphic.animate(anim);\n                // Store reference on connection\n                this.graphics = this.graphics || {};\n                this.graphics.path = pathGraphic;\n            };\n            /**\n             * Calculate and add marker graphics for connection to the chart. The\n             * created/updated elements are stored on this.graphics.start and\n             * this.graphics.end.\n             *\n             * @function Highcharts.Connection#addMarker\n             *\n             * @param {string} type\n             *        Marker type, either 'start' or 'end'.\n             *\n             * @param {Highcharts.ConnectorsMarkerOptions} options\n             *        All options for this marker. Not calculated or merged with other\n             *        options.\n             *\n             * @param {Highcharts.SVGPathArray} path\n             *        Connection path in array format. This is used to calculate the\n             *        rotation angle of the markers.\n             */\n            Connection.prototype.addMarker = function (type, options, path) {\n                var connection = this, chart = connection.fromPoint.series.chart, pathfinder = chart.pathfinder, renderer = chart.renderer, point = (type === 'start' ?\n                    connection.fromPoint :\n                    connection.toPoint), anchor = point.getPathfinderAnchorPoint(options);\n                var markerVector, radians, rotation, box, width, height, pathVector, segment;\n                if (!options.enabled) {\n                    return;\n                }\n                // Last vector before start/end of path, used to get angle\n                if (type === 'start') {\n                    segment = path[1];\n                }\n                else { // 'end'\n                    segment = path[path.length - 2];\n                }\n                if (segment && segment[0] === 'M' || segment[0] === 'L') {\n                    pathVector = {\n                        x: segment[1],\n                        y: segment[2]\n                    };\n                    // Get angle between pathVector and anchor point and use it to\n                    // create marker position.\n                    radians = point.getRadiansToVector(pathVector, anchor);\n                    markerVector = point.getMarkerVector(radians, options.radius, anchor);\n                    // Rotation of marker is calculated from angle between pathVector\n                    // and markerVector.\n                    // (Note:\n                    //  Used to recalculate radians between markerVector and pathVector,\n                    //  but this should be the same as between pathVector and anchor.)\n                    rotation = -radians / deg2rad;\n                    if (options.width && options.height) {\n                        width = options.width;\n                        height = options.height;\n                    }\n                    else {\n                        width = height = options.radius * 2;\n                    }\n                    // Add graphics object if it does not exist\n                    connection.graphics = connection.graphics || {};\n                    box = {\n                        x: markerVector.x - (width / 2),\n                        y: markerVector.y - (height / 2),\n                        width: width,\n                        height: height,\n                        rotation: rotation,\n                        rotationOriginX: markerVector.x,\n                        rotationOriginY: markerVector.y\n                    };\n                    if (!connection.graphics[type]) {\n                        // Create new marker element\n                        connection.graphics[type] = renderer\n                            .symbol(options.symbol)\n                            .addClass('highcharts-point-connecting-path-' + type + '-marker' +\n                            ' highcharts-color-' + this.fromPoint.colorIndex)\n                            .attr(box)\n                            .add(pathfinder.group);\n                        if (!renderer.styledMode) {\n                            connection.graphics[type].attr({\n                                fill: options.color || connection.fromPoint.color,\n                                stroke: options.lineColor,\n                                'stroke-width': options.lineWidth,\n                                opacity: 0\n                            })\n                                .animate({\n                                opacity: 1\n                            }, point.series.options.animation);\n                        }\n                    }\n                    else {\n                        connection.graphics[type].animate(box);\n                    }\n                }\n            };\n            /**\n             * Calculate and return connection path.\n             * Note: Recalculates chart obstacles on demand if they aren't calculated.\n             *\n             * @function Highcharts.Connection#getPath\n             *\n             * @param {Highcharts.ConnectorsOptions} options\n             *        Connector options. Not calculated or merged with other options.\n             *\n             * @return {object|undefined}\n             *         Calculated SVG path data in array format.\n             */\n            Connection.prototype.getPath = function (options) {\n                var pathfinder = this.pathfinder, chart = this.chart, algorithm = pathfinder.algorithms[options.type];\n                var chartObstacles = pathfinder.chartObstacles;\n                if (typeof algorithm !== 'function') {\n                    error('\"' + options.type + '\" is not a Pathfinder algorithm.');\n                    return {\n                        path: [],\n                        obstacles: []\n                    };\n                }\n                // This function calculates obstacles on demand if they don't exist\n                if (algorithm.requiresObstacles && !chartObstacles) {\n                    chartObstacles =\n                        pathfinder.chartObstacles =\n                            pathfinder.getChartObstacles(options);\n                    // If the algorithmMargin was computed, store the result in default\n                    // options.\n                    chart.options.connectors.algorithmMargin =\n                        options.algorithmMargin;\n                    // Cache some metrics too\n                    pathfinder.chartObstacleMetrics =\n                        pathfinder.getObstacleMetrics(chartObstacles);\n                }\n                // Get the SVG path\n                return algorithm(\n                // From\n                this.fromPoint.getPathfinderAnchorPoint(options.startMarker), \n                // To\n                this.toPoint.getPathfinderAnchorPoint(options.endMarker), merge({\n                    chartObstacles: chartObstacles,\n                    lineObstacles: pathfinder.lineObstacles || [],\n                    obstacleMetrics: pathfinder.chartObstacleMetrics,\n                    hardBounds: {\n                        xMin: 0,\n                        xMax: chart.plotWidth,\n                        yMin: 0,\n                        yMax: chart.plotHeight\n                    },\n                    obstacleOptions: {\n                        margin: options.algorithmMargin\n                    },\n                    startDirectionX: pathfinder.getAlgorithmStartDirection(options.startMarker)\n                }, options));\n            };\n            /**\n             * (re)Calculate and (re)draw the connection.\n             *\n             * @function Highcharts.Connection#render\n             */\n            Connection.prototype.render = function () {\n                var connection = this, fromPoint = connection.fromPoint, series = fromPoint.series, chart = series.chart, pathfinder = chart.pathfinder, attribs = {};\n                var options = merge(chart.options.connectors, series.options.connectors, fromPoint.options.connectors, connection.options);\n                // Set path attribs\n                if (!chart.styledMode) {\n                    attribs.stroke = options.lineColor || fromPoint.color;\n                    attribs['stroke-width'] = options.lineWidth;\n                    if (options.dashStyle) {\n                        attribs.dashstyle = options.dashStyle;\n                    }\n                }\n                attribs['class'] = // eslint-disable-line dot-notation\n                    'highcharts-point-connecting-path ' +\n                        'highcharts-color-' + fromPoint.colorIndex;\n                options = merge(attribs, options);\n                // Set common marker options\n                if (!defined(options.marker.radius)) {\n                    options.marker.radius = min(max(Math.ceil((options.algorithmMargin || 8) / 2) - 1, 1), 5);\n                }\n                // Get the path\n                var pathResult = connection.getPath(options), path = pathResult.path;\n                // Always update obstacle storage with obstacles from this path.\n                // We don't know if future calls will need this for their algorithm.\n                if (pathResult.obstacles) {\n                    pathfinder.lineObstacles =\n                        pathfinder.lineObstacles || [];\n                    pathfinder.lineObstacles =\n                        pathfinder.lineObstacles.concat(pathResult.obstacles);\n                }\n                // Add the calculated path to the pathfinder group\n                connection.renderPath(path, attribs);\n                // Render the markers\n                connection.addMarker('start', merge(options.marker, options.startMarker), path);\n                connection.addMarker('end', merge(options.marker, options.endMarker), path);\n            };\n            /**\n             * Destroy connection by destroying the added graphics elements.\n             *\n             * @function Highcharts.Connection#destroy\n             */\n            Connection.prototype.destroy = function () {\n                if (this.graphics) {\n                    objectEach(this.graphics, function (val) {\n                        val.destroy();\n                    });\n                    delete this.graphics;\n                }\n            };\n            return Connection;\n        }());\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Declarations\n         *\n         * */\n        /**\n         * The default pathfinder algorithm to use for a chart. It is possible to define\n         * your own algorithms by adding them to the\n         * `Highcharts.Pathfinder.prototype.algorithms`\n         * object before the chart has been created.\n         *\n         * The default algorithms are as follows:\n         *\n         * `straight`:      Draws a straight line between the connecting\n         *                  points. Does not avoid other points when drawing.\n         *\n         * `simpleConnect`: Finds a path between the points using right angles\n         *                  only. Takes only starting/ending points into\n         *                  account, and will not avoid other points.\n         *\n         * `fastAvoid`:     Finds a path between the points using right angles\n         *                  only. Will attempt to avoid other points, but its\n         *                  focus is performance over accuracy. Works well with\n         *                  less dense datasets.\n         *\n         * @typedef {\"fastAvoid\"|\"simpleConnect\"|\"straight\"|string} Highcharts.PathfinderTypeValue\n         */\n        ''; // Keeps doclets above in JS file\n\n        return Connection;\n    });\n    _registerModule(_modules, 'Series/PathUtilities.js', [], function () {\n        /* *\n         *\n         *  (c) 2010-2024 Pawel Lysy\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var getLinkPath = {\n            'default': getDefaultPath,\n            straight: getStraightPath,\n            curved: getCurvedPath\n        };\n        /**\n         *\n         */\n        function getDefaultPath(pathParams) {\n            var x1 = pathParams.x1, y1 = pathParams.y1, x2 = pathParams.x2, y2 = pathParams.y2, _a = pathParams.width, width = _a === void 0 ? 0 : _a, _b = pathParams.inverted, inverted = _b === void 0 ? false : _b, radius = pathParams.radius, parentVisible = pathParams.parentVisible;\n            var path = [\n                ['M', x1, y1],\n                ['L', x1, y1],\n                ['C', x1, y1, x1, y2, x1, y2],\n                ['L', x1, y2],\n                ['C', x1, y1, x1, y2, x1, y2],\n                ['L', x1, y2]\n            ];\n            return parentVisible ?\n                applyRadius([\n                    ['M', x1, y1],\n                    ['L', x1 + width * (inverted ? -0.5 : 0.5), y1],\n                    ['L', x1 + width * (inverted ? -0.5 : 0.5), y2],\n                    ['L', x2, y2]\n                ], radius) :\n                path;\n        }\n        /**\n         *\n         */\n        function getStraightPath(pathParams) {\n            var x1 = pathParams.x1, y1 = pathParams.y1, x2 = pathParams.x2, y2 = pathParams.y2, _a = pathParams.width, width = _a === void 0 ? 0 : _a, _b = pathParams.inverted, inverted = _b === void 0 ? false : _b, parentVisible = pathParams.parentVisible;\n            return parentVisible ? [\n                ['M', x1, y1],\n                ['L', x1 + width * (inverted ? -1 : 1), y2],\n                ['L', x2, y2]\n            ] : [\n                ['M', x1, y1],\n                ['L', x1, y2],\n                ['L', x1, y2]\n            ];\n        }\n        /**\n         *\n         */\n        function getCurvedPath(pathParams) {\n            var x1 = pathParams.x1, y1 = pathParams.y1, x2 = pathParams.x2, y2 = pathParams.y2, _a = pathParams.offset, offset = _a === void 0 ? 0 : _a, _b = pathParams.width, width = _b === void 0 ? 0 : _b, _c = pathParams.inverted, inverted = _c === void 0 ? false : _c, parentVisible = pathParams.parentVisible;\n            return parentVisible ?\n                [\n                    ['M', x1, y1],\n                    [\n                        'C',\n                        x1 + offset,\n                        y1,\n                        x1 - offset + width * (inverted ? -1 : 1),\n                        y2,\n                        x1 + width * (inverted ? -1 : 1),\n                        y2\n                    ],\n                    ['L', x2, y2]\n                ] :\n                [\n                    ['M', x1, y1],\n                    ['C', x1, y1, x1, y2, x1, y2],\n                    ['L', x2, y2]\n                ];\n        }\n        /**\n         * General function to apply corner radius to a path\n         * @private\n         */\n        function applyRadius(path, r) {\n            var d = [];\n            for (var i = 0; i < path.length; i++) {\n                var x = path[i][1];\n                var y = path[i][2];\n                if (typeof x === 'number' && typeof y === 'number') {\n                    // MoveTo\n                    if (i === 0) {\n                        d.push(['M', x, y]);\n                    }\n                    else if (i === path.length - 1) {\n                        d.push(['L', x, y]);\n                        // CurveTo\n                    }\n                    else if (r) {\n                        var prevSeg = path[i - 1];\n                        var nextSeg = path[i + 1];\n                        if (prevSeg && nextSeg) {\n                            var x1 = prevSeg[1], y1 = prevSeg[2], x2 = nextSeg[1], y2 = nextSeg[2];\n                            // Only apply to breaks\n                            if (typeof x1 === 'number' &&\n                                typeof x2 === 'number' &&\n                                typeof y1 === 'number' &&\n                                typeof y2 === 'number' &&\n                                x1 !== x2 &&\n                                y1 !== y2) {\n                                var directionX = x1 < x2 ? 1 : -1, directionY = y1 < y2 ? 1 : -1;\n                                d.push([\n                                    'L',\n                                    x - directionX * Math.min(Math.abs(x - x1), r),\n                                    y - directionY * Math.min(Math.abs(y - y1), r)\n                                ], [\n                                    'C',\n                                    x,\n                                    y,\n                                    x,\n                                    y,\n                                    x + directionX * Math.min(Math.abs(x - x2), r),\n                                    y + directionY * Math.min(Math.abs(y - y2), r)\n                                ]);\n                            }\n                        }\n                        // LineTo\n                    }\n                    else {\n                        d.push(['L', x, y]);\n                    }\n                }\n            }\n            return d;\n        }\n        var PathUtilities = {\n            applyRadius: applyRadius,\n            getLinkPath: getLinkPath\n        };\n\n        return PathUtilities;\n    });\n    _registerModule(_modules, 'Gantt/PathfinderAlgorithms.js', [_modules['Series/PathUtilities.js'], _modules['Core/Utilities.js']], function (PathUtilities, U) {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Author: Øystein Moseng\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var pick = U.pick;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        var min = Math.min, max = Math.max, abs = Math.abs;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Get index of last obstacle before xMin. Employs a type of binary search, and\n         * thus requires that obstacles are sorted by xMin value.\n         *\n         * @private\n         * @function findLastObstacleBefore\n         *\n         * @param {Array<object>} obstacles\n         *        Array of obstacles to search in.\n         *\n         * @param {number} xMin\n         *        The xMin threshold.\n         *\n         * @param {number} [startIx]\n         *        Starting index to search from. Must be within array range.\n         *\n         * @return {number}\n         *         The index of the last obstacle element before xMin.\n         */\n        function findLastObstacleBefore(obstacles, xMin, startIx) {\n            var min = xMin - 0.0000001; // Make sure we include all obstacles at xMin\n            var left = startIx || 0, // Left limit\n            right = obstacles.length - 1, // Right limit\n            cursor, cmp;\n            while (left <= right) {\n                cursor = (right + left) >> 1;\n                cmp = min - obstacles[cursor].xMin;\n                if (cmp > 0) {\n                    left = cursor + 1;\n                }\n                else if (cmp < 0) {\n                    right = cursor - 1;\n                }\n                else {\n                    return cursor;\n                }\n            }\n            return left > 0 ? left - 1 : 0;\n        }\n        /**\n         * Test if a point lays within an obstacle.\n         *\n         * @private\n         * @function pointWithinObstacle\n         *\n         * @param {Object} obstacle\n         *        Obstacle to test.\n         *\n         * @param {Highcharts.Point} point\n         *        Point with x/y props.\n         *\n         * @return {boolean}\n         *         Whether point is within the obstacle or not.\n         */\n        function pointWithinObstacle(obstacle, point) {\n            return (point.x <= obstacle.xMax &&\n                point.x >= obstacle.xMin &&\n                point.y <= obstacle.yMax &&\n                point.y >= obstacle.yMin);\n        }\n        /**\n         * Find the index of an obstacle that wraps around a point.\n         * Returns -1 if not found.\n         *\n         * @private\n         * @function findObstacleFromPoint\n         *\n         * @param {Array<object>} obstacles\n         *        Obstacles to test.\n         *\n         * @param {Highcharts.Point} point\n         *        Point with x/y props.\n         *\n         * @return {number}\n         *         Ix of the obstacle in the array, or -1 if not found.\n         */\n        function findObstacleFromPoint(obstacles, point) {\n            var i = findLastObstacleBefore(obstacles, point.x + 1) + 1;\n            while (i--) {\n                if (obstacles[i].xMax >= point.x &&\n                    // Optimization using lazy evaluation\n                    pointWithinObstacle(obstacles[i], point)) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n        /**\n         * Get SVG path array from array of line segments.\n         *\n         * @private\n         * @function pathFromSegments\n         *\n         * @param {Array<object>} segments\n         *        The segments to build the path from.\n         *\n         * @return {Highcharts.SVGPathArray}\n         *         SVG path array as accepted by the SVG Renderer.\n         */\n        function pathFromSegments(segments) {\n            var path = [];\n            if (segments.length) {\n                path.push(['M', segments[0].start.x, segments[0].start.y]);\n                for (var i = 0; i < segments.length; ++i) {\n                    path.push(['L', segments[i].end.x, segments[i].end.y]);\n                }\n            }\n            return path;\n        }\n        /**\n         * Limits obstacle max/mins in all directions to bounds. Modifies input\n         * obstacle.\n         *\n         * @private\n         * @function limitObstacleToBounds\n         *\n         * @param {Object} obstacle\n         *        Obstacle to limit.\n         *\n         * @param {Object} bounds\n         *        Bounds to use as limit.\n         *\n         * @return {void}\n         */\n        function limitObstacleToBounds(obstacle, bounds) {\n            obstacle.yMin = max(obstacle.yMin, bounds.yMin);\n            obstacle.yMax = min(obstacle.yMax, bounds.yMax);\n            obstacle.xMin = max(obstacle.xMin, bounds.xMin);\n            obstacle.xMax = min(obstacle.xMax, bounds.xMax);\n        }\n        /**\n         * Get an SVG path from a starting coordinate to an ending coordinate.\n         * Draws a straight line.\n         *\n         * @function Highcharts.Pathfinder.algorithms.straight\n         *\n         * @param {Highcharts.PositionObject} start\n         *        Starting coordinate, object with x/y props.\n         *\n         * @param {Highcharts.PositionObject} end\n         *        Ending coordinate, object with x/y props.\n         *\n         * @return {Object}\n         *         An object with the SVG path in Array form as accepted by the SVG\n         *         renderer, as well as an array of new obstacles making up this\n         *         path.\n         */\n        function straight(start, end) {\n            return {\n                path: [\n                    ['M', start.x, start.y],\n                    ['L', end.x, end.y]\n                ],\n                obstacles: [{ start: start, end: end }]\n            };\n        }\n        /**\n         * Find a path from a starting coordinate to an ending coordinate, using\n         * right angles only, and taking only starting/ending obstacle into\n         * consideration.\n         *\n         * @function Highcharts.Pathfinder.algorithms.simpleConnect\n         *\n         * @param {Highcharts.PositionObject} start\n         *        Starting coordinate, object with x/y props.\n         *\n         * @param {Highcharts.PositionObject} end\n         *        Ending coordinate, object with x/y props.\n         *\n         * @param {Object} options\n         *        Options for the algorithm:\n         *        - chartObstacles: Array of chart obstacles to avoid\n         *        - startDirectionX: Optional. True if starting in the X direction.\n         *          If not provided, the algorithm starts in the direction that is\n         *          the furthest between start/end.\n         *\n         * @return {Object}\n         *         An object with the SVG path in Array form as accepted by the SVG\n         *         renderer, as well as an array of new obstacles making up this\n         *         path.\n         */\n        var simpleConnect = function (start, end, options) {\n            var segments = [], chartObstacles = options.chartObstacles, startObstacleIx = findObstacleFromPoint(chartObstacles, start), endObstacleIx = findObstacleFromPoint(chartObstacles, end);\n            var endSegment, dir = pick(options.startDirectionX, abs(end.x - start.x) > abs(end.y - start.y)) ? 'x' : 'y', startObstacle, endObstacle, waypoint, useMax, endPoint;\n            // eslint-disable-next-line valid-jsdoc\n            /**\n             * Return a clone of a point with a property set from a target object,\n             * optionally with an offset\n             * @private\n             */\n            function copyFromPoint(from, fromKey, to, toKey, offset) {\n                var point = {\n                    x: from.x,\n                    y: from.y\n                };\n                point[fromKey] = to[toKey || fromKey] + (offset || 0);\n                return point;\n            }\n            // eslint-disable-next-line valid-jsdoc\n            /**\n             * Return waypoint outside obstacle.\n             * @private\n             */\n            function getMeOut(obstacle, point, direction) {\n                var useMax = abs(point[direction] - obstacle[direction + 'Min']) >\n                    abs(point[direction] - obstacle[direction + 'Max']);\n                return copyFromPoint(point, direction, obstacle, direction + (useMax ? 'Max' : 'Min'), useMax ? 1 : -1);\n            }\n            // Pull out end point\n            if (endObstacleIx > -1) {\n                endObstacle = chartObstacles[endObstacleIx];\n                waypoint = getMeOut(endObstacle, end, dir);\n                endSegment = {\n                    start: waypoint,\n                    end: end\n                };\n                endPoint = waypoint;\n            }\n            else {\n                endPoint = end;\n            }\n            // If an obstacle envelops the start point, add a segment to get out,\n            // and around it.\n            if (startObstacleIx > -1) {\n                startObstacle = chartObstacles[startObstacleIx];\n                waypoint = getMeOut(startObstacle, start, dir);\n                segments.push({\n                    start: start,\n                    end: waypoint\n                });\n                // If we are going back again, switch direction to get around start\n                // obstacle.\n                if (\n                // Going towards max from start:\n                waypoint[dir] >= start[dir] ===\n                    // Going towards min to end:\n                    waypoint[dir] >= endPoint[dir]) {\n                    dir = dir === 'y' ? 'x' : 'y';\n                    useMax = start[dir] < end[dir];\n                    segments.push({\n                        start: waypoint,\n                        end: copyFromPoint(waypoint, dir, startObstacle, dir + (useMax ? 'Max' : 'Min'), useMax ? 1 : -1)\n                    });\n                    // Switch direction again\n                    dir = dir === 'y' ? 'x' : 'y';\n                }\n            }\n            // We are around the start obstacle. Go towards the end in one\n            // direction.\n            var prevWaypoint = segments.length ?\n                segments[segments.length - 1].end :\n                start;\n            waypoint = copyFromPoint(prevWaypoint, dir, endPoint);\n            segments.push({\n                start: prevWaypoint,\n                end: waypoint\n            });\n            // Final run to end point in the other direction\n            dir = dir === 'y' ? 'x' : 'y';\n            var waypoint2 = copyFromPoint(waypoint, dir, endPoint);\n            segments.push({\n                start: waypoint,\n                end: waypoint2\n            });\n            // Finally add the endSegment\n            segments.push(endSegment);\n            var path = PathUtilities.applyRadius(pathFromSegments(segments), options.radius);\n            return {\n                path: path,\n                obstacles: segments\n            };\n        };\n        simpleConnect.requiresObstacles = true;\n        /**\n         * Find a path from a starting coordinate to an ending coordinate, taking\n         * obstacles into consideration. Might not always find the optimal path,\n         * but is fast, and usually good enough.\n         *\n         * @function Highcharts.Pathfinder.algorithms.fastAvoid\n         *\n         * @param {Highcharts.PositionObject} start\n         *        Starting coordinate, object with x/y props.\n         *\n         * @param {Highcharts.PositionObject} end\n         *        Ending coordinate, object with x/y props.\n         *\n         * @param {Object} options\n         *        Options for the algorithm.\n         *        - chartObstacles:  Array of chart obstacles to avoid\n         *        - lineObstacles:   Array of line obstacles to jump over\n         *        - obstacleMetrics: Object with metrics of chartObstacles cached\n         *        - hardBounds:      Hard boundaries to not cross\n         *        - obstacleOptions: Options for the obstacles, including margin\n         *        - startDirectionX: Optional. True if starting in the X direction.\n         *                           If not provided, the algorithm starts in the\n         *                           direction that is the furthest between\n         *                           start/end.\n         *\n         * @return {Object}\n         *         An object with the SVG path in Array form as accepted by the SVG\n         *         renderer, as well as an array of new obstacles making up this\n         *         path.\n         */\n        function fastAvoid(start, end, options) {\n            /*\n                Algorithm rules/description\n                - Find initial direction\n                - Determine soft/hard max for each direction.\n                - Move along initial direction until obstacle.\n                - Change direction.\n                - If hitting obstacle, first try to change length of previous line\n                    before changing direction again.\n\n                Soft min/max x = start/destination x +/- widest obstacle + margin\n                Soft min/max y = start/destination y +/- tallest obstacle + margin\n\n                @todo:\n                    - Make retrospective, try changing prev segment to reduce\n                        corners\n                    - Fix logic for breaking out of end-points - not always picking\n                        the best direction currently\n                    - When going around the end obstacle we should not always go the\n                        shortest route, rather pick the one closer to the end point\n            */\n            var dirIsX = pick(options.startDirectionX, abs(end.x - start.x) > abs(end.y - start.y)), dir = dirIsX ? 'x' : 'y', endSegments = [], \n            // Boundaries to stay within. If beyond soft boundary, prefer to\n            // change direction ASAP. If at hard max, always change immediately.\n            metrics = options.obstacleMetrics, softMinX = min(start.x, end.x) - metrics.maxWidth - 10, softMaxX = max(start.x, end.x) + metrics.maxWidth + 10, softMinY = min(start.y, end.y) - metrics.maxHeight - 10, softMaxY = max(start.y, end.y) + metrics.maxHeight + 10;\n            var segments, useMax, extractedEndPoint, forceObstacleBreak = false, // Used in clearPathTo to keep track of\n            // when to force break through an obstacle.\n            // Obstacles\n            chartObstacles = options.chartObstacles, endObstacleIx = findLastObstacleBefore(chartObstacles, softMaxX);\n            var startObstacleIx = findLastObstacleBefore(chartObstacles, softMinX);\n            // eslint-disable-next-line valid-jsdoc\n            /**\n             * How far can you go between two points before hitting an obstacle?\n             * Does not work for diagonal lines (because it doesn't have to).\n             * @private\n             */\n            function pivotPoint(fromPoint, toPoint, directionIsX) {\n                var searchDirection = fromPoint.x < toPoint.x ? 1 : -1;\n                var firstPoint, lastPoint, highestPoint, lowestPoint;\n                if (fromPoint.x < toPoint.x) {\n                    firstPoint = fromPoint;\n                    lastPoint = toPoint;\n                }\n                else {\n                    firstPoint = toPoint;\n                    lastPoint = fromPoint;\n                }\n                if (fromPoint.y < toPoint.y) {\n                    lowestPoint = fromPoint;\n                    highestPoint = toPoint;\n                }\n                else {\n                    lowestPoint = toPoint;\n                    highestPoint = fromPoint;\n                }\n                // Go through obstacle range in reverse if toPoint is before\n                // fromPoint in the X-dimension.\n                var i = searchDirection < 0 ?\n                    // Searching backwards, start at last obstacle before last point\n                    min(findLastObstacleBefore(chartObstacles, lastPoint.x), chartObstacles.length - 1) :\n                    // Forwards. Since we're not sorted by xMax, we have to look\n                    // at all obstacles.\n                    0;\n                // Go through obstacles in this X range\n                while (chartObstacles[i] && (searchDirection > 0 && chartObstacles[i].xMin <= lastPoint.x ||\n                    searchDirection < 0 && chartObstacles[i].xMax >= firstPoint.x)) {\n                    // If this obstacle is between from and to points in a straight\n                    // line, pivot at the intersection.\n                    if (chartObstacles[i].xMin <= lastPoint.x &&\n                        chartObstacles[i].xMax >= firstPoint.x &&\n                        chartObstacles[i].yMin <= highestPoint.y &&\n                        chartObstacles[i].yMax >= lowestPoint.y) {\n                        if (directionIsX) {\n                            return {\n                                y: fromPoint.y,\n                                x: fromPoint.x < toPoint.x ?\n                                    chartObstacles[i].xMin - 1 :\n                                    chartObstacles[i].xMax + 1,\n                                obstacle: chartObstacles[i]\n                            };\n                        }\n                        // Else ...\n                        return {\n                            x: fromPoint.x,\n                            y: fromPoint.y < toPoint.y ?\n                                chartObstacles[i].yMin - 1 :\n                                chartObstacles[i].yMax + 1,\n                            obstacle: chartObstacles[i]\n                        };\n                    }\n                    i += searchDirection;\n                }\n                return toPoint;\n            }\n            /**\n             * Decide in which direction to dodge or get out of an obstacle.\n             * Considers desired direction, which way is shortest, soft and hard\n             * bounds.\n             *\n             * (? Returns a string, either xMin, xMax, yMin or yMax.)\n             *\n             * @private\n             * @function\n             *\n             * @param {Object} obstacle\n             *        Obstacle to dodge/escape.\n             *\n             * @param {Object} fromPoint\n             *        Point with x/y props that's dodging/escaping.\n             *\n             * @param {Object} toPoint\n             *        Goal point.\n             *\n             * @param {boolean} dirIsX\n             *        Dodge in X dimension.\n             *\n             * @param {Object} bounds\n             *        Hard and soft boundaries.\n             *\n             * @return {boolean}\n             *         Use max or not.\n             */\n            function getDodgeDirection(obstacle, fromPoint, toPoint, dirIsX, bounds) {\n                var softBounds = bounds.soft, hardBounds = bounds.hard, dir = dirIsX ? 'x' : 'y', toPointMax = { x: fromPoint.x, y: fromPoint.y }, toPointMin = { x: fromPoint.x, y: fromPoint.y }, maxOutOfSoftBounds = obstacle[dir + 'Max'] >=\n                    softBounds[dir + 'Max'], minOutOfSoftBounds = obstacle[dir + 'Min'] <=\n                    softBounds[dir + 'Min'], maxOutOfHardBounds = obstacle[dir + 'Max'] >=\n                    hardBounds[dir + 'Max'], minOutOfHardBounds = obstacle[dir + 'Min'] <=\n                    hardBounds[dir + 'Min'], \n                // Find out if we should prefer one direction over the other if\n                // we can choose freely\n                minDistance = abs(obstacle[dir + 'Min'] - fromPoint[dir]), maxDistance = abs(obstacle[dir + 'Max'] - fromPoint[dir]);\n                var // If it's a small difference, pick the one leading towards dest\n                // point. Otherwise pick the shortest distance\n                useMax = abs(minDistance - maxDistance) < 10 ?\n                    fromPoint[dir] < toPoint[dir] :\n                    maxDistance < minDistance;\n                // Check if we hit any obstacles trying to go around in either\n                // direction.\n                toPointMin[dir] = obstacle[dir + 'Min'];\n                toPointMax[dir] = obstacle[dir + 'Max'];\n                var minPivot = pivotPoint(fromPoint, toPointMin, dirIsX)[dir] !==\n                    toPointMin[dir], maxPivot = pivotPoint(fromPoint, toPointMax, dirIsX)[dir] !==\n                    toPointMax[dir];\n                useMax = minPivot ?\n                    (maxPivot ? useMax : true) :\n                    (maxPivot ? false : useMax);\n                // `useMax` now contains our preferred choice, bounds not taken into\n                // account. If both or neither direction is out of bounds we want to\n                // use this.\n                // Deal with soft bounds\n                useMax = minOutOfSoftBounds ?\n                    (maxOutOfSoftBounds ? useMax : true) : // Out on min\n                    (maxOutOfSoftBounds ? false : useMax); // Not out on min\n                // Deal with hard bounds\n                useMax = minOutOfHardBounds ?\n                    (maxOutOfHardBounds ? useMax : true) : // Out on min\n                    (maxOutOfHardBounds ? false : useMax); // Not out on min\n                return useMax;\n            }\n            // eslint-disable-next-line valid-jsdoc\n            /**\n             * Find a clear path between point.\n             * @private\n             */\n            function clearPathTo(fromPoint, toPoint, dirIsX) {\n                // Don't waste time if we've hit goal\n                if (fromPoint.x === toPoint.x && fromPoint.y === toPoint.y) {\n                    return [];\n                }\n                var dir = dirIsX ? 'x' : 'y', obstacleMargin = options.obstacleOptions.margin, bounds = {\n                    soft: {\n                        xMin: softMinX,\n                        xMax: softMaxX,\n                        yMin: softMinY,\n                        yMax: softMaxY\n                    },\n                    hard: options.hardBounds\n                };\n                var pivot, segments, waypoint, waypointUseMax, envelopingObstacle, secondEnvelopingObstacle, envelopWaypoint;\n                // If fromPoint is inside an obstacle we have a problem. Break out\n                // by just going to the outside of this obstacle. We prefer to go to\n                // the nearest edge in the chosen direction.\n                envelopingObstacle =\n                    findObstacleFromPoint(chartObstacles, fromPoint);\n                if (envelopingObstacle > -1) {\n                    envelopingObstacle = chartObstacles[envelopingObstacle];\n                    waypointUseMax = getDodgeDirection(envelopingObstacle, fromPoint, toPoint, dirIsX, bounds);\n                    // Cut obstacle to hard bounds to make sure we stay within\n                    limitObstacleToBounds(envelopingObstacle, options.hardBounds);\n                    envelopWaypoint = dirIsX ? {\n                        y: fromPoint.y,\n                        x: envelopingObstacle[waypointUseMax ? 'xMax' : 'xMin'] +\n                            (waypointUseMax ? 1 : -1)\n                    } : {\n                        x: fromPoint.x,\n                        y: envelopingObstacle[waypointUseMax ? 'yMax' : 'yMin'] +\n                            (waypointUseMax ? 1 : -1)\n                    };\n                    // If we crashed into another obstacle doing this, we put the\n                    // waypoint between them instead\n                    secondEnvelopingObstacle = findObstacleFromPoint(chartObstacles, envelopWaypoint);\n                    if (secondEnvelopingObstacle > -1) {\n                        secondEnvelopingObstacle = chartObstacles[secondEnvelopingObstacle];\n                        // Cut obstacle to hard bounds\n                        limitObstacleToBounds(secondEnvelopingObstacle, options.hardBounds);\n                        // Modify waypoint to lay between obstacles\n                        envelopWaypoint[dir] = waypointUseMax ? max(envelopingObstacle[dir + 'Max'] - obstacleMargin + 1, (secondEnvelopingObstacle[dir + 'Min'] +\n                            envelopingObstacle[dir + 'Max']) / 2) :\n                            min((envelopingObstacle[dir + 'Min'] + obstacleMargin - 1), ((secondEnvelopingObstacle[dir + 'Max'] +\n                                envelopingObstacle[dir + 'Min']) / 2));\n                        // We are not going anywhere. If this happens for the first\n                        // time, do nothing. Otherwise, try to go to the extreme of\n                        // the obstacle pair in the current direction.\n                        if (fromPoint.x === envelopWaypoint.x &&\n                            fromPoint.y === envelopWaypoint.y) {\n                            if (forceObstacleBreak) {\n                                envelopWaypoint[dir] = waypointUseMax ?\n                                    max(envelopingObstacle[dir + 'Max'], secondEnvelopingObstacle[dir + 'Max']) + 1 :\n                                    min(envelopingObstacle[dir + 'Min'], secondEnvelopingObstacle[dir + 'Min']) - 1;\n                            }\n                            // Toggle on if off, and the opposite\n                            forceObstacleBreak = !forceObstacleBreak;\n                        }\n                        else {\n                            // This point is not identical to previous.\n                            // Clear break trigger.\n                            forceObstacleBreak = false;\n                        }\n                    }\n                    segments = [{\n                            start: fromPoint,\n                            end: envelopWaypoint\n                        }];\n                }\n                else { // If not enveloping, use standard pivot calculation\n                    pivot = pivotPoint(fromPoint, {\n                        x: dirIsX ? toPoint.x : fromPoint.x,\n                        y: dirIsX ? fromPoint.y : toPoint.y\n                    }, dirIsX);\n                    segments = [{\n                            start: fromPoint,\n                            end: {\n                                x: pivot.x,\n                                y: pivot.y\n                            }\n                        }];\n                    // Pivot before goal, use a waypoint to dodge obstacle\n                    if (pivot[dirIsX ? 'x' : 'y'] !== toPoint[dirIsX ? 'x' : 'y']) {\n                        // Find direction of waypoint\n                        waypointUseMax = getDodgeDirection(pivot.obstacle, pivot, toPoint, !dirIsX, bounds);\n                        // Cut waypoint to hard bounds\n                        limitObstacleToBounds(pivot.obstacle, options.hardBounds);\n                        waypoint = {\n                            x: dirIsX ?\n                                pivot.x :\n                                pivot.obstacle[waypointUseMax ? 'xMax' : 'xMin'] +\n                                    (waypointUseMax ? 1 : -1),\n                            y: dirIsX ?\n                                pivot.obstacle[waypointUseMax ? 'yMax' : 'yMin'] +\n                                    (waypointUseMax ? 1 : -1) :\n                                pivot.y\n                        };\n                        // We're changing direction here, store that to make sure we\n                        // also change direction when adding the last segment array\n                        // after handling waypoint.\n                        dirIsX = !dirIsX;\n                        segments = segments.concat(clearPathTo({\n                            x: pivot.x,\n                            y: pivot.y\n                        }, waypoint, dirIsX));\n                    }\n                }\n                // Get segments for the other direction too\n                // Recursion is our friend\n                segments = segments.concat(clearPathTo(segments[segments.length - 1].end, toPoint, !dirIsX));\n                return segments;\n            }\n            // eslint-disable-next-line valid-jsdoc\n            /**\n             * Extract point to outside of obstacle in whichever direction is\n             * closest. Returns new point outside obstacle.\n             * @private\n             */\n            function extractFromObstacle(obstacle, point, goalPoint) {\n                var dirIsX = min(obstacle.xMax - point.x, point.x - obstacle.xMin) <\n                    min(obstacle.yMax - point.y, point.y - obstacle.yMin), bounds = {\n                    soft: options.hardBounds,\n                    hard: options.hardBounds\n                }, useMax = getDodgeDirection(obstacle, point, goalPoint, dirIsX, bounds);\n                return dirIsX ? {\n                    y: point.y,\n                    x: obstacle[useMax ? 'xMax' : 'xMin'] + (useMax ? 1 : -1)\n                } : {\n                    x: point.x,\n                    y: obstacle[useMax ? 'yMax' : 'yMin'] + (useMax ? 1 : -1)\n                };\n            }\n            // Cut the obstacle array to soft bounds for optimization in large\n            // datasets.\n            chartObstacles =\n                chartObstacles.slice(startObstacleIx, endObstacleIx + 1);\n            // If an obstacle envelops the end point, move it out of there and add\n            // a little segment to where it was.\n            if ((endObstacleIx = findObstacleFromPoint(chartObstacles, end)) > -1) {\n                extractedEndPoint = extractFromObstacle(chartObstacles[endObstacleIx], end, start);\n                endSegments.push({\n                    end: end,\n                    start: extractedEndPoint\n                });\n                end = extractedEndPoint;\n            }\n            // If it's still inside one or more obstacles, get out of there by\n            // force-moving towards the start point.\n            while ((endObstacleIx = findObstacleFromPoint(chartObstacles, end)) > -1) {\n                useMax = end[dir] - start[dir] < 0;\n                extractedEndPoint = {\n                    x: end.x,\n                    y: end.y\n                };\n                extractedEndPoint[dir] = chartObstacles[endObstacleIx][useMax ? dir + 'Max' : dir + 'Min'] + (useMax ? 1 : -1);\n                endSegments.push({\n                    end: end,\n                    start: extractedEndPoint\n                });\n                end = extractedEndPoint;\n            }\n            // Find the path\n            segments = clearPathTo(start, end, dirIsX);\n            // Add the end-point segments\n            segments = segments.concat(endSegments.reverse());\n            return {\n                path: pathFromSegments(segments),\n                obstacles: segments\n            };\n        }\n        fastAvoid.requiresObstacles = true;\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        // Define the available pathfinding algorithms.\n        // Algorithms take up to 3 arguments: starting point, ending point, and an\n        // options object.\n        var algorithms = {\n            fastAvoid: fastAvoid,\n            straight: straight,\n            simpleConnect: simpleConnect\n        };\n\n        return algorithms;\n    });\n    _registerModule(_modules, 'Gantt/ConnectorsDefaults.js', [], function () {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Authors: Øystein Moseng, Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  API Defaults\n         *\n         * */\n        /*\n         @todo:\n             - Document how to write your own algorithms\n             - Consider adding a Point.pathTo method that wraps creating a connection\n               and rendering it\n        */\n        var connectorsDefaults = {\n            /**\n             * The Pathfinder module allows you to define connections between any two\n             * points, represented as lines - optionally with markers for the start\n             * and/or end points. Multiple algorithms are available for calculating how\n             * the connecting lines are drawn.\n             *\n             * Connector functionality requires Highcharts Gantt to be loaded. In Gantt\n             * charts, the connectors are used to draw dependencies between tasks.\n             *\n             * @see [dependency](series.gantt.data.dependency)\n             *\n             * @sample gantt/pathfinder/demo\n             *         Pathfinder connections\n             *\n             * @declare      Highcharts.ConnectorsOptions\n             * @product      gantt\n             * @optionparent connectors\n             */\n            connectors: {\n                /**\n                 * Enable connectors for this chart. Requires Highcharts Gantt.\n                 *\n                 * @type      {boolean}\n                 * @default   true\n                 * @since     6.2.0\n                 * @apioption connectors.enabled\n                 */\n                /**\n                 * Set the default dash style for this chart's connecting lines.\n                 *\n                 * @type      {string}\n                 * @default   solid\n                 * @since     6.2.0\n                 * @apioption connectors.dashStyle\n                 */\n                /**\n                 * Set the default color for this chart's Pathfinder connecting lines.\n                 * Defaults to the color of the point being connected.\n                 *\n                 * @type      {Highcharts.ColorString}\n                 * @since     6.2.0\n                 * @apioption connectors.lineColor\n                 */\n                /**\n                 * Set the default pathfinder margin to use, in pixels. Some Pathfinder\n                 * algorithms attempt to avoid obstacles, such as other points in the\n                 * chart. These algorithms use this margin to determine how close lines\n                 * can be to an obstacle. The default is to compute this automatically\n                 * from the size of the obstacles in the chart.\n                 *\n                 * To draw connecting lines close to existing points, set this to a low\n                 * number. For more space around existing points, set this number\n                 * higher.\n                 *\n                 * @sample gantt/pathfinder/algorithm-margin\n                 *         Small algorithmMargin\n                 *\n                 * @type      {number}\n                 * @since     6.2.0\n                 * @apioption connectors.algorithmMargin\n                 */\n                /**\n                 * Set the default pathfinder algorithm to use for this chart. It is\n                 * possible to define your own algorithms by adding them to the\n                 * Highcharts.Pathfinder.prototype.algorithms object before the chart\n                 * has been created.\n                 *\n                 * The default algorithms are as follows:\n                 *\n                 * `straight`:      Draws a straight line between the connecting\n                 *                  points. Does not avoid other points when drawing.\n                 *\n                 * `simpleConnect`: Finds a path between the points using right angles\n                 *                  only. Takes only starting/ending points into\n                 *                  account, and will not avoid other points.\n                 *\n                 * `fastAvoid`:     Finds a path between the points using right angles\n                 *                  only. Will attempt to avoid other points, but its\n                 *                  focus is performance over accuracy. Works well with\n                 *                  less dense datasets.\n                 *\n                 * Default value: `straight` is used as default for most series types,\n                 * while `simpleConnect` is used as default for Gantt series, to show\n                 * dependencies between points.\n                 *\n                 * @sample gantt/pathfinder/demo\n                 *         Different types used\n                 *\n                 * @type    {Highcharts.PathfinderTypeValue}\n                 * @default undefined\n                 * @since   6.2.0\n                 */\n                type: 'straight',\n                /**\n                 * The corner radius for the connector line.\n                 *\n                 * @since 11.2.0\n                 */\n                radius: 0,\n                /**\n                 * Set the default pixel width for this chart's Pathfinder connecting\n                 * lines.\n                 *\n                 * @since 6.2.0\n                 */\n                lineWidth: 1,\n                /**\n                 * Marker options for this chart's Pathfinder connectors. Note that\n                 * this option is overridden by the `startMarker` and `endMarker`\n                 * options.\n                 *\n                 * @declare Highcharts.ConnectorsMarkerOptions\n                 * @since   6.2.0\n                 */\n                marker: {\n                    /**\n                     * Set the radius of the connector markers. The default is\n                     * automatically computed based on the algorithmMargin setting.\n                     *\n                     * Setting marker.width and marker.height will override this\n                     * setting.\n                     *\n                     * @type      {number}\n                     * @since     6.2.0\n                     * @apioption connectors.marker.radius\n                     */\n                    /**\n                     * Set the width of the connector markers. If not supplied, this\n                     * is inferred from the marker radius.\n                     *\n                     * @type      {number}\n                     * @since     6.2.0\n                     * @apioption connectors.marker.width\n                     */\n                    /**\n                     * Set the height of the connector markers. If not supplied, this\n                     * is inferred from the marker radius.\n                     *\n                     * @type      {number}\n                     * @since     6.2.0\n                     * @apioption connectors.marker.height\n                     */\n                    /**\n                     * Set the color of the connector markers. By default this is the\n                     * same as the connector color.\n                     *\n                     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                     * @since     6.2.0\n                     * @apioption connectors.marker.color\n                     */\n                    /**\n                     * Set the line/border color of the connector markers. By default\n                     * this is the same as the marker color.\n                     *\n                     * @type      {Highcharts.ColorString}\n                     * @since     6.2.0\n                     * @apioption connectors.marker.lineColor\n                     */\n                    /**\n                     * Enable markers for the connectors.\n                     */\n                    enabled: false,\n                    /**\n                     * Horizontal alignment of the markers relative to the points.\n                     *\n                     * @type {Highcharts.AlignValue}\n                     */\n                    align: 'center',\n                    /**\n                     * Vertical alignment of the markers relative to the points.\n                     *\n                     * @type {Highcharts.VerticalAlignValue}\n                     */\n                    verticalAlign: 'middle',\n                    /**\n                     * Whether or not to draw the markers inside the points.\n                     */\n                    inside: false,\n                    /**\n                     * Set the line/border width of the pathfinder markers.\n                     */\n                    lineWidth: 1\n                },\n                /**\n                 * Marker options specific to the start markers for this chart's\n                 * Pathfinder connectors. Overrides the generic marker options.\n                 *\n                 * @declare Highcharts.ConnectorsStartMarkerOptions\n                 * @extends connectors.marker\n                 * @since   6.2.0\n                 */\n                startMarker: {\n                    /**\n                     * Set the symbol of the connector start markers.\n                     */\n                    symbol: 'diamond'\n                },\n                /**\n                 * Marker options specific to the end markers for this chart's\n                 * Pathfinder connectors. Overrides the generic marker options.\n                 *\n                 * @declare Highcharts.ConnectorsEndMarkerOptions\n                 * @extends connectors.marker\n                 * @since   6.2.0\n                 */\n                endMarker: {\n                    /**\n                     * Set the symbol of the connector end markers.\n                     */\n                    symbol: 'arrow-filled'\n                }\n            }\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * Override Pathfinder connector options for a series. Requires Highcharts Gantt\n         * to be loaded.\n         *\n         * @declare   Highcharts.SeriesConnectorsOptionsObject\n         * @extends   connectors\n         * @since     6.2.0\n         * @excluding enabled, algorithmMargin\n         * @product   gantt\n         * @apioption plotOptions.series.connectors\n         */\n        /**\n         * Connect to a point. This option can be either a string, referring to the ID\n         * of another point, or an object, or an array of either. If the option is an\n         * array, each element defines a connection.\n         *\n         * @sample gantt/pathfinder/demo\n         *         Different connection types\n         *\n         * @declare   Highcharts.XrangePointConnectorsOptionsObject\n         * @type      {string|Array<string|*>|*}\n         * @extends   plotOptions.series.connectors\n         * @since     6.2.0\n         * @excluding enabled\n         * @product   gantt\n         * @requires  highcharts-gantt\n         * @apioption series.xrange.data.connect\n         */\n        /**\n         * The ID of the point to connect to.\n         *\n         * @type      {string}\n         * @since     6.2.0\n         * @product   gantt\n         * @apioption series.xrange.data.connect.to\n         */\n        ''; // Keeps doclets above in JS file\n\n        return connectorsDefaults;\n    });\n    _registerModule(_modules, 'Gantt/PathfinderComposition.js', [_modules['Gantt/ConnectorsDefaults.js'], _modules['Core/Defaults.js'], _modules['Core/Utilities.js']], function (ConnectorsDefaults, D, U) {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Authors: Øystein Moseng, Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var setOptions = D.setOptions;\n        var defined = U.defined, error = U.error, merge = U.merge;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Get point bounding box using plotX/plotY and shapeArgs. If using\n         * graphic.getBBox() directly, the bbox will be affected by animation.\n         *\n         * @private\n         * @function\n         *\n         * @param {Highcharts.Point} point\n         *        The point to get BB of.\n         *\n         * @return {Highcharts.Dictionary<number>|null}\n         *         Result xMax, xMin, yMax, yMin.\n         */\n        function getPointBB(point) {\n            var shapeArgs = point.shapeArgs;\n            // Prefer using shapeArgs (columns)\n            if (shapeArgs) {\n                return {\n                    xMin: shapeArgs.x || 0,\n                    xMax: (shapeArgs.x || 0) + (shapeArgs.width || 0),\n                    yMin: shapeArgs.y || 0,\n                    yMax: (shapeArgs.y || 0) + (shapeArgs.height || 0)\n                };\n            }\n            // Otherwise use plotX/plotY and bb\n            var bb = point.graphic && point.graphic.getBBox();\n            return bb ? {\n                xMin: point.plotX - bb.width / 2,\n                xMax: point.plotX + bb.width / 2,\n                yMin: point.plotY - bb.height / 2,\n                yMax: point.plotY + bb.height / 2\n            } : null;\n        }\n        /**\n         * Warn if using legacy options. Copy the options over. Note that this will\n         * still break if using the legacy options in chart.update, addSeries etc.\n         * @private\n         */\n        function warnLegacy(chart) {\n            if (chart.options.pathfinder ||\n                chart.series.reduce(function (acc, series) {\n                    if (series.options) {\n                        merge(true, (series.options.connectors = series.options.connectors ||\n                            {}), series.options.pathfinder);\n                    }\n                    return acc || series.options && series.options.pathfinder;\n                }, false)) {\n                merge(true, (chart.options.connectors = chart.options.connectors || {}), chart.options.pathfinder);\n                error('WARNING: Pathfinder options have been renamed. ' +\n                    'Use \"chart.connectors\" or \"series.connectors\" instead.');\n            }\n        }\n        /* *\n         *\n         *  Composition\n         *\n         * */\n        var ConnectionComposition;\n        (function (ConnectionComposition) {\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /** @private */\n            function compose(ChartClass, PathfinderClass, PointClass) {\n                var pointProto = PointClass.prototype;\n                if (!pointProto.getPathfinderAnchorPoint) {\n                    // Initialize Pathfinder for charts\n                    ChartClass.prototype.callbacks.push(function (chart) {\n                        var options = chart.options;\n                        if (options.connectors.enabled !== false) {\n                            warnLegacy(chart);\n                            this.pathfinder = new PathfinderClass(this);\n                            this.pathfinder.update(true); // First draw, defer render\n                        }\n                    });\n                    pointProto.getMarkerVector = pointGetMarkerVector;\n                    pointProto.getPathfinderAnchorPoint = pointGetPathfinderAnchorPoint;\n                    pointProto.getRadiansToVector = pointGetRadiansToVector;\n                    // Set default Pathfinder options\n                    setOptions(ConnectorsDefaults);\n                }\n            }\n            ConnectionComposition.compose = compose;\n            /**\n             * Get coordinates of anchor point for pathfinder connection.\n             *\n             * @private\n             * @function Highcharts.Point#getPathfinderAnchorPoint\n             *\n             * @param {Highcharts.ConnectorsMarkerOptions} markerOptions\n             *        Connection options for position on point.\n             *\n             * @return {Highcharts.PositionObject}\n             *         An object with x/y properties for the position. Coordinates are\n             *         in plot values, not relative to point.\n             */\n            function pointGetPathfinderAnchorPoint(markerOptions) {\n                var bb = getPointBB(this);\n                var x, y;\n                switch (markerOptions.align) { // eslint-disable-line default-case\n                    case 'right':\n                        x = 'xMax';\n                        break;\n                    case 'left':\n                        x = 'xMin';\n                }\n                switch (markerOptions.verticalAlign) { // eslint-disable-line default-case\n                    case 'top':\n                        y = 'yMin';\n                        break;\n                    case 'bottom':\n                        y = 'yMax';\n                }\n                return {\n                    x: x ? bb[x] : (bb.xMin + bb.xMax) / 2,\n                    y: y ? bb[y] : (bb.yMin + bb.yMax) / 2\n                };\n            }\n            /**\n             * Utility to get the angle from one point to another.\n             *\n             * @private\n             * @function Highcharts.Point#getRadiansToVector\n             *\n             * @param {Highcharts.PositionObject} v1\n             *        The first vector, as an object with x/y properties.\n             *\n             * @param {Highcharts.PositionObject} v2\n             *        The second vector, as an object with x/y properties.\n             *\n             * @return {number}\n             *         The angle in degrees\n             */\n            function pointGetRadiansToVector(v1, v2) {\n                var box;\n                if (!defined(v2)) {\n                    box = getPointBB(this);\n                    if (box) {\n                        v2 = {\n                            x: (box.xMin + box.xMax) / 2,\n                            y: (box.yMin + box.yMax) / 2\n                        };\n                    }\n                }\n                return Math.atan2(v2.y - v1.y, v1.x - v2.x);\n            }\n            /**\n             * Utility to get the position of the marker, based on the path angle and\n             * the marker's radius.\n             *\n             * @private\n             * @function Highcharts.Point#getMarkerVector\n             *\n             * @param {number} radians\n             *        The angle in radians from the point center to another vector.\n             *\n             * @param {number} markerRadius\n             *        The radius of the marker, to calculate the additional distance to\n             *        the center of the marker.\n             *\n             * @param {Object} anchor\n             *        The anchor point of the path and marker as an object with x/y\n             *        properties.\n             *\n             * @return {Object}\n             *         The marker vector as an object with x/y properties.\n             */\n            function pointGetMarkerVector(radians, markerRadius, anchor) {\n                var twoPI = Math.PI * 2.0, bb = getPointBB(this), rectWidth = bb.xMax - bb.xMin, rectHeight = bb.yMax - bb.yMin, rAtan = Math.atan2(rectHeight, rectWidth), rectHalfWidth = rectWidth / 2.0, rectHalfHeight = rectHeight / 2.0, rectHorizontalCenter = bb.xMin + rectHalfWidth, rectVerticalCenter = bb.yMin + rectHalfHeight, edgePoint = {\n                    x: rectHorizontalCenter,\n                    y: rectVerticalCenter\n                };\n                var theta = radians, tanTheta = 1, leftOrRightRegion = false, xFactor = 1, yFactor = 1;\n                while (theta < -Math.PI) {\n                    theta += twoPI;\n                }\n                while (theta > Math.PI) {\n                    theta -= twoPI;\n                }\n                tanTheta = Math.tan(theta);\n                if ((theta > -rAtan) && (theta <= rAtan)) {\n                    // Right side\n                    yFactor = -1;\n                    leftOrRightRegion = true;\n                }\n                else if (theta > rAtan && theta <= (Math.PI - rAtan)) {\n                    // Top side\n                    yFactor = -1;\n                }\n                else if (theta > (Math.PI - rAtan) || theta <= -(Math.PI - rAtan)) {\n                    // Left side\n                    xFactor = -1;\n                    leftOrRightRegion = true;\n                }\n                else {\n                    // Bottom side\n                    xFactor = -1;\n                }\n                // Correct the edgePoint according to the placement of the marker\n                if (leftOrRightRegion) {\n                    edgePoint.x += xFactor * (rectHalfWidth);\n                    edgePoint.y += yFactor * (rectHalfWidth) * tanTheta;\n                }\n                else {\n                    edgePoint.x += xFactor * (rectHeight / (2.0 * tanTheta));\n                    edgePoint.y += yFactor * (rectHalfHeight);\n                }\n                if (anchor.x !== rectHorizontalCenter) {\n                    edgePoint.x = anchor.x;\n                }\n                if (anchor.y !== rectVerticalCenter) {\n                    edgePoint.y = anchor.y;\n                }\n                return {\n                    x: edgePoint.x + (markerRadius * Math.cos(theta)),\n                    y: edgePoint.y - (markerRadius * Math.sin(theta))\n                };\n            }\n        })(ConnectionComposition || (ConnectionComposition = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ConnectionComposition;\n    });\n    _registerModule(_modules, 'Gantt/Pathfinder.js', [_modules['Gantt/Connection.js'], _modules['Gantt/PathfinderAlgorithms.js'], _modules['Gantt/PathfinderComposition.js'], _modules['Core/Series/Point.js'], _modules['Core/Utilities.js']], function (Connection, PathfinderAlgorithms, PathfinderComposition, Point, U) {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Authors: Øystein Moseng, Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var addEvent = U.addEvent, defined = U.defined, pick = U.pick, splat = U.splat;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        var max = Math.max, min = Math.min;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Get point bounding box using plotX/plotY and shapeArgs. If using\n         * graphic.getBBox() directly, the bbox will be affected by animation.\n         *\n         * @private\n         * @function\n         *\n         * @param {Highcharts.Point} point\n         *        The point to get BB of.\n         *\n         * @return {Highcharts.Dictionary<number>|null}\n         *         Result xMax, xMin, yMax, yMin.\n         */\n        function getPointBB(point) {\n            var shapeArgs = point.shapeArgs;\n            // Prefer using shapeArgs (columns)\n            if (shapeArgs) {\n                return {\n                    xMin: shapeArgs.x || 0,\n                    xMax: (shapeArgs.x || 0) + (shapeArgs.width || 0),\n                    yMin: shapeArgs.y || 0,\n                    yMax: (shapeArgs.y || 0) + (shapeArgs.height || 0)\n                };\n            }\n            // Otherwise use plotX/plotY and bb\n            var bb = point.graphic && point.graphic.getBBox();\n            return bb ? {\n                xMin: point.plotX - bb.width / 2,\n                xMax: point.plotX + bb.width / 2,\n                yMin: point.plotY - bb.height / 2,\n                yMax: point.plotY + bb.height / 2\n            } : null;\n        }\n        /**\n         * Compute smallest distance between two rectangles.\n         * @private\n         */\n        function calculateObstacleDistance(a, b, bbMargin) {\n            // Count the distance even if we are slightly off\n            var margin = pick(bbMargin, 10), yOverlap = a.yMax + margin > b.yMin - margin &&\n                a.yMin - margin < b.yMax + margin, xOverlap = a.xMax + margin > b.xMin - margin &&\n                a.xMin - margin < b.xMax + margin, xDistance = yOverlap ? (a.xMin > b.xMax ? a.xMin - b.xMax : b.xMin - a.xMax) : Infinity, yDistance = xOverlap ? (a.yMin > b.yMax ? a.yMin - b.yMax : b.yMin - a.yMax) : Infinity;\n            // If the rectangles collide, try recomputing with smaller margin.\n            // If they collide anyway, discard the obstacle.\n            if (xOverlap && yOverlap) {\n                return (margin ?\n                    calculateObstacleDistance(a, b, Math.floor(margin / 2)) :\n                    Infinity);\n            }\n            return min(xDistance, yDistance);\n        }\n        /**\n         * Calculate margin to place around obstacles for the pathfinder in pixels.\n         * Returns a minimum of 1 pixel margin.\n         *\n         * @private\n         * @function\n         *\n         * @param {Array<object>} obstacles\n         *        Obstacles to calculate margin from.\n         *\n         * @return {number}\n         *         The calculated margin in pixels. At least 1.\n         */\n        function calculateObstacleMargin(obstacles) {\n            var len = obstacles.length, distances = [];\n            var onstacleDistance;\n            // Go over all obstacles and compare them to the others.\n            for (var i = 0; i < len; ++i) {\n                // Compare to all obstacles ahead. We will already have compared this\n                // obstacle to the ones before.\n                for (var j = i + 1; j < len; ++j) {\n                    onstacleDistance =\n                        calculateObstacleDistance(obstacles[i], obstacles[j]);\n                    // TODO: Magic number 80\n                    if (onstacleDistance < 80) { // Ignore large distances\n                        distances.push(onstacleDistance);\n                    }\n                }\n            }\n            // Ensure we always have at least one value, even in very spacious charts\n            distances.push(80);\n            return max(Math.floor(distances.sort(function (a, b) {\n                return (a - b);\n            })[\n            // Discard first 10% of the relevant distances, and then grab\n            // the smallest one.\n            Math.floor(distances.length / 10)] / 2 - 1 // Divide the distance by 2 and subtract 1.\n            ), 1 // 1 is the minimum margin\n            );\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The Pathfinder class.\n         *\n         * @private\n         * @class\n         * @name Highcharts.Pathfinder\n         *\n         * @param {Highcharts.Chart} chart\n         *        The chart to operate on.\n         */\n        var Pathfinder = /** @class */ (function () {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            function Pathfinder(chart) {\n                this.init(chart);\n            }\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            Pathfinder.compose = function (ChartClass, PointClass) {\n                PathfinderComposition.compose(ChartClass, Pathfinder, PointClass);\n            };\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Initialize the Pathfinder object.\n             *\n             * @function Highcharts.Pathfinder#init\n             *\n             * @param {Highcharts.Chart} chart\n             *        The chart context.\n             */\n            Pathfinder.prototype.init = function (chart) {\n                // Initialize pathfinder with chart context\n                this.chart = chart;\n                // Init connection reference list\n                this.connections = [];\n                // Recalculate paths/obstacles on chart redraw\n                addEvent(chart, 'redraw', function () {\n                    this.pathfinder.update();\n                });\n            };\n            /**\n             * Update Pathfinder connections from scratch.\n             *\n             * @function Highcharts.Pathfinder#update\n             *\n             * @param {boolean} [deferRender]\n             *        Whether or not to defer rendering of connections until\n             *        series.afterAnimate event has fired. Used on first render.\n             */\n            Pathfinder.prototype.update = function (deferRender) {\n                var chart = this.chart, pathfinder = this, oldConnections = pathfinder.connections;\n                // Rebuild pathfinder connections from options\n                pathfinder.connections = [];\n                chart.series.forEach(function (series) {\n                    if (series.visible && !series.options.isInternal) {\n                        series.points.forEach(function (point) {\n                            var _a;\n                            var ganttPointOptions = point.options;\n                            // For Gantt series the connect could be\n                            // defined as a dependency\n                            if (ganttPointOptions && ganttPointOptions.dependency) {\n                                ganttPointOptions.connect = ganttPointOptions\n                                    .dependency;\n                            }\n                            var connects = (((_a = point.options) === null || _a === void 0 ? void 0 : _a.connect) &&\n                                splat(point.options.connect));\n                            var to;\n                            if (point.visible && point.isInside !== false && connects) {\n                                connects.forEach(function (connect) {\n                                    to = chart.get(typeof connect === 'string' ?\n                                        connect : connect.to);\n                                    if (to instanceof Point &&\n                                        to.series.visible &&\n                                        to.visible &&\n                                        to.isInside !== false) {\n                                        // Add new connection\n                                        pathfinder.connections.push(new Connection(point, // From\n                                        to, typeof connect === 'string' ?\n                                            {} :\n                                            connect));\n                                    }\n                                });\n                            }\n                        });\n                    }\n                });\n                // Clear connections that should not be updated, and move old info over\n                // to new connections.\n                for (var j = 0, k = void 0, found = void 0, lenOld = oldConnections.length, lenNew = pathfinder.connections.length; j < lenOld; ++j) {\n                    found = false;\n                    var oldCon = oldConnections[j];\n                    for (k = 0; k < lenNew; ++k) {\n                        var newCon = pathfinder.connections[k];\n                        if ((oldCon.options && oldCon.options.type) ===\n                            (newCon.options && newCon.options.type) &&\n                            oldCon.fromPoint === newCon.fromPoint &&\n                            oldCon.toPoint === newCon.toPoint) {\n                            newCon.graphics = oldCon.graphics;\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        oldCon.destroy();\n                    }\n                }\n                // Clear obstacles to force recalculation. This must be done on every\n                // redraw in case positions have changed. Recalculation is handled in\n                // Connection.getPath on demand.\n                delete this.chartObstacles;\n                delete this.lineObstacles;\n                // Draw the pending connections\n                pathfinder.renderConnections(deferRender);\n            };\n            /**\n             * Draw the chart's connecting paths.\n             *\n             * @function Highcharts.Pathfinder#renderConnections\n             *\n             * @param {boolean} [deferRender]\n             *        Whether or not to defer render until series animation is finished.\n             *        Used on first render.\n             */\n            Pathfinder.prototype.renderConnections = function (deferRender) {\n                if (deferRender) {\n                    // Render after series are done animating\n                    this.chart.series.forEach(function (series) {\n                        var render = function () {\n                            // Find pathfinder connections belonging to this series\n                            // that haven't rendered, and render them now.\n                            var pathfinder = series.chart.pathfinder, conns = pathfinder && pathfinder.connections || [];\n                            conns.forEach(function (connection) {\n                                if (connection.fromPoint &&\n                                    connection.fromPoint.series === series) {\n                                    connection.render();\n                                }\n                            });\n                            if (series.pathfinderRemoveRenderEvent) {\n                                series.pathfinderRemoveRenderEvent();\n                                delete series.pathfinderRemoveRenderEvent;\n                            }\n                        };\n                        if (series.options.animation === false) {\n                            render();\n                        }\n                        else {\n                            series.pathfinderRemoveRenderEvent = addEvent(series, 'afterAnimate', render);\n                        }\n                    });\n                }\n                else {\n                    // Go through connections and render them\n                    this.connections.forEach(function (connection) {\n                        connection.render();\n                    });\n                }\n            };\n            /**\n             * Get obstacles for the points in the chart. Does not include connecting\n             * lines from Pathfinder. Applies algorithmMargin to the obstacles.\n             *\n             * @function Highcharts.Pathfinder#getChartObstacles\n             *\n             * @param {Object} options\n             *        Options for the calculation. Currently only\n             *        `options.algorithmMargin`.\n             *\n             * @param {number} options.algorithmMargin\n             *        The algorithm margin to use for the obstacles.\n\n            * @return {Array<object>}\n             *         An array of calculated obstacles. Each obstacle is defined as an\n             *         object with xMin, xMax, yMin and yMax properties.\n             */\n            Pathfinder.prototype.getChartObstacles = function (options) {\n                var series = this.chart.series, margin = pick(options.algorithmMargin, 0);\n                var obstacles = [], calculatedMargin;\n                for (var i = 0, sLen = series.length; i < sLen; ++i) {\n                    if (series[i].visible && !series[i].options.isInternal) {\n                        for (var j = 0, pLen = series[i].points.length, bb = void 0, point = void 0; j < pLen; ++j) {\n                            point = series[i].points[j];\n                            if (point.visible) {\n                                bb = getPointBB(point);\n                                if (bb) {\n                                    obstacles.push({\n                                        xMin: bb.xMin - margin,\n                                        xMax: bb.xMax + margin,\n                                        yMin: bb.yMin - margin,\n                                        yMax: bb.yMax + margin\n                                    });\n                                }\n                            }\n                        }\n                    }\n                }\n                // Sort obstacles by xMin for optimization\n                obstacles = obstacles.sort(function (a, b) {\n                    return a.xMin - b.xMin;\n                });\n                // Add auto-calculated margin if the option is not defined\n                if (!defined(options.algorithmMargin)) {\n                    calculatedMargin =\n                        options.algorithmMargin =\n                            calculateObstacleMargin(obstacles);\n                    obstacles.forEach(function (obstacle) {\n                        obstacle.xMin -= calculatedMargin;\n                        obstacle.xMax += calculatedMargin;\n                        obstacle.yMin -= calculatedMargin;\n                        obstacle.yMax += calculatedMargin;\n                    });\n                }\n                return obstacles;\n            };\n            /**\n             * Utility function to get metrics for obstacles:\n             * - Widest obstacle width\n             * - Tallest obstacle height\n             *\n             * @function Highcharts.Pathfinder#getObstacleMetrics\n             *\n             * @param {Array<object>} obstacles\n             *        An array of obstacles to inspect.\n             *\n             * @return {Object}\n             *         The calculated metrics, as an object with maxHeight and maxWidth\n             *         properties.\n             */\n            Pathfinder.prototype.getObstacleMetrics = function (obstacles) {\n                var maxWidth = 0, maxHeight = 0, width, height, i = obstacles.length;\n                while (i--) {\n                    width = obstacles[i].xMax - obstacles[i].xMin;\n                    height = obstacles[i].yMax - obstacles[i].yMin;\n                    if (maxWidth < width) {\n                        maxWidth = width;\n                    }\n                    if (maxHeight < height) {\n                        maxHeight = height;\n                    }\n                }\n                return {\n                    maxHeight: maxHeight,\n                    maxWidth: maxWidth\n                };\n            };\n            /**\n             * Utility to get which direction to start the pathfinding algorithm\n             * (X vs Y), calculated from a set of marker options.\n             *\n             * @function Highcharts.Pathfinder#getAlgorithmStartDirection\n             *\n             * @param {Highcharts.ConnectorsMarkerOptions} markerOptions\n             *        Marker options to calculate from.\n             *\n             * @return {boolean}\n             *         Returns true for X, false for Y, and undefined for autocalculate.\n             */\n            Pathfinder.prototype.getAlgorithmStartDirection = function (markerOptions) {\n                var xCenter = markerOptions.align !== 'left' &&\n                    markerOptions.align !== 'right', yCenter = markerOptions.verticalAlign !== 'top' &&\n                    markerOptions.verticalAlign !== 'bottom';\n                return xCenter ?\n                    (yCenter ? void 0 : false) : // When x is centered\n                    (yCenter ? true : void 0); // When x is off-center\n            };\n            return Pathfinder;\n        }());\n        /**\n         * @name Highcharts.Pathfinder#algorithms\n         * @type {Highcharts.Dictionary<Function>}\n         */\n        Pathfinder.prototype.algorithms = PathfinderAlgorithms;\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * The default pathfinder algorithm to use for a chart. It is possible to define\n         * your own algorithms by adding them to the\n         * `Highcharts.Pathfinder.prototype.algorithms`\n         * object before the chart has been created.\n         *\n         * The default algorithms are as follows:\n         *\n         * `straight`:      Draws a straight line between the connecting\n         *                  points. Does not avoid other points when drawing.\n         *\n         * `simpleConnect`: Finds a path between the points using right angles\n         *                  only. Takes only starting/ending points into\n         *                  account, and will not avoid other points.\n         *\n         * `fastAvoid`:     Finds a path between the points using right angles\n         *                  only. Will attempt to avoid other points, but its\n         *                  focus is performance over accuracy. Works well with\n         *                  less dense datasets.\n         *\n         * @typedef {\"fastAvoid\"|\"simpleConnect\"|\"straight\"|string} Highcharts.PathfinderTypeValue\n         */\n        ''; // Keeps doclets above in JS file\n\n        return Pathfinder;\n    });\n    _registerModule(_modules, 'Extensions/ArrowSymbols.js', [], function () {\n        /* *\n         *\n         *  (c) 2017 Highsoft AS\n         *  Authors: Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Creates an arrow symbol. Like a triangle, except not filled.\n         * ```\n         *                   o\n         *             o\n         *       o\n         * o\n         *       o\n         *             o\n         *                   o\n         * ```\n         *\n         * @private\n         * @function\n         *\n         * @param {number} x\n         *        x position of the arrow\n         *\n         * @param {number} y\n         *        y position of the arrow\n         *\n         * @param {number} w\n         *        width of the arrow\n         *\n         * @param {number} h\n         *        height of the arrow\n         *\n         * @return {Highcharts.SVGPathArray}\n         *         Path array\n         */\n        function arrow(x, y, w, h) {\n            return [\n                ['M', x, y + h / 2],\n                ['L', x + w, y],\n                ['L', x, y + h / 2],\n                ['L', x + w, y + h]\n            ];\n        }\n        /**\n         * Creates a half-width arrow symbol. Like a triangle, except not filled.\n         * ```\n         *       o\n         *    o\n         * o\n         *    o\n         *       o\n         * ```\n         *\n         * @private\n         * @function\n         *\n         * @param {number} x\n         *        x position of the arrow\n         *\n         * @param {number} y\n         *        y position of the arrow\n         *\n         * @param {number} w\n         *        width of the arrow\n         *\n         * @param {number} h\n         *        height of the arrow\n         *\n         * @return {Highcharts.SVGPathArray}\n         *         Path array\n         */\n        function arrowHalf(x, y, w, h) {\n            return arrow(x, y, w / 2, h);\n        }\n        /**\n         * @private\n         */\n        function compose(SVGRendererClass) {\n            var symbols = SVGRendererClass.prototype.symbols;\n            symbols.arrow = arrow;\n            symbols['arrow-filled'] = triangleLeft;\n            symbols['arrow-filled-half'] = triangleLeftHalf;\n            symbols['arrow-half'] = arrowHalf;\n            symbols['triangle-left'] = triangleLeft;\n            symbols['triangle-left-half'] = triangleLeftHalf;\n        }\n        /**\n         * Creates a left-oriented triangle.\n         * ```\n         *             o\n         *       ooooooo\n         * ooooooooooooo\n         *       ooooooo\n         *             o\n         * ```\n         *\n         * @private\n         * @function\n         *\n         * @param {number} x\n         *        x position of the triangle\n         *\n         * @param {number} y\n         *        y position of the triangle\n         *\n         * @param {number} w\n         *        width of the triangle\n         *\n         * @param {number} h\n         *        height of the triangle\n         *\n         * @return {Highcharts.SVGPathArray}\n         *         Path array\n         */\n        function triangleLeft(x, y, w, h) {\n            return [\n                ['M', x + w, y],\n                ['L', x, y + h / 2],\n                ['L', x + w, y + h],\n                ['Z']\n            ];\n        }\n        /**\n         * Creates a half-width, left-oriented triangle.\n         * ```\n         *       o\n         *    oooo\n         * ooooooo\n         *    oooo\n         *       o\n         * ```\n         *\n         * @private\n         * @function\n         *\n         * @param {number} x\n         *        x position of the triangle\n         *\n         * @param {number} y\n         *        y position of the triangle\n         *\n         * @param {number} w\n         *        width of the triangle\n         *\n         * @param {number} h\n         *        height of the triangle\n         *\n         * @return {Highcharts.SVGPathArray}\n         *         Path array\n         */\n        function triangleLeftHalf(x, y, w, h) {\n            return triangleLeft(x, y, w / 2, h);\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        var ArrowSymbols = {\n            compose: compose\n        };\n\n        return ArrowSymbols;\n    });\n    _registerModule(_modules, 'masters/modules/pathfinder.src.js', [_modules['Core/Globals.js'], _modules['Gantt/Pathfinder.js'], _modules['Extensions/ArrowSymbols.js']], function (Highcharts, Pathfinder, ArrowSymbols) {\n\n        var G = Highcharts;\n        G.Pathfinder = G.Pathfinder || Pathfinder;\n        ArrowSymbols.compose(G.SVGRenderer);\n        G.Pathfinder.compose(G.Chart, G.Point);\n\n        return Highcharts;\n    });\n}));\n"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","win","dispatchEvent","detail","H","U","defined","error","merge","objectEach","deg2rad","max","Math","min","Connection","from","to","options","init","prototype","fromPoint","toPoint","chart","series","pathfinder","renderPath","attribs","styledMode","anim","pathGraphic","connection","graphics","group","renderer","g","addClass","attr","zIndex","add","seriesGroup","translate","plotLeft","plotTop","opacity","d","animate","addMarker","type","markerVector","radians","rotation","box","width","height","pathVector","segment","point","anchor","getPathfinderAnchorPoint","enabled","length","x","y","getRadiansToVector","getMarkerVector","radius","rotationOriginX","rotationOriginY","symbol","colorIndex","fill","color","stroke","lineColor","lineWidth","animation","getPath","algorithm","algorithms","chartObstacles","obstacles","requiresObstacles","getChartObstacles","connectors","algorithmMargin","chartObstacleMetrics","getObstacleMetrics","startMarker","endMarker","lineObstacles","obstacleMetrics","hardBounds","xMin","xMax","plotWidth","yMin","yMax","plotHeight","obstacleOptions","margin","startDirectionX","getAlgorithmStartDirection","render","dashStyle","dashstyle","marker","ceil","pathResult","concat","destroy","val","applyRadius","r","i","push","prevSeg","nextSeg","x1","y1","x2","y2","directionX","directionY","abs","getLinkPath","pathParams","_a","_b","inverted","parentVisible","straight","curved","offset","_c","PathUtilities","pick","findLastObstacleBefore","startIx","cursor","cmp","left","right","findObstacleFromPoint","obstacle","pathFromSegments","segments","start","end","limitObstacleToBounds","bounds","simpleConnect","endSegment","startObstacle","waypoint","useMax","endPoint","startObstacleIx","endObstacleIx","dir","copyFromPoint","fromKey","toKey","getMeOut","direction","prevWaypoint","waypoint2","fastAvoid","dirIsX","extractedEndPoint","endSegments","metrics","softMinX","maxWidth","softMaxX","softMinY","maxHeight","softMaxY","forceObstacleBreak","pivotPoint","directionIsX","firstPoint","lastPoint","highestPoint","lowestPoint","searchDirection","getDodgeDirection","softBounds","soft","hard","toPointMax","toPointMin","maxOutOfSoftBounds","minOutOfSoftBounds","maxOutOfHardBounds","minOutOfHardBounds","minDistance","maxDistance","minPivot","maxPivot","slice","clearPathTo","pivot","waypointUseMax","envelopingObstacle","secondEnvelopingObstacle","envelopWaypoint","obstacleMargin","reverse","align","verticalAlign","inside","ConnectorsDefaults","D","ConnectionComposition","setOptions","getPointBB","shapeArgs","bb","graphic","getBBox","plotX","plotY","pointGetPathfinderAnchorPoint","markerOptions","pointGetRadiansToVector","v1","v2","atan2","pointGetMarkerVector","markerRadius","twoPI","PI","rectWidth","rectHeight","rAtan","rectHalfWidth","rectHalfHeight","rectHorizontalCenter","rectVerticalCenter","edgePoint","theta","tanTheta","leftOrRightRegion","xFactor","yFactor","tan","cos","sin","compose","ChartClass","PathfinderClass","PointClass","pointProto","callbacks","reduce","acc","update","PathfinderAlgorithms","PathfinderComposition","Point","addEvent","splat","Pathfinder","connections","deferRender","oldConnections","forEach","visible","isInternal","points","ganttPointOptions","dependency","connect","connects","isInside","get","j","k","found","lenOld","lenNew","oldCon","newCon","renderConnections","conns","pathfinderRemoveRenderEvent","calculatedMargin","sLen","pLen","sort","a","b","calculateObstacleMargin","onstacleDistance","len","distances","calculateObstacleDistance","bbMargin","yOverlap","xOverlap","xDistance","Infinity","yDistance","floor","xCenter","yCenter","arrow","w","h","arrowHalf","triangleLeft","triangleLeftHalf","SVGRendererClass","symbols","ArrowSymbols","G","SVGRenderer","Chart"],"mappings":"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"}
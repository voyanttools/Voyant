{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v11.4.8 (2024-08-29)\n *\n * Variable Pie module for Highcharts\n *\n * (c) 2010-2024 Grzegorz Blachliński\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/variable-pie', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                Highcharts.win.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Series/VariablePie/VariablePieSeriesDefaults.js', [], function () {\n        /* *\n         *\n         *  Variable Pie module for Highcharts\n         *\n         *  (c) 2010-2024 Grzegorz Blachliński\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * A variable pie series is a two dimensional series type, where each point\n         * renders an Y and Z value.  Each point is drawn as a pie slice where the\n         * size (arc) of the slice relates to the Y value and the radius of pie\n         * slice relates to the Z value.\n         *\n         * @sample {highcharts} highcharts/demo/variable-radius-pie/\n         *         Variable-radius pie chart\n         *\n         * @extends      plotOptions.pie\n         * @excluding    dragDrop\n         * @since        6.0.0\n         * @product      highcharts\n         * @requires     modules/variable-pie\n         * @optionparent plotOptions.variablepie\n         */\n        const VariablePieSeriesDefaults = {\n            /**\n             * The minimum size of the points' radius related to chart's `plotArea`.\n             * If a number is set, it applies in pixels.\n             *\n             * @sample {highcharts} highcharts/variable-radius-pie/min-max-point-size/\n             *         Example of minPointSize and maxPointSize\n             * @sample {highcharts} highcharts/variable-radius-pie/min-point-size-100/\n             *         minPointSize set to 100\n             *\n             * @type  {number|string}\n             * @since 6.0.0\n             */\n            minPointSize: '10%',\n            /**\n             * The maximum size of the points' radius related to chart's `plotArea`.\n             * If a number is set, it applies in pixels.\n             *\n             * @sample {highcharts} highcharts/variable-radius-pie/min-max-point-size/\n             *         Example of minPointSize and maxPointSize\n             *\n             * @type  {number|string}\n             * @since 6.0.0\n             */\n            maxPointSize: '100%',\n            /**\n             * The minimum possible z value for the point's radius calculation. If\n             * the point's Z value is smaller than zMin, the slice will be drawn\n             * according to the zMin value.\n             *\n             * @sample {highcharts} highcharts/variable-radius-pie/zmin-5/\n             *         zMin set to 5, smaller z values are treated as 5\n             * @sample {highcharts} highcharts/variable-radius-pie/zmin-zmax/\n             *         Series limited by both zMin and zMax\n             *\n             * @type  {number}\n             * @since 6.0.0\n             */\n            zMin: void 0,\n            /**\n             * The maximum possible z value for the point's radius calculation. If\n             * the point's Z value is bigger than zMax, the slice will be drawn\n             * according to the zMax value\n             *\n             * @sample {highcharts} highcharts/variable-radius-pie/zmin-zmax/\n             *         Series limited by both zMin and zMax\n             *\n             * @type  {number}\n             * @since 6.0.0\n             */\n            zMax: void 0,\n            /**\n             * Whether the pie slice's value should be represented by the area or\n             * the radius of the slice. Can be either `area` or `radius`. The\n             * default, `area`, corresponds best to the human perception of the size\n             * of each pie slice.\n             *\n             * @sample {highcharts} highcharts/variable-radius-pie/sizeby/\n             *         Difference between area and radius sizeBy\n             *\n             * @type  {Highcharts.VariablePieSizeByValue}\n             * @since 6.0.0\n             */\n            sizeBy: 'area',\n            tooltip: {\n                pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}<br/>Value: {point.y}<br/>Size: {point.z}<br/>'\n            }\n        };\n        /**\n         * A `variablepie` series. If the [type](#series.variablepie.type) option is not\n         * specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.variablepie\n         * @excluding dataParser, dataURL, stack, xAxis, yAxis, dataSorting,\n         *            boostThreshold, boostBlending\n         * @product   highcharts\n         * @requires  modules/variable-pie\n         * @apioption series.variablepie\n         */\n        /**\n         * An array of data points for the series. For the `variablepie` series type,\n         * points can be given in the following ways:\n         *\n         * 1. An array of arrays with 2 values. In this case, the numerical values will\n         *    be interpreted as `y, z` options. Example:\n         *    ```js\n         *    data: [\n         *        [40, 75],\n         *        [50, 50],\n         *        [60, 40]\n         *    ]\n         *    ```\n         *\n         * 2. An array of objects with named values. The following snippet shows only a\n         *    few settings, see the complete options set below. If the total number of\n         *    data points exceeds the series'\n         *    [turboThreshold](#series.variablepie.turboThreshold), this option is not\n         *    available.\n         *    ```js\n         *    data: [{\n         *        y: 1,\n         *        z: 4,\n         *        name: \"Point2\",\n         *        color: \"#00FF00\"\n         *    }, {\n         *        y: 7,\n         *        z: 10,\n         *        name: \"Point1\",\n         *        color: \"#FF00FF\"\n         *    }]\n         *    ```\n         *\n         * @sample {highcharts} highcharts/series/data-array-of-arrays/\n         *         Arrays of numeric x and y\n         * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n         *         Arrays of datetime x and y\n         * @sample {highcharts} highcharts/series/data-array-of-name-value/\n         *         Arrays of point.name and y\n         * @sample {highcharts} highcharts/series/data-array-of-objects/\n         *         Config objects\n         *\n         * @type      {Array<Array<(number|string),number>|*>}\n         * @extends   series.pie.data\n         * @excluding marker, x\n         * @product   highcharts\n         * @apioption series.variablepie.data\n         */\n        ''; // Keeps doclets above separate\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return VariablePieSeriesDefaults;\n    });\n    _registerModule(_modules, 'Series/VariablePie/VariablePieSeries.js', [_modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js'], _modules['Series/VariablePie/VariablePieSeriesDefaults.js']], function (SeriesRegistry, U, VariablePieSeriesDefaults) {\n        /* *\n         *\n         *  Variable Pie module for Highcharts\n         *\n         *  (c) 2010-2024 Grzegorz Blachliński\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { pie: PieSeries } = SeriesRegistry.seriesTypes;\n        const { arrayMax, arrayMin, clamp, extend, fireEvent, merge, pick } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The variablepie series type.\n         *\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.variablepie\n         *\n         * @augments Highcharts.Series\n         */\n        class VariablePieSeries extends PieSeries {\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Before standard translate method for pie chart it is needed to calculate\n             * min/max radius of each pie slice based on its Z value.\n             * @private\n             */\n            calculateExtremes() {\n                const series = this, chart = series.chart, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, seriesOptions = series.options, slicingRoom = 2 * (seriesOptions.slicedOffset || 0), zData = series.zData, smallestSize = Math.min(plotWidth, plotHeight) - slicingRoom, \n                // Min and max size of pie slice:\n                extremes = {}, \n                // In pie charts size of a pie is changed to make space for\n                // dataLabels, then series.center is changing.\n                positions = series.center || series.getCenter();\n                let zMin, zMax;\n                for (const prop of ['minPointSize', 'maxPointSize']) {\n                    let length = seriesOptions[prop];\n                    const isPercent = /%$/.test(length);\n                    length = parseInt(length, 10);\n                    extremes[prop] = isPercent ?\n                        smallestSize * length / 100 :\n                        length * 2; // Because it should be radius, not diameter.\n                }\n                series.minPxSize = positions[3] + extremes.minPointSize;\n                series.maxPxSize = clamp(positions[2], positions[3] + extremes.minPointSize, extremes.maxPointSize);\n                if (zData.length) {\n                    zMin = pick(seriesOptions.zMin, arrayMin(zData.filter(series.zValEval)));\n                    zMax = pick(seriesOptions.zMax, arrayMax(zData.filter(series.zValEval)));\n                    this.getRadii(zMin, zMax, series.minPxSize, series.maxPxSize);\n                }\n            }\n            /**\n             * Finding radius of series points based on their Z value and min/max Z\n             * value for all series.\n             *\n             * @private\n             * @function Highcharts.Series#getRadii\n             *\n             * @param {number} zMin\n             * Min threshold for Z value. If point's Z value is smaller that zMin, point\n             * will have the smallest possible radius.\n             *\n             * @param {number} zMax\n             * Max threshold for Z value. If point's Z value is bigger that zMax, point\n             * will have the biggest possible radius.\n             *\n             * @param {number} minSize\n             * Minimal pixel size possible for radius.\n             *\n             * @param {numbner} maxSize\n             * Minimal pixel size possible for radius.\n             */\n            getRadii(zMin, zMax, minSize, maxSize) {\n                const zData = this.zData, radii = [], options = this.options, sizeByArea = options.sizeBy !== 'radius', zRange = zMax - zMin;\n                let pos, value, radius;\n                // Calculate radius for all pie slice's based on their Z values\n                for (let i = 0; i < zData.length; i++) {\n                    // If zData[i] is null/undefined/string we need to take zMin for\n                    // smallest radius.\n                    value = this.zValEval(zData[i]) ? zData[i] : zMin;\n                    if (value <= zMin) {\n                        radius = minSize / 2;\n                    }\n                    else if (value >= zMax) {\n                        radius = maxSize / 2;\n                    }\n                    else {\n                        // Relative size, a number between 0 and 1\n                        pos = zRange > 0 ? (value - zMin) / zRange : 0.5;\n                        if (sizeByArea) {\n                            pos = Math.sqrt(pos);\n                        }\n                        radius = Math.ceil(minSize + pos * (maxSize - minSize)) / 2;\n                    }\n                    radii.push(radius);\n                }\n                this.radii = radii;\n            }\n            /**\n             * It is needed to null series.center on chart redraw. Probably good idea\n             * will be to add this option in directly in pie series.\n             * @private\n             */\n            redraw() {\n                this.center = null;\n                super.redraw();\n            }\n            /** @private */\n            getDataLabelPosition(point, distance) {\n                const { center, options } = this, angle = point.angle || 0, r = this.radii[point.index], x = center[0] + Math.cos(angle) * r, y = center[1] + Math.sin(angle) * r, connectorOffset = (options.slicedOffset || 0) +\n                    (options.borderWidth || 0), \n                // Set the anchor point for data labels. Use point.labelDistance\n                // instead of labelDistance // #1174\n                // finalConnectorOffset - not override connectorOffset value.\n                finalConnectorOffset = Math.min(connectorOffset, distance / 5); // #1678\n                return {\n                    distance,\n                    natural: {\n                        // Initial position of the data label - it's utilized for\n                        // finding the final position for the label\n                        x: x + Math.cos(angle) * distance,\n                        y: y + Math.sin(angle) * distance\n                    },\n                    computed: {\n                    // Used for generating connector path - initialized later in\n                    // drawDataLabels function x: undefined, y: undefined\n                    },\n                    // Left - pie on the left side of the data label\n                    // Right - pie on the right side of the data label\n                    alignment: point.half ? 'right' : 'left',\n                    connectorPosition: {\n                        breakAt: {\n                            x: x + Math.cos(angle) * finalConnectorOffset,\n                            y: y + Math.sin(angle) * finalConnectorOffset\n                        },\n                        touchingSliceAt: {\n                            x,\n                            y\n                        }\n                    }\n                };\n            }\n            /**\n             * Extend translate by updating radius for each pie slice instead of using\n             * one global radius.\n             * @private\n             */\n            translate(positions) {\n                this.generatePoints();\n                const series = this, precision = 1000, // Issue #172\n                options = series.options, slicedOffset = options.slicedOffset, startAngle = options.startAngle || 0, startAngleRad = Math.PI / 180 * (startAngle - 90), endAngleRad = Math.PI / 180 * (pick(options.endAngle, startAngle + 360) - 90), circ = endAngleRad - startAngleRad, // 2 * Math.PI,\n                points = series.points, ignoreHiddenPoint = options.ignoreHiddenPoint;\n                let cumulative = 0, start, end, angle, \n                // The x component of the radius vector for a given point\n                radiusX, radiusY, point, pointRadii;\n                series.startAngleRad = startAngleRad;\n                series.endAngleRad = endAngleRad;\n                // Use calculateExtremes to get series.radii array.\n                series.calculateExtremes();\n                // Get positions - either an integer or a percentage string must be\n                // given. If positions are passed as a parameter, we're in a\n                // recursive loop for adjusting space for data labels.\n                if (!positions) {\n                    series.center = positions = series.getCenter();\n                }\n                // Calculate the geometry for each point\n                for (let i = 0; i < points.length; i++) {\n                    point = points[i];\n                    pointRadii = series.radii[i];\n                    // Set start and end angle\n                    start = startAngleRad + (cumulative * circ);\n                    if (!ignoreHiddenPoint || point.visible) {\n                        cumulative += point.percentage / 100;\n                    }\n                    end = startAngleRad + (cumulative * circ);\n                    // Set the shape\n                    point.shapeType = 'arc';\n                    point.shapeArgs = {\n                        x: positions[0],\n                        y: positions[1],\n                        r: pointRadii,\n                        innerR: positions[3] / 2,\n                        start: Math.round(start * precision) / precision,\n                        end: Math.round(end * precision) / precision\n                    };\n                    // The angle must stay within -90 and 270 (#2645)\n                    angle = (end + start) / 2;\n                    if (angle > 1.5 * Math.PI) {\n                        angle -= 2 * Math.PI;\n                    }\n                    else if (angle < -Math.PI / 2) {\n                        angle += 2 * Math.PI;\n                    }\n                    // Center for the sliced out slice\n                    point.slicedTranslation = {\n                        translateX: Math.round(Math.cos(angle) * slicedOffset),\n                        translateY: Math.round(Math.sin(angle) * slicedOffset)\n                    };\n                    // Set the anchor point for tooltips\n                    radiusX = Math.cos(angle) * positions[2] / 2;\n                    radiusY = Math.sin(angle) * positions[2] / 2;\n                    point.tooltipPos = [\n                        positions[0] + radiusX * 0.7,\n                        positions[1] + radiusY * 0.7\n                    ];\n                    point.half = angle < -Math.PI / 2 || angle > Math.PI / 2 ?\n                        1 :\n                        0;\n                    point.angle = angle;\n                }\n                fireEvent(series, 'afterTranslate');\n            }\n            /**\n             * For arrayMin and arrayMax calculations array shouldn't have\n             * null/undefined/string values. In this case it is needed to check if\n             * points Z value is a Number.\n             * @private\n             */\n            zValEval(zVal) {\n                if (typeof zVal === 'number' && !isNaN(zVal)) {\n                    return true;\n                }\n                return null;\n            }\n        }\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        VariablePieSeries.defaultOptions = merge(PieSeries.defaultOptions, VariablePieSeriesDefaults);\n        extend(VariablePieSeries.prototype, {\n            pointArrayMap: ['y', 'z'],\n            parallelArrays: ['x', 'y', 'z']\n        });\n        SeriesRegistry.registerSeriesType('variablepie', VariablePieSeries);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Declarations\n         *\n         * */\n        /**\n         * @typedef {\"area\"|\"radius\"} Highcharts.VariablePieSizeByValue\n         */\n        ''; // Adds doclets above to transpiled file\n\n        return VariablePieSeries;\n    });\n    _registerModule(_modules, 'masters/modules/variable-pie.src.js', [_modules['Core/Globals.js']], function (Highcharts) {\n\n\n        return Highcharts;\n    });\n}));\n"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","win","dispatchEvent","detail","minPointSize","maxPointSize","zMin","zMax","sizeBy","tooltip","pointFormat","SeriesRegistry","U","VariablePieSeriesDefaults","pie","PieSeries","seriesTypes","arrayMax","arrayMin","clamp","extend","fireEvent","merge","pick","VariablePieSeries","calculateExtremes","chart","series","plotWidth","plotHeight","seriesOptions","options","slicingRoom","slicedOffset","zData","smallestSize","Math","min","extremes","positions","center","getCenter","prop","length","isPercent","test","parseInt","minPxSize","maxPxSize","filter","zValEval","getRadii","minSize","maxSize","pos","value","radius","radii","sizeByArea","zRange","i","sqrt","ceil","push","redraw","getDataLabelPosition","point","distance","angle","r","index","x","cos","y","sin","finalConnectorOffset","borderWidth","natural","computed","alignment","half","connectorPosition","breakAt","touchingSliceAt","translate","generatePoints","startAngle","startAngleRad","PI","endAngleRad","endAngle","circ","points","ignoreHiddenPoint","cumulative","start","end","radiusX","radiusY","pointRadii","visible","percentage","shapeType","shapeArgs","innerR","round","slicedTranslation","translateX","translateY","tooltipPos","zVal","isNaN","defaultOptions","prototype","pointArrayMap","parallelArrays","registerSeriesType"],"mappings":"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"}
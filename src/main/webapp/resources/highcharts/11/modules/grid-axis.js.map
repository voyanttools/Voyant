{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts Gantt JS v11.4.8 (2024-08-29)\n *\n * GridAxis\n *\n * (c) 2016-2024 Lars A. V. Cabrera\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/grid-axis', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                Highcharts.win.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Core/Axis/GridAxis.js', [_modules['Core/Axis/Axis.js'], _modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (Axis, H, U) {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Authors: Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { dateFormats } = H;\n        const { addEvent, defined, erase, find, isArray, isNumber, merge, pick, timeUnits, wrap } = U;\n        /* *\n         *\n         *  Enums\n         *\n         * */\n        /**\n         * Enum for which side the axis is on. Maps to axis.side.\n         * @private\n         */\n        var GridAxisSide;\n        (function (GridAxisSide) {\n            GridAxisSide[GridAxisSide[\"top\"] = 0] = \"top\";\n            GridAxisSide[GridAxisSide[\"right\"] = 1] = \"right\";\n            GridAxisSide[GridAxisSide[\"bottom\"] = 2] = \"bottom\";\n            GridAxisSide[GridAxisSide[\"left\"] = 3] = \"left\";\n        })(GridAxisSide || (GridAxisSide = {}));\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function argsToArray(args) {\n            return Array.prototype.slice.call(args, 1);\n        }\n        /**\n         * @private\n         */\n        function isObject(x) {\n            // Always use strict mode\n            return U.isObject(x, true);\n        }\n        /**\n         * @private\n         */\n        function applyGridOptions(axis) {\n            const options = axis.options;\n            // Center-align by default\n            /*\n            if (!options.labels) {\n                options.labels = {};\n            }\n            */\n            options.labels.align = pick(options.labels.align, 'center');\n            // @todo: Check against tickLabelPlacement between/on etc\n            /* Prevents adding the last tick label if the axis is not a category\n               axis.\n               Since numeric labels are normally placed at starts and ends of a\n               range of value, and this module makes the label point at the value,\n               an \"extra\" label would appear. */\n            if (!axis.categories) {\n                options.showLastLabel = false;\n            }\n            // Prevents rotation of labels when squished, as rotating them would not\n            // help.\n            axis.labelRotation = 0;\n            options.labels.rotation = 0;\n            // Allow putting ticks closer than their data points.\n            options.minTickInterval = 1;\n        }\n        /**\n         * Extends axis class with grid support.\n         * @private\n         */\n        function compose(AxisClass, ChartClass, TickClass) {\n            if (!AxisClass.keepProps.includes('grid')) {\n                AxisClass.keepProps.push('grid');\n                AxisClass.prototype.getMaxLabelDimensions = getMaxLabelDimensions;\n                wrap(AxisClass.prototype, 'unsquish', wrapUnsquish);\n                wrap(AxisClass.prototype, 'getOffset', wrapGetOffset);\n                // Add event handlers\n                addEvent(AxisClass, 'init', onInit);\n                addEvent(AxisClass, 'afterGetTitlePosition', onAfterGetTitlePosition);\n                addEvent(AxisClass, 'afterInit', onAfterInit);\n                addEvent(AxisClass, 'afterRender', onAfterRender);\n                addEvent(AxisClass, 'afterSetAxisTranslation', onAfterSetAxisTranslation);\n                addEvent(AxisClass, 'afterSetOptions', onAfterSetOptions);\n                addEvent(AxisClass, 'afterSetOptions', onAfterSetOptions2);\n                addEvent(AxisClass, 'afterSetScale', onAfterSetScale);\n                addEvent(AxisClass, 'afterTickSize', onAfterTickSize);\n                addEvent(AxisClass, 'trimTicks', onTrimTicks);\n                addEvent(AxisClass, 'destroy', onDestroy);\n                addEvent(ChartClass, 'afterSetChartSize', onChartAfterSetChartSize);\n                addEvent(TickClass, 'afterGetLabelPosition', onTickAfterGetLabelPosition);\n                addEvent(TickClass, 'labelFormat', onTickLabelFormat);\n            }\n            return AxisClass;\n        }\n        /**\n         * Get the largest label width and height.\n         *\n         * @private\n         * @function Highcharts.Axis#getMaxLabelDimensions\n         *\n         * @param {Highcharts.Dictionary<Highcharts.Tick>} ticks\n         * All the ticks on one axis.\n         *\n         * @param {Array<number|string>} tickPositions\n         * All the tick positions on one axis.\n         *\n         * @return {Highcharts.SizeObject}\n         * Object containing the properties height and width.\n         *\n         * @todo Move this to the generic axis implementation, as it is used there.\n         */\n        function getMaxLabelDimensions(ticks, tickPositions) {\n            const dimensions = {\n                width: 0,\n                height: 0\n            };\n            tickPositions.forEach(function (pos) {\n                const tick = ticks[pos];\n                let labelHeight = 0, labelWidth = 0, label;\n                if (isObject(tick)) {\n                    label = isObject(tick.label) ? tick.label : {};\n                    // Find width and height of label\n                    labelHeight = label.getBBox ? label.getBBox().height : 0;\n                    if (label.textStr && !isNumber(label.textPxLength)) {\n                        label.textPxLength = label.getBBox().width;\n                    }\n                    labelWidth = isNumber(label.textPxLength) ?\n                        // Math.round ensures crisp lines\n                        Math.round(label.textPxLength) :\n                        0;\n                    if (label.textStr) {\n                        // Set the tickWidth same as the label width after ellipsis\n                        // applied #10281\n                        labelWidth = Math.round(label.getBBox().width);\n                    }\n                    // Update the result if width and/or height are larger\n                    dimensions.height = Math.max(labelHeight, dimensions.height);\n                    dimensions.width = Math.max(labelWidth, dimensions.width);\n                }\n            });\n            // For tree grid, add indentation\n            if (this.type === 'treegrid' &&\n                this.treeGrid &&\n                this.treeGrid.mapOfPosToGridNode) {\n                const treeDepth = this.treeGrid.mapOfPosToGridNode[-1].height || 0;\n                dimensions.width += (this.options.labels.indentation *\n                    (treeDepth - 1));\n            }\n            return dimensions;\n        }\n        /**\n         * Handle columns and getOffset.\n         * @private\n         */\n        function wrapGetOffset(proceed) {\n            const { grid } = this, \n            // On the left side we handle the columns first because the offset is\n            // calculated from the plot area and out\n            columnsFirst = this.side === 3;\n            if (!columnsFirst) {\n                proceed.apply(this);\n            }\n            if (!grid?.isColumn) {\n                let columns = grid?.columns || [];\n                if (columnsFirst) {\n                    columns = columns.slice().reverse();\n                }\n                columns\n                    .forEach((column) => {\n                    column.getOffset();\n                });\n            }\n            if (columnsFirst) {\n                proceed.apply(this);\n            }\n        }\n        /**\n         * @private\n         */\n        function onAfterGetTitlePosition(e) {\n            const axis = this;\n            const options = axis.options;\n            const gridOptions = options.grid || {};\n            if (gridOptions.enabled === true) {\n                // Compute anchor points for each of the title align options\n                const { axisTitle, height: axisHeight, horiz, left: axisLeft, offset, opposite, options, top: axisTop, width: axisWidth } = axis;\n                const tickSize = axis.tickSize();\n                const titleWidth = axisTitle && axisTitle.getBBox().width;\n                const xOption = options.title.x;\n                const yOption = options.title.y;\n                const titleMargin = pick(options.title.margin, horiz ? 5 : 10);\n                const titleFontSize = axisTitle ? axis.chart.renderer.fontMetrics(axisTitle).f : 0;\n                const crispCorr = tickSize ? tickSize[0] / 2 : 0;\n                // TODO account for alignment\n                // the position in the perpendicular direction of the axis\n                const offAxis = ((horiz ? axisTop + axisHeight : axisLeft) +\n                    (horiz ? 1 : -1) * // Horizontal axis reverses the margin\n                        (opposite ? -1 : 1) * // So does opposite axes\n                        crispCorr +\n                    (axis.side === GridAxisSide.bottom ? titleFontSize : 0));\n                e.titlePosition.x = horiz ?\n                    axisLeft - (titleWidth || 0) / 2 - titleMargin + xOption :\n                    offAxis + (opposite ? axisWidth : 0) + offset + xOption;\n                e.titlePosition.y = horiz ?\n                    (offAxis -\n                        (opposite ? axisHeight : 0) +\n                        (opposite ? titleFontSize : -titleFontSize) / 2 +\n                        offset +\n                        yOption) :\n                    axisTop - titleMargin + yOption;\n            }\n        }\n        /**\n         * @private\n         */\n        function onAfterInit() {\n            const axis = this;\n            const { chart, options: { grid: gridOptions = {} }, userOptions } = axis;\n            if (gridOptions.enabled) {\n                applyGridOptions(axis);\n            }\n            if (gridOptions.columns) {\n                const columns = axis.grid.columns = [];\n                let columnIndex = axis.grid.columnIndex = 0;\n                // Handle columns, each column is a grid axis\n                while (++columnIndex < gridOptions.columns.length) {\n                    const columnOptions = merge(userOptions, gridOptions.columns[columnIndex], {\n                        isInternal: true,\n                        linkedTo: 0,\n                        // Disable by default the scrollbar on the grid axis\n                        scrollbar: {\n                            enabled: false\n                        }\n                    }, \n                    // Avoid recursion\n                    {\n                        grid: {\n                            columns: void 0\n                        }\n                    });\n                    const column = new Axis(axis.chart, columnOptions, 'yAxis');\n                    column.grid.isColumn = true;\n                    column.grid.columnIndex = columnIndex;\n                    // Remove column axis from chart axes array, and place it\n                    // in the columns array.\n                    erase(chart.axes, column);\n                    erase(chart[axis.coll] || [], column);\n                    columns.push(column);\n                }\n            }\n        }\n        /**\n         * Draw an extra line on the far side of the outermost axis,\n         * creating floor/roof/wall of a grid. And some padding.\n         * ```\n         * Make this:\n         *             (axis.min) __________________________ (axis.max)\n         *                           |    |    |    |    |\n         * Into this:\n         *             (axis.min) __________________________ (axis.max)\n         *                        ___|____|____|____|____|__\n         * ```\n         * @private\n         */\n        function onAfterRender() {\n            const axis = this, { axisTitle, grid, options } = axis, gridOptions = options.grid || {};\n            if (gridOptions.enabled === true) {\n                const min = axis.min || 0, max = axis.max || 0, firstTick = axis.ticks[axis.tickPositions[0]];\n                // Adjust the title max width to the column width (#19657)\n                if (axisTitle &&\n                    !axis.chart.styledMode &&\n                    firstTick?.slotWidth &&\n                    !axis.options.title.style.width) {\n                    axisTitle.css({ width: `${firstTick.slotWidth}px` });\n                }\n                // @todo actual label padding (top, bottom, left, right)\n                axis.maxLabelDimensions = axis.getMaxLabelDimensions(axis.ticks, axis.tickPositions);\n                // Remove right wall before rendering if updating\n                if (axis.rightWall) {\n                    axis.rightWall.destroy();\n                }\n                /*\n                Draw an extra axis line on outer axes\n                            >\n                Make this:    |______|______|______|___\n\n                            > _________________________\n                Into this:    |______|______|______|__|\n                                                        */\n                if (axis.grid && axis.grid.isOuterAxis() && axis.axisLine) {\n                    const lineWidth = options.lineWidth;\n                    if (lineWidth) {\n                        const linePath = axis.getLinePath(lineWidth), startPoint = linePath[0], endPoint = linePath[1], \n                        // Negate distance if top or left axis\n                        // Subtract 1px to draw the line at the end of the tick\n                        tickLength = (axis.tickSize('tick') || [1])[0], distance = tickLength * ((axis.side === GridAxisSide.top ||\n                            axis.side === GridAxisSide.left) ? -1 : 1);\n                        // If axis is horizontal, reposition line path vertically\n                        if (startPoint[0] === 'M' && endPoint[0] === 'L') {\n                            if (axis.horiz) {\n                                startPoint[2] += distance;\n                                endPoint[2] += distance;\n                            }\n                            else {\n                                startPoint[1] += distance;\n                                endPoint[1] += distance;\n                            }\n                        }\n                        // If it doesn't exist, add an upper and lower border\n                        // for the vertical grid axis.\n                        if (!axis.horiz && axis.chart.marginRight) {\n                            const upperBorderStartPoint = startPoint, upperBorderEndPoint = [\n                                'L',\n                                axis.left,\n                                startPoint[2] || 0\n                            ], upperBorderPath = [\n                                upperBorderStartPoint,\n                                upperBorderEndPoint\n                            ], lowerBorderEndPoint = [\n                                'L',\n                                axis.chart.chartWidth - axis.chart.marginRight,\n                                axis.toPixels(max + axis.tickmarkOffset)\n                            ], lowerBorderStartPoint = [\n                                'M',\n                                endPoint[1] || 0,\n                                axis.toPixels(max + axis.tickmarkOffset)\n                            ], lowerBorderPath = [\n                                lowerBorderStartPoint,\n                                lowerBorderEndPoint\n                            ];\n                            if (!axis.grid.upperBorder && min % 1 !== 0) {\n                                axis.grid.upperBorder = axis.grid.renderBorder(upperBorderPath);\n                            }\n                            if (axis.grid.upperBorder) {\n                                axis.grid.upperBorder.attr({\n                                    stroke: options.lineColor,\n                                    'stroke-width': options.lineWidth\n                                });\n                                axis.grid.upperBorder.animate({\n                                    d: upperBorderPath\n                                });\n                            }\n                            if (!axis.grid.lowerBorder && max % 1 !== 0) {\n                                axis.grid.lowerBorder = axis.grid.renderBorder(lowerBorderPath);\n                            }\n                            if (axis.grid.lowerBorder) {\n                                axis.grid.lowerBorder.attr({\n                                    stroke: options.lineColor,\n                                    'stroke-width': options.lineWidth\n                                });\n                                axis.grid.lowerBorder.animate({\n                                    d: lowerBorderPath\n                                });\n                            }\n                        }\n                        // Render an extra line parallel to the existing axes, to\n                        // close the grid.\n                        if (!axis.grid.axisLineExtra) {\n                            axis.grid.axisLineExtra = axis.grid.renderBorder(linePath);\n                        }\n                        else {\n                            axis.grid.axisLineExtra.attr({\n                                stroke: options.lineColor,\n                                'stroke-width': options.lineWidth\n                            });\n                            axis.grid.axisLineExtra.animate({\n                                d: linePath\n                            });\n                        }\n                        // Show or hide the line depending on options.showEmpty\n                        axis.axisLine[axis.showAxis ? 'show' : 'hide']();\n                    }\n                }\n                (grid && grid.columns || []).forEach((column) => column.render());\n                // Manipulate the tick mark visibility\n                // based on the axis.max- allows smooth scrolling.\n                if (!axis.horiz &&\n                    axis.chart.hasRendered &&\n                    (axis.scrollbar ||\n                        (axis.linkedParent && axis.linkedParent.scrollbar)) &&\n                    axis.tickPositions.length) {\n                    const tickmarkOffset = axis.tickmarkOffset, lastTick = axis.tickPositions[axis.tickPositions.length - 1], firstTick = axis.tickPositions[0];\n                    let label, tickMark;\n                    while ((label = axis.hiddenLabels.pop()) && label.element) {\n                        label.show(); // #15453\n                    }\n                    while ((tickMark = axis.hiddenMarks.pop()) &&\n                        tickMark.element) {\n                        tickMark.show(); // #16439\n                    }\n                    // Hide/show first tick label.\n                    label = axis.ticks[firstTick].label;\n                    if (label) {\n                        if (min - firstTick > tickmarkOffset) {\n                            axis.hiddenLabels.push(label.hide());\n                        }\n                        else {\n                            label.show();\n                        }\n                    }\n                    // Hide/show last tick mark/label.\n                    label = axis.ticks[lastTick].label;\n                    if (label) {\n                        if (lastTick - max > tickmarkOffset) {\n                            axis.hiddenLabels.push(label.hide());\n                        }\n                        else {\n                            label.show();\n                        }\n                    }\n                    const mark = axis.ticks[lastTick].mark;\n                    if (mark &&\n                        lastTick - max < tickmarkOffset &&\n                        lastTick - max > 0 && axis.ticks[lastTick].isLast) {\n                        axis.hiddenMarks.push(mark.hide());\n                    }\n                }\n            }\n        }\n        /**\n         * @private\n         */\n        function onAfterSetAxisTranslation() {\n            const axis = this;\n            const tickInfo = axis.tickPositions && axis.tickPositions.info;\n            const options = axis.options;\n            const gridOptions = options.grid || {};\n            const userLabels = axis.userOptions.labels || {};\n            // Fire this only for the Gantt type chart, #14868.\n            if (gridOptions.enabled) {\n                if (axis.horiz) {\n                    axis.series.forEach((series) => {\n                        series.options.pointRange = 0;\n                    });\n                    // Lower level time ticks, like hours or minutes, represent\n                    // points in time and not ranges. These should be aligned\n                    // left in the grid cell by default. The same applies to\n                    // years of higher order.\n                    if (tickInfo &&\n                        options.dateTimeLabelFormats &&\n                        options.labels &&\n                        !defined(userLabels.align) &&\n                        (options.dateTimeLabelFormats[tickInfo.unitName]\n                            .range === false ||\n                            tickInfo.count > 1 // Years\n                        )) {\n                        options.labels.align = 'left';\n                        if (!defined(userLabels.x)) {\n                            options.labels.x = 3;\n                        }\n                    }\n                }\n                else {\n                    // Don't trim ticks which not in min/max range but\n                    // they are still in the min/max plus tickInterval.\n                    if (this.type !== 'treegrid' &&\n                        axis.grid &&\n                        axis.grid.columns) {\n                        this.minPointOffset = this.tickInterval;\n                    }\n                }\n            }\n        }\n        /**\n         * Creates a left and right wall on horizontal axes:\n         * - Places leftmost tick at the start of the axis, to create a left\n         *   wall\n         * - Ensures that the rightmost tick is at the end of the axis, to\n         *   create a right wall.\n         * @private\n         */\n        function onAfterSetOptions(e) {\n            const options = this.options, userOptions = e.userOptions, gridOptions = ((options && isObject(options.grid)) ? options.grid : {});\n            let gridAxisOptions;\n            if (gridOptions.enabled === true) {\n                // Merge the user options into default grid axis options so\n                // that when a user option is set, it takes precedence.\n                gridAxisOptions = merge(true, {\n                    className: ('highcharts-grid-axis ' + (userOptions.className || '')),\n                    dateTimeLabelFormats: {\n                        hour: {\n                            list: ['%H:%M', '%H']\n                        },\n                        day: {\n                            list: ['%A, %e. %B', '%a, %e. %b', '%E']\n                        },\n                        week: {\n                            list: ['Week %W', 'W%W']\n                        },\n                        month: {\n                            list: ['%B', '%b', '%o']\n                        }\n                    },\n                    grid: {\n                        borderWidth: 1\n                    },\n                    labels: {\n                        padding: 2,\n                        style: {\n                            fontSize: '0.9em'\n                        }\n                    },\n                    margin: 0,\n                    title: {\n                        text: null,\n                        reserveSpace: false,\n                        rotation: 0,\n                        style: {\n                            textOverflow: 'ellipsis'\n                        }\n                    },\n                    // In a grid axis, only allow one unit of certain types,\n                    // for example we shouldn't have one grid cell spanning\n                    // two days.\n                    units: [[\n                            'millisecond', // Unit name\n                            [1, 10, 100]\n                        ], [\n                            'second',\n                            [1, 10]\n                        ], [\n                            'minute',\n                            [1, 5, 15]\n                        ], [\n                            'hour',\n                            [1, 6]\n                        ], [\n                            'day',\n                            [1]\n                        ], [\n                            'week',\n                            [1]\n                        ], [\n                            'month',\n                            [1]\n                        ], [\n                            'year',\n                            null\n                        ]]\n                }, userOptions);\n                // X-axis specific options\n                if (this.coll === 'xAxis') {\n                    // For linked axes, tickPixelInterval is used only if\n                    // the tickPositioner below doesn't run or returns\n                    // undefined (like multiple years)\n                    if (defined(userOptions.linkedTo) &&\n                        !defined(userOptions.tickPixelInterval)) {\n                        gridAxisOptions.tickPixelInterval = 350;\n                    }\n                    // For the secondary grid axis, use the primary axis'\n                    // tick intervals and return ticks one level higher.\n                    if (\n                    // Check for tick pixel interval in options\n                    !defined(userOptions.tickPixelInterval) &&\n                        // Only for linked axes\n                        defined(userOptions.linkedTo) &&\n                        !defined(userOptions.tickPositioner) &&\n                        !defined(userOptions.tickInterval) &&\n                        !defined(userOptions.units)) {\n                        gridAxisOptions.tickPositioner = function (min, max) {\n                            const parentInfo = (this.linkedParent &&\n                                this.linkedParent.tickPositions &&\n                                this.linkedParent.tickPositions.info);\n                            if (parentInfo) {\n                                const units = (gridAxisOptions.units || []);\n                                let unitIdx, count = 1, unitName = 'year';\n                                for (let i = 0; i < units.length; i++) {\n                                    const unit = units[i];\n                                    if (unit && unit[0] === parentInfo.unitName) {\n                                        unitIdx = i;\n                                        break;\n                                    }\n                                }\n                                // Get the first allowed count on the next unit.\n                                const unit = (isNumber(unitIdx) && units[unitIdx + 1]);\n                                if (unit) {\n                                    unitName = unit[0] || 'year';\n                                    const counts = unit[1];\n                                    count = counts && counts[0] || 1;\n                                    // In case the base X axis shows years, make the\n                                    // secondary axis show ten times the years (#11427)\n                                }\n                                else if (parentInfo.unitName === 'year') {\n                                    // `unitName` is 'year'\n                                    count = parentInfo.count * 10;\n                                }\n                                const unitRange = timeUnits[unitName];\n                                this.tickInterval = unitRange * count;\n                                return this.chart.time.getTimeTicks({ unitRange, count, unitName }, min, max, this.options.startOfWeek);\n                            }\n                        };\n                    }\n                }\n                // Now merge the combined options into the axis options\n                merge(true, this.options, gridAxisOptions);\n                if (this.horiz) {\n                    /*               _________________________\n                    Make this:    ___|_____|_____|_____|__|\n                                    ^                     ^\n                                    _________________________\n                    Into this:    |_____|_____|_____|_____|\n                                        ^                 ^    */\n                    options.minPadding = pick(userOptions.minPadding, 0);\n                    options.maxPadding = pick(userOptions.maxPadding, 0);\n                }\n                // If borderWidth is set, then use its value for tick and\n                // line width.\n                if (isNumber(options.grid.borderWidth)) {\n                    options.tickWidth = options.lineWidth =\n                        gridOptions.borderWidth;\n                }\n            }\n        }\n        /**\n         * @private\n         */\n        function onAfterSetOptions2(e) {\n            const axis = this;\n            const userOptions = e.userOptions;\n            const gridOptions = userOptions && userOptions.grid || {};\n            const columns = gridOptions.columns;\n            // Add column options to the parent axis. Children has their column options\n            // set on init in onGridAxisAfterInit.\n            if (gridOptions.enabled && columns) {\n                merge(true, axis.options, columns[0]);\n            }\n        }\n        /**\n         * Handle columns and setScale.\n         * @private\n         */\n        function onAfterSetScale() {\n            const axis = this;\n            (axis.grid.columns || []).forEach((column) => column.setScale());\n        }\n        /**\n         * Draw vertical axis ticks extra long to create cell floors and roofs.\n         * Overrides the tickLength for vertical axes.\n         * @private\n         */\n        function onAfterTickSize(e) {\n            const { horiz, maxLabelDimensions, options: { grid: gridOptions = {} } } = this;\n            if (gridOptions.enabled && maxLabelDimensions) {\n                const labelPadding = this.options.labels.distance * 2;\n                const distance = horiz ?\n                    (gridOptions.cellHeight ||\n                        labelPadding + maxLabelDimensions.height) :\n                    labelPadding + maxLabelDimensions.width;\n                if (isArray(e.tickSize)) {\n                    e.tickSize[0] = distance;\n                }\n                else {\n                    e.tickSize = [distance, 0];\n                }\n            }\n        }\n        /**\n         * @private\n         */\n        function onChartAfterSetChartSize() {\n            this.axes.forEach((axis) => {\n                (axis.grid && axis.grid.columns || []).forEach((column) => {\n                    column.setAxisSize();\n                    column.setAxisTranslation();\n                });\n            });\n        }\n        /**\n         * @private\n         */\n        function onDestroy(e) {\n            const { grid } = this;\n            (grid.columns || []).forEach((column) => column.destroy(e.keepEvents));\n            grid.columns = void 0;\n        }\n        /**\n         * Wraps axis init to draw cell walls on vertical axes.\n         * @private\n         */\n        function onInit(e) {\n            const axis = this;\n            const userOptions = e.userOptions || {};\n            const gridOptions = userOptions.grid || {};\n            if (gridOptions.enabled && defined(gridOptions.borderColor)) {\n                userOptions.tickColor = userOptions.lineColor = (gridOptions.borderColor);\n            }\n            if (!axis.grid) {\n                axis.grid = new GridAxisAdditions(axis);\n            }\n            axis.hiddenLabels = [];\n            axis.hiddenMarks = [];\n        }\n        /**\n         * Center tick labels in cells.\n         * @private\n         */\n        function onTickAfterGetLabelPosition(e) {\n            const tick = this, label = tick.label, axis = tick.axis, reversed = axis.reversed, chart = axis.chart, options = axis.options, gridOptions = options.grid || {}, labelOpts = axis.options.labels, align = labelOpts.align, \n            // `verticalAlign` is currently not supported for axis.labels.\n            verticalAlign = 'middle', // LabelOpts.verticalAlign,\n            side = GridAxisSide[axis.side], tickmarkOffset = e.tickmarkOffset, tickPositions = axis.tickPositions, tickPos = tick.pos - tickmarkOffset, nextTickPos = (isNumber(tickPositions[e.index + 1]) ?\n                tickPositions[e.index + 1] - tickmarkOffset :\n                (axis.max || 0) + tickmarkOffset), tickSize = axis.tickSize('tick'), tickWidth = tickSize ? tickSize[0] : 0, crispCorr = tickSize ? tickSize[1] / 2 : 0;\n            // Only center tick labels in grid axes\n            if (gridOptions.enabled === true) {\n                let bottom, top, left, right;\n                // Calculate top and bottom positions of the cell.\n                if (side === 'top') {\n                    bottom = axis.top + axis.offset;\n                    top = bottom - tickWidth;\n                }\n                else if (side === 'bottom') {\n                    top = chart.chartHeight - axis.bottom + axis.offset;\n                    bottom = top + tickWidth;\n                }\n                else {\n                    bottom = axis.top + axis.len - (axis.translate(reversed ? nextTickPos : tickPos) || 0);\n                    top = axis.top + axis.len - (axis.translate(reversed ? tickPos : nextTickPos) || 0);\n                }\n                // Calculate left and right positions of the cell.\n                if (side === 'right') {\n                    left = chart.chartWidth - axis.right + axis.offset;\n                    right = left + tickWidth;\n                }\n                else if (side === 'left') {\n                    right = axis.left + axis.offset;\n                    left = right - tickWidth;\n                }\n                else {\n                    left = Math.round(axis.left + (axis.translate(reversed ? nextTickPos : tickPos) || 0)) - crispCorr;\n                    right = Math.min(// #15742\n                    Math.round(axis.left + (axis.translate(reversed ? tickPos : nextTickPos) || 0)) - crispCorr, axis.left + axis.len);\n                }\n                tick.slotWidth = right - left;\n                // Calculate the positioning of the label based on\n                // alignment.\n                e.pos.x = (align === 'left' ?\n                    left :\n                    align === 'right' ?\n                        right :\n                        left + ((right - left) / 2) // Default to center\n                );\n                e.pos.y = (verticalAlign === 'top' ?\n                    top :\n                    verticalAlign === 'bottom' ?\n                        bottom :\n                        top + ((bottom - top) / 2) // Default to middle\n                );\n                if (label) {\n                    const lblMetrics = chart.renderer.fontMetrics(label), labelHeight = label.getBBox().height;\n                    // Adjustment to y position to align the label correctly.\n                    // Would be better to have a setter or similar for this.\n                    if (!labelOpts.useHTML) {\n                        const lines = Math.round(labelHeight / lblMetrics.h);\n                        e.pos.y += (\n                        // Center the label\n                        // TODO: why does this actually center the label?\n                        ((lblMetrics.b - (lblMetrics.h - lblMetrics.f)) / 2) +\n                            // Adjust for height of additional lines.\n                            -(((lines - 1) * lblMetrics.h) / 2));\n                    }\n                    else {\n                        e.pos.y += (\n                        // Readjust yCorr in htmlUpdateTransform\n                        lblMetrics.b +\n                            // Adjust for height of html label\n                            -(labelHeight / 2));\n                    }\n                }\n                e.pos.x += (axis.horiz && labelOpts.x) || 0;\n            }\n        }\n        /**\n         * @private\n         */\n        function onTickLabelFormat(ctx) {\n            const { axis, value } = ctx;\n            if (axis.options.grid &&\n                axis.options.grid.enabled) {\n                const tickPos = axis.tickPositions;\n                const series = (axis.linkedParent || axis).series[0];\n                const isFirst = value === tickPos[0];\n                const isLast = value === tickPos[tickPos.length - 1];\n                const point = series && find(series.options.data, function (p) {\n                    return p[axis.isXAxis ? 'x' : 'y'] === value;\n                });\n                let pointCopy;\n                if (point && series.is('gantt')) {\n                    // For the Gantt set point aliases to the pointCopy\n                    // to do not change the original point\n                    pointCopy = merge(point);\n                    H.seriesTypes.gantt.prototype.pointClass\n                        .setGanttPointAliases(pointCopy);\n                }\n                // Make additional properties available for the\n                // formatter\n                ctx.isFirst = isFirst;\n                ctx.isLast = isLast;\n                ctx.point = pointCopy;\n            }\n        }\n        /**\n         * Makes tick labels which are usually ignored in a linked axis\n         * displayed if they are within range of linkedParent.min.\n         * ```\n         *                        _____________________________\n         *                        |   |       |       |       |\n         * Make this:             |   |   2   |   3   |   4   |\n         *                        |___|_______|_______|_______|\n         *                          ^\n         *                        _____________________________\n         *                        |   |       |       |       |\n         * Into this:             | 1 |   2   |   3   |   4   |\n         *                        |___|_______|_______|_______|\n         *                          ^\n         * ```\n         * @private\n         * @todo Does this function do what the drawing says? Seems to affect\n         *       ticks and not the labels directly?\n         */\n        function onTrimTicks() {\n            const axis = this, options = axis.options, gridOptions = options.grid || {}, categoryAxis = axis.categories, tickPositions = axis.tickPositions, firstPos = tickPositions[0], secondPos = tickPositions[1], lastPos = tickPositions[tickPositions.length - 1], beforeLastPos = tickPositions[tickPositions.length - 2], linkedMin = axis.linkedParent && axis.linkedParent.min, linkedMax = axis.linkedParent && axis.linkedParent.max, min = linkedMin || axis.min, max = linkedMax || axis.max, tickInterval = axis.tickInterval, startLessThanMin = ( // #19845\n            isNumber(min) &&\n                min >= firstPos + tickInterval &&\n                min < secondPos), endMoreThanMin = (isNumber(min) &&\n                firstPos < min &&\n                firstPos + tickInterval > min), startLessThanMax = (isNumber(max) &&\n                lastPos > max &&\n                lastPos - tickInterval < max), endMoreThanMax = (isNumber(max) &&\n                max <= lastPos - tickInterval &&\n                max > beforeLastPos);\n            if (gridOptions.enabled === true &&\n                !categoryAxis &&\n                (axis.isXAxis || axis.isLinked)) {\n                if ((endMoreThanMin || startLessThanMin) && !options.startOnTick) {\n                    tickPositions[0] = min;\n                }\n                if ((startLessThanMax || endMoreThanMax) && !options.endOnTick) {\n                    tickPositions[tickPositions.length - 1] = max;\n                }\n            }\n        }\n        /**\n         * Avoid altering tickInterval when reserving space.\n         * @private\n         */\n        function wrapUnsquish(proceed) {\n            const axis = this;\n            const { options: { grid: gridOptions = {} } } = axis;\n            if (gridOptions.enabled === true && axis.categories) {\n                return axis.tickInterval;\n            }\n            return proceed.apply(axis, argsToArray(arguments));\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Additions for grid axes.\n         * @private\n         * @class\n         */\n        class GridAxisAdditions {\n            /* *\n            *\n            *  Constructors\n            *\n            * */\n            constructor(axis) {\n                this.axis = axis;\n            }\n            /* *\n            *\n            *  Functions\n            *\n            * */\n            /**\n             * Checks if an axis is the outer axis in its dimension. Since\n             * axes are placed outwards in order, the axis with the highest\n             * index is the outermost axis.\n             *\n             * Example: If there are multiple x-axes at the top of the chart,\n             * this function returns true if the axis supplied is the last\n             * of the x-axes.\n             *\n             * @private\n             *\n             * @return {boolean}\n             * True if the axis is the outermost axis in its dimension; false if\n             * not.\n             */\n            isOuterAxis() {\n                const axis = this.axis;\n                const chart = axis.chart;\n                const columnIndex = axis.grid.columnIndex;\n                const columns = (axis.linkedParent?.grid.columns ||\n                    axis.grid.columns ||\n                    []);\n                const parentAxis = columnIndex ? axis.linkedParent : axis;\n                let thisIndex = -1, lastIndex = 0;\n                // On the left side, when we have columns (not only multiple axes), the\n                // main axis is to the left\n                if (axis.side === 3 && !chart.inverted && columns.length) {\n                    return !axis.linkedParent;\n                }\n                (chart[axis.coll] || []).forEach((otherAxis, index) => {\n                    if (otherAxis.side === axis.side &&\n                        !otherAxis.options.isInternal) {\n                        lastIndex = index;\n                        if (otherAxis === parentAxis) {\n                            // Get the index of the axis in question\n                            thisIndex = index;\n                        }\n                    }\n                });\n                return (lastIndex === thisIndex &&\n                    (isNumber(columnIndex) ?\n                        columns.length === columnIndex :\n                        true));\n            }\n            /**\n             * Add extra border based on the provided path.\n             * @private\n             * @param {SVGPath} path\n             * The path of the border.\n             * @return {Highcharts.SVGElement}\n             * Border\n             */\n            renderBorder(path) {\n                const axis = this.axis, renderer = axis.chart.renderer, options = axis.options, extraBorderLine = renderer.path(path)\n                    .addClass('highcharts-axis-line')\n                    .add(axis.axisGroup);\n                if (!renderer.styledMode) {\n                    extraBorderLine.attr({\n                        stroke: options.lineColor,\n                        'stroke-width': options.lineWidth,\n                        zIndex: 7\n                    });\n                }\n                return extraBorderLine;\n            }\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        // First letter of the day of the week, e.g. 'M' for 'Monday'.\n        dateFormats.E = function (timestamp) {\n            return this.dateFormat('%a', timestamp, true).charAt(0);\n        };\n        // Adds week date format\n        dateFormats.W = function (timestamp) {\n            const time = this, d = new this.Date(timestamp), unitsToOmit = ['Hours', 'Milliseconds', 'Minutes', 'Seconds'];\n            unitsToOmit.forEach(function (format) {\n                time.set(format, d, 0);\n            });\n            const firstDay = (this.get('Day', d) + 6) % 7;\n            const thursday = new this.Date(d.valueOf());\n            this.set('Date', thursday, this.get('Date', d) - firstDay + 3);\n            const firstThursday = new this.Date(this.get('FullYear', thursday), 0, 1);\n            if (this.get('Day', firstThursday) !== 4) {\n                this.set('Month', d, 0);\n                this.set('Date', d, 1 + (11 - this.get('Day', firstThursday)) % 7);\n            }\n            return (1 +\n                Math.floor((thursday.valueOf() - firstThursday.valueOf()) / 604800000)).toString();\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const GridAxis = {\n            compose\n        };\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * @productdesc {gantt}\n         * For grid axes (like in Gantt charts),\n         * it is possible to declare as a list to provide different\n         * formats depending on available space.\n         *\n         * Defaults to:\n         * ```js\n         * {\n         *     hour: { list: ['%H:%M', '%H'] },\n         *     day: { list: ['%A, %e. %B', '%a, %e. %b', '%E'] },\n         *     week: { list: ['Week %W', 'W%W'] },\n         *     month: { list: ['%B', '%b', '%o'] }\n         * }\n         * ```\n         *\n         * @sample {gantt} gantt/grid-axis/date-time-label-formats\n         *         Gantt chart with custom axis date format.\n         *\n         * @apioption xAxis.dateTimeLabelFormats\n         */\n        /**\n         * Set grid options for the axis labels. Requires Highcharts Gantt.\n         *\n         * @since     6.2.0\n         * @product   gantt\n         * @apioption xAxis.grid\n         */\n        /**\n         * Enable grid on the axis labels. Defaults to true for Gantt charts.\n         *\n         * @type      {boolean}\n         * @default   true\n         * @since     6.2.0\n         * @product   gantt\n         * @apioption xAxis.grid.enabled\n         */\n        /**\n         * Set specific options for each column (or row for horizontal axes) in the\n         * grid. Each extra column/row is its own axis, and the axis options can be set\n         * here.\n         *\n         * @sample gantt/demo/left-axis-table\n         *         Left axis as a table\n         * @sample gantt/demo/treegrid-columns\n         *         Collapsible tree grid with columns\n         *\n         * @type      {Array<Highcharts.XAxisOptions>}\n         * @apioption xAxis.grid.columns\n         */\n        /**\n         * Set border color for the label grid lines.\n         *\n         * @type      {Highcharts.ColorString}\n         * @default   #e6e6e6\n         * @apioption xAxis.grid.borderColor\n         */\n        /**\n         * Set border width of the label grid lines.\n         *\n         * @type      {number}\n         * @default   1\n         * @apioption xAxis.grid.borderWidth\n         */\n        /**\n         * Set cell height for grid axis labels. By default this is calculated from font\n         * size. This option only applies to horizontal axes. For vertical axes, check\n         * the [#yAxis.staticScale](yAxis.staticScale) option.\n         *\n         * @sample gantt/grid-axis/cellheight\n         *         Gant chart with custom cell height\n         * @type      {number}\n         * @apioption xAxis.grid.cellHeight\n         */\n        ''; // Keeps doclets above in JS file\n\n        return GridAxis;\n    });\n    _registerModule(_modules, 'masters/modules/grid-axis.src.js', [_modules['Core/Globals.js'], _modules['Core/Axis/GridAxis.js']], function (Highcharts, GridAxis) {\n\n        const G = Highcharts;\n        // Compositions\n        GridAxis.compose(G.Axis, G.Chart, G.Tick);\n\n        return Highcharts;\n    });\n}));\n"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","win","dispatchEvent","detail","Axis","H","U","GridAxisSide","dateFormats","addEvent","defined","erase","find","isArray","isNumber","merge","pick","timeUnits","wrap","isObject","x","getMaxLabelDimensions","ticks","tickPositions","dimensions","width","height","forEach","pos","tick","labelHeight","labelWidth","label","getBBox","textStr","textPxLength","Math","round","max","type","treeGrid","mapOfPosToGridNode","treeDepth","options","labels","indentation","wrapGetOffset","proceed","grid","columnsFirst","side","isColumn","columns","slice","reverse","column","getOffset","onAfterGetTitlePosition","e","gridOptions","axis","enabled","axisTitle","axisHeight","horiz","left","axisLeft","offset","opposite","top","axisTop","axisWidth","tickSize","titleWidth","xOption","title","yOption","y","titleMargin","margin","titleFontSize","chart","renderer","fontMetrics","f","offAxis","bottom","titlePosition","onAfterInit","userOptions","applyGridOptions","align","categories","showLastLabel","labelRotation","rotation","minTickInterval","columnIndex","length","columnOptions","isInternal","linkedTo","scrollbar","axes","coll","push","onAfterRender","min","firstTick","styledMode","slotWidth","style","css","maxLabelDimensions","rightWall","destroy","isOuterAxis","axisLine","lineWidth","linePath","getLinePath","startPoint","endPoint","distance","tickLength","marginRight","upperBorderEndPoint","upperBorderPath","lowerBorderEndPoint","chartWidth","toPixels","tickmarkOffset","lowerBorderPath","upperBorder","renderBorder","attr","stroke","lineColor","animate","d","lowerBorder","axisLineExtra","showAxis","render","hasRendered","linkedParent","tickMark","lastTick","hiddenLabels","pop","element","show","hiddenMarks","hide","mark","isLast","onAfterSetAxisTranslation","tickInfo","info","userLabels","series","pointRange","dateTimeLabelFormats","unitName","range","count","minPointOffset","tickInterval","onAfterSetOptions","gridAxisOptions","className","hour","list","day","week","month","borderWidth","padding","fontSize","text","reserveSpace","textOverflow","units","tickPixelInterval","tickPositioner","parentInfo","unitIdx","i","unit","counts","unitRange","time","getTimeTicks","startOfWeek","minPadding","maxPadding","tickWidth","onAfterSetOptions2","onAfterSetScale","setScale","onAfterTickSize","labelPadding","cellHeight","onChartAfterSetChartSize","setAxisSize","setAxisTranslation","onDestroy","keepEvents","onInit","borderColor","tickColor","GridAxisAdditions","onTickAfterGetLabelPosition","reversed","labelOpts","tickPos","nextTickPos","index","crispCorr","right","chartHeight","len","translate","lblMetrics","useHTML","b","lines","h","onTickLabelFormat","ctx","value","pointCopy","isFirst","point","data","p","isXAxis","is","seriesTypes","gantt","prototype","pointClass","setGanttPointAliases","onTrimTicks","categoryAxis","firstPos","secondPos","lastPos","beforeLastPos","linkedMin","linkedMax","startLessThanMin","endMoreThanMin","startLessThanMax","endMoreThanMax","isLinked","startOnTick","endOnTick","wrapUnsquish","arguments","Array","call","constructor","parentAxis","thisIndex","lastIndex","inverted","otherAxis","extraBorderLine","addClass","add","axisGroup","zIndex","E","timestamp","dateFormat","charAt","W","Date","unitsToOmit","format","set","firstDay","get","thursday","valueOf","firstThursday","floor","toString","compose","AxisClass","ChartClass","TickClass","keepProps","includes","GridAxis","G","Chart","Tick"],"mappings":"CAAA;;;;;;;;CAQC,EACA,SAAUA,CAAO,EACV,AAAkB,UAAlB,OAAOC,QAAuBA,OAAOC,OAAO,EAC5CF,EAAQ,OAAU,CAAGA,EACrBC,OAAOC,OAAO,CAAGF,GACV,AAAkB,YAAlB,OAAOG,QAAyBA,OAAOC,GAAG,CACjDD,OAAO,+BAAgC,CAAC,aAAa,CAAE,SAAUE,CAAU,EAGvE,OAFAL,EAAQK,GACRL,EAAQK,UAAU,CAAGA,EACdL,CACX,GAEAA,EAAQ,AAAsB,aAAtB,OAAOK,WAA6BA,WAAaC,KAAAA,EAEjE,EAAE,SAAUD,CAAU,EAClB,aACA,IAAIE,EAAWF,EAAaA,EAAWE,QAAQ,CAAG,CAAC,EACnD,SAASC,EAAgBC,CAAG,CAAEC,CAAI,CAAEC,CAAI,CAAEC,CAAE,EACnCH,EAAII,cAAc,CAACH,KACpBD,CAAG,CAACC,EAAK,CAAGE,EAAGE,KAAK,CAAC,KAAMH,GAEA,YAAvB,OAAOI,aACPV,EAAWW,GAAG,CAACC,aAAa,CAAC,IAAIF,YAC7B,yBACA,CAAEG,OAAQ,CAAER,KAAMA,EAAMT,OAAQQ,CAAG,CAACC,EAAK,AAAC,CAAE,IAI5D,CACAF,EAAgBD,EAAU,wBAAyB,CAACA,CAAQ,CAAC,oBAAoB,CAAEA,CAAQ,CAAC,kBAAkB,CAAEA,CAAQ,CAAC,oBAAoB,CAAC,CAAE,SAAUY,CAAI,CAAEC,CAAC,CAAEC,CAAC,MAsB5JC,EACOA,EAZX,GAAM,CAAEC,YAAAA,CAAW,CAAE,CAAGH,EAClB,CAAEI,SAAAA,CAAQ,CAAEC,QAAAA,CAAO,CAAEC,MAAAA,CAAK,CAAEC,KAAAA,CAAI,CAAEC,QAAAA,CAAO,CAAEC,SAAAA,CAAQ,CAAEC,MAAAA,CAAK,CAAEC,KAAAA,CAAI,CAAEC,UAAAA,CAAS,CAAEC,KAAAA,CAAI,CAAE,CAAGZ,EA+B5F,SAASa,EAASC,CAAC,EAEf,OAAOd,EAAEa,QAAQ,CAACC,EAAG,CAAA,EACzB,CA0EA,SAASC,EAAsBC,CAAK,CAAEC,CAAa,EAC/C,IAAMC,EAAa,CACfC,MAAO,EACPC,OAAQ,CACZ,EA0BA,GAzBAH,EAAcI,OAAO,CAAC,SAAUC,CAAG,EAC/B,IAAMC,EAAOP,CAAK,CAACM,EAAI,CACnBE,EAAc,EAAGC,EAAa,EAAGC,EACjCb,EAASU,KAGTC,EAAcE,AAFdA,CAAAA,EAAQb,EAASU,EAAKG,KAAK,EAAIH,EAAKG,KAAK,CAAG,CAAC,CAAA,EAEzBC,OAAO,CAAGD,EAAMC,OAAO,GAAGP,MAAM,CAAG,EACnDM,EAAME,OAAO,EAAI,CAACpB,EAASkB,EAAMG,YAAY,GAC7CH,CAAAA,EAAMG,YAAY,CAAGH,EAAMC,OAAO,GAAGR,KAAK,AAAD,EAE7CM,EAAajB,EAASkB,EAAMG,YAAY,EAEpCC,KAAKC,KAAK,CAACL,EAAMG,YAAY,EAC7B,EACAH,EAAME,OAAO,EAGbH,CAAAA,EAAaK,KAAKC,KAAK,CAACL,EAAMC,OAAO,GAAGR,KAAK,CAAA,EAGjDD,EAAWE,MAAM,CAAGU,KAAKE,GAAG,CAACR,EAAaN,EAAWE,MAAM,EAC3DF,EAAWC,KAAK,CAAGW,KAAKE,GAAG,CAACP,EAAYP,EAAWC,KAAK,EAEhE,GAEI,AAAc,aAAd,IAAI,CAACc,IAAI,EACT,IAAI,CAACC,QAAQ,EACb,IAAI,CAACA,QAAQ,CAACC,kBAAkB,CAAE,CAClC,IAAMC,EAAY,IAAI,CAACF,QAAQ,CAACC,kBAAkB,CAAC,GAAG,CAACf,MAAM,EAAI,CACjEF,CAAAA,EAAWC,KAAK,EAAK,IAAI,CAACkB,OAAO,CAACC,MAAM,CAACC,WAAW,CAC/CH,CAAAA,EAAY,CAAA,CACrB,CACA,OAAOlB,CACX,CAKA,SAASsB,EAAcC,CAAO,EAC1B,GAAM,CAAEC,KAAAA,CAAI,CAAE,CAAG,IAAI,CAGrBC,EAAe,AAAc,IAAd,IAAI,CAACC,IAAI,CAIxB,GAHKD,GACDF,EAAQhD,KAAK,CAAC,IAAI,EAElB,CAACiD,GAAMG,SAAU,CACjB,IAAIC,EAAUJ,GAAMI,SAAW,EAAE,CAC7BH,GACAG,CAAAA,EAAUA,EAAQC,KAAK,GAAGC,OAAO,EAAC,EAEtCF,EACKzB,OAAO,CAAC,AAAC4B,IACVA,EAAOC,SAAS,EACpB,EACJ,CACIP,GACAF,EAAQhD,KAAK,CAAC,IAAI,CAE1B,CAIA,SAAS0D,EAAwBC,CAAC,EAI9B,GAAIC,AAAwB,CAAA,IAAxBA,AADgBhB,CAAAA,AADJiB,AADH,IAAI,CACIjB,OAAO,CACAK,IAAI,EAAI,CAAC,CAAA,EACrBa,OAAO,CAAW,CAE9B,GAAM,CAAEC,UAAAA,CAAS,CAAEpC,OAAQqC,CAAU,CAAEC,MAAAA,CAAK,CAAEC,KAAMC,CAAQ,CAAEC,OAAAA,CAAM,CAAEC,SAAAA,CAAQ,CAAEzB,QAAAA,CAAO,CAAE0B,IAAKC,CAAO,CAAE7C,MAAO8C,CAAS,CAAE,CALhH,IAAI,CAMPC,EAAWZ,AANR,IAAI,CAMSY,QAAQ,GACxBC,EAAaX,GAAaA,EAAU7B,OAAO,GAAGR,KAAK,CACnDiD,EAAU/B,EAAQgC,KAAK,CAACvD,CAAC,CACzBwD,EAAUjC,EAAQgC,KAAK,CAACE,CAAC,CACzBC,EAAc9D,EAAK2B,EAAQgC,KAAK,CAACI,MAAM,CAAEf,EAAQ,EAAI,IACrDgB,EAAgBlB,EAAYF,AAXzB,IAAI,CAW0BqB,KAAK,CAACC,QAAQ,CAACC,WAAW,CAACrB,GAAWsB,CAAC,CAAG,EAI3EC,EAAW,AAACrB,CAAAA,EAAQM,EAAUP,EAAaG,CAAO,EACpD,AAACF,CAAAA,EAAQ,EAAI,EAAC,EACTI,CAAAA,EAAW,GAAK,CAAA,EALPI,CAAAA,EAAWA,CAAQ,CAAC,EAAE,CAAG,EAAI,CAAA,EAO1CZ,CAAAA,AAnBI,IAAI,CAmBHV,IAAI,GAAK3C,EAAa+E,MAAM,CAAGN,EAAgB,CAAA,CACzDtB,CAAAA,EAAE6B,aAAa,CAACnE,CAAC,CAAG4C,EAChBE,EAAW,AAACO,CAAAA,GAAc,CAAA,EAAK,EAAIK,EAAcJ,EACjDW,EAAWjB,CAAAA,EAAWG,EAAY,CAAA,EAAKJ,EAASO,EACpDhB,EAAE6B,aAAa,CAACV,CAAC,CAAGb,EACfqB,EACIjB,CAAAA,EAAWL,EAAa,CAAA,EACzB,AAACK,CAAAA,EAAWY,EAAgB,CAACA,CAAY,EAAK,EAC9Cb,EACAS,EACJN,EAAUQ,EAAcF,CAChC,CACJ,CAIA,SAASY,IAEL,GAAM,CAAEP,MAAAA,CAAK,CAAEtC,QAAS,CAAEK,KAAMW,EAAc,CAAC,CAAC,CAAE,CAAE8B,YAAAA,CAAW,CAAE,CADpD,IAAI,CAKjB,GAHI9B,EAAYE,OAAO,EACnB6B,AAlLR,SAA0B9B,CAAI,EAC1B,IAAMjB,EAAUiB,EAAKjB,OAAO,AAO5BA,CAAAA,EAAQC,MAAM,CAAC+C,KAAK,CAAG3E,EAAK2B,EAAQC,MAAM,CAAC+C,KAAK,CAAE,UAO7C/B,EAAKgC,UAAU,EAChBjD,CAAAA,EAAQkD,aAAa,CAAG,CAAA,CAAI,EAIhCjC,EAAKkC,aAAa,CAAG,EACrBnD,EAAQC,MAAM,CAACmD,QAAQ,CAAG,EAE1BpD,EAAQqD,eAAe,CAAG,CAC9B,EAuJiB,IAAI,EAKbrC,EAAYP,OAAO,CAAE,CACrB,IAAMA,EAAUQ,AANP,IAAI,CAMQZ,IAAI,CAACI,OAAO,CAAG,EAAE,CAClC6C,EAAcrC,AAPT,IAAI,CAOUZ,IAAI,CAACiD,WAAW,CAAG,EAE1C,KAAO,EAAEA,EAActC,EAAYP,OAAO,CAAC8C,MAAM,EAAE,CAC/C,IAAMC,EAAgBpF,EAAM0E,EAAa9B,EAAYP,OAAO,CAAC6C,EAAY,CAAE,CACvEG,WAAY,CAAA,EACZC,SAAU,EAEVC,UAAW,CACPzC,QAAS,CAAA,CACb,CACJ,EAEA,CACIb,KAAM,CACFI,QAAS,KAAK,CAClB,CACJ,GACMG,EAAS,IAAInD,EAAKwD,AAxBnB,IAAI,CAwBoBqB,KAAK,CAAEkB,EAAe,QACnD5C,CAAAA,EAAOP,IAAI,CAACG,QAAQ,CAAG,CAAA,EACvBI,EAAOP,IAAI,CAACiD,WAAW,CAAGA,EAG1BtF,EAAMsE,EAAMsB,IAAI,CAAEhD,GAClB5C,EAAMsE,CAAK,CAACrB,AA9BP,IAAI,CA8BQ4C,IAAI,CAAC,EAAI,EAAE,CAAEjD,GAC9BH,EAAQqD,IAAI,CAAClD,EACjB,CACJ,CACJ,CAcA,SAASmD,IACL,GAAmB,CAAE5C,UAAAA,CAAS,CAAEd,KAAAA,CAAI,CAAEL,QAAAA,CAAO,CAAE,CAAlC,IAAI,CACjB,GAAIgB,AAAwB,CAAA,IAAxBA,AADkEhB,CAAAA,EAAQK,IAAI,EAAI,CAAC,CAAA,EACvEa,OAAO,CAAW,CAC9B,IAAM8C,EAAM/C,AAFH,IAAI,CAEI+C,GAAG,EAAI,EAAGrE,EAAMsB,AAFxB,IAAI,CAEyBtB,GAAG,EAAI,EAAGsE,EAAYhD,AAFnD,IAAI,CAEoDtC,KAAK,CAACsC,AAF9D,IAAI,CAE+DrC,aAAa,CAAC,EAAE,CAAC,CAsB7F,GApBIuC,GACA,CAACF,AALI,IAAI,CAKHqB,KAAK,CAAC4B,UAAU,EACtBD,GAAWE,WACX,CAAClD,AAPI,IAAI,CAOHjB,OAAO,CAACgC,KAAK,CAACoC,KAAK,CAACtF,KAAK,EAC/BqC,EAAUkD,GAAG,CAAC,CAAEvF,MAAO,CAAC,EAAEmF,EAAUE,SAAS,CAAC,EAAE,CAAC,AAAC,GAGtDlD,AAXS,IAAI,CAWRqD,kBAAkB,CAAGrD,AAXjB,IAAI,CAWkBvC,qBAAqB,CAACuC,AAX5C,IAAI,CAW6CtC,KAAK,CAAEsC,AAXxD,IAAI,CAWyDrC,aAAa,EAE/EqC,AAbK,IAAI,CAaJsD,SAAS,EACdtD,AAdK,IAAI,CAcJsD,SAAS,CAACC,OAAO,GAUtBvD,AAxBK,IAAI,CAwBJZ,IAAI,EAAIY,AAxBR,IAAI,CAwBSZ,IAAI,CAACoE,WAAW,IAAMxD,AAxBnC,IAAI,CAwBoCyD,QAAQ,CAAE,CACvD,IAAMC,EAAY3E,EAAQ2E,SAAS,CACnC,GAAIA,EAAW,CACX,IAAMC,EAAW3D,AA3BhB,IAAI,CA2BiB4D,WAAW,CAACF,GAAYG,EAAaF,CAAQ,CAAC,EAAE,CAAEG,EAAWH,CAAQ,CAAC,EAAE,CAG9CI,EAAWC,AAA9C,AAAChE,CAAAA,AA9Bb,IAAI,CA8BcY,QAAQ,CAAC,SAAW,CAAC,EAAE,AAAD,CAAE,CAAC,EAAE,CAA2B,CAAA,AAACZ,AA9BzE,IAAI,CA8B0EV,IAAI,GAAK3C,EAAa8D,GAAG,EACpGT,AA/BH,IAAI,CA+BIV,IAAI,GAAK3C,EAAa0D,IAAI,CAAI,GAAK,CAAA,EAc5C,GAZsB,MAAlBwD,CAAU,CAAC,EAAE,EAAYC,AAAgB,MAAhBA,CAAQ,CAAC,EAAE,GAChC9D,AAlCP,IAAI,CAkCQI,KAAK,EACVyD,CAAU,CAAC,EAAE,EAAIE,EACjBD,CAAQ,CAAC,EAAE,EAAIC,IAGfF,CAAU,CAAC,EAAE,EAAIE,EACjBD,CAAQ,CAAC,EAAE,EAAIC,IAKnB,CAAC/D,AA7CJ,IAAI,CA6CKI,KAAK,EAAIJ,AA7ClB,IAAI,CA6CmBqB,KAAK,CAAC4C,WAAW,CAAE,CACvC,IAA0CC,EAAsB,CAC5D,IACAlE,AAhDP,IAAI,CAgDQK,IAAI,CACTwD,CAAU,CAAC,EAAE,EAAI,EACpB,CAAEM,EAAkB,CAJSN,EAM1BK,EACH,CAAEE,EAAsB,CACrB,IACApE,AAvDP,IAAI,CAuDQqB,KAAK,CAACgD,UAAU,CAAGrE,AAvD/B,IAAI,CAuDgCqB,KAAK,CAAC4C,WAAW,CAC9CjE,AAxDP,IAAI,CAwDQsE,QAAQ,CAAC5F,EAAMsB,AAxD3B,IAAI,CAwD4BuE,cAAc,EAC1C,CAIEC,EAAkB,CAJM,CACvB,IACAV,CAAQ,CAAC,EAAE,EAAI,EACf9D,AA5DP,IAAI,CA4DQsE,QAAQ,CAAC5F,EAAMsB,AA5D3B,IAAI,CA4D4BuE,cAAc,EAC1C,CAEGH,EACH,AACIpE,CAjER,IAAI,CAiESZ,IAAI,CAACqF,WAAW,EAAI1B,EAAM,GAAM,GACtC/C,CAAAA,AAlEP,IAAI,CAkEQZ,IAAI,CAACqF,WAAW,CAAGzE,AAlE/B,IAAI,CAkEgCZ,IAAI,CAACsF,YAAY,CAACP,EAAe,EAE9DnE,AApEP,IAAI,CAoEQZ,IAAI,CAACqF,WAAW,GACrBzE,AArEP,IAAI,CAqEQZ,IAAI,CAACqF,WAAW,CAACE,IAAI,CAAC,CACvBC,OAAQ7F,EAAQ8F,SAAS,CACzB,eAAgB9F,EAAQ2E,SAAS,AACrC,GACA1D,AAzEP,IAAI,CAyEQZ,IAAI,CAACqF,WAAW,CAACK,OAAO,CAAC,CAC1BC,EAAGZ,CACP,IAECnE,AA7ER,IAAI,CA6ESZ,IAAI,CAAC4F,WAAW,EAAItG,EAAM,GAAM,GACtCsB,CAAAA,AA9EP,IAAI,CA8EQZ,IAAI,CAAC4F,WAAW,CAAGhF,AA9E/B,IAAI,CA8EgCZ,IAAI,CAACsF,YAAY,CAACF,EAAe,EAE9DxE,AAhFP,IAAI,CAgFQZ,IAAI,CAAC4F,WAAW,GACrBhF,AAjFP,IAAI,CAiFQZ,IAAI,CAAC4F,WAAW,CAACL,IAAI,CAAC,CACvBC,OAAQ7F,EAAQ8F,SAAS,CACzB,eAAgB9F,EAAQ2E,SAAS,AACrC,GACA1D,AArFP,IAAI,CAqFQZ,IAAI,CAAC4F,WAAW,CAACF,OAAO,CAAC,CAC1BC,EAAGP,CACP,GAER,CAGKxE,AA5FJ,IAAI,CA4FKZ,IAAI,CAAC6F,aAAa,EAIxBjF,AAhGH,IAAI,CAgGIZ,IAAI,CAAC6F,aAAa,CAACN,IAAI,CAAC,CACzBC,OAAQ7F,EAAQ8F,SAAS,CACzB,eAAgB9F,EAAQ2E,SAAS,AACrC,GACA1D,AApGH,IAAI,CAoGIZ,IAAI,CAAC6F,aAAa,CAACH,OAAO,CAAC,CAC5BC,EAAGpB,CACP,IATA3D,AA7FH,IAAI,CA6FIZ,IAAI,CAAC6F,aAAa,CAAGjF,AA7F7B,IAAI,CA6F8BZ,IAAI,CAACsF,YAAY,CAACf,GAYrD3D,AAzGC,IAAI,CAyGAyD,QAAQ,CAACzD,AAzGb,IAAI,CAyGckF,QAAQ,CAAG,OAAS,OAAO,EAClD,CACJ,CAIA,GAHA,AAAC9F,CAAAA,GAAQA,EAAKI,OAAO,EAAI,EAAE,AAAD,EAAGzB,OAAO,CAAC,AAAC4B,GAAWA,EAAOwF,MAAM,IAG1D,CAACnF,AA/GI,IAAI,CA+GHI,KAAK,EACXJ,AAhHK,IAAI,CAgHJqB,KAAK,CAAC+D,WAAW,EACrBpF,CAAAA,AAjHI,IAAI,CAiHH0C,SAAS,EACV1C,AAlHA,IAAI,CAkHCqF,YAAY,EAAIrF,AAlHrB,IAAI,CAkHsBqF,YAAY,CAAC3C,SAAS,GACrD1C,AAnHK,IAAI,CAmHJrC,aAAa,CAAC2E,MAAM,CAAE,KAEvBlE,EAAOkH,EADX,IAAMf,EAAiBvE,AApHlB,IAAI,CAoHmBuE,cAAc,CAAEgB,EAAWvF,AApHlD,IAAI,CAoHmDrC,aAAa,CAACqC,AApHrE,IAAI,CAoHsErC,aAAa,CAAC2E,MAAM,CAAG,EAAE,CAAEU,EAAYhD,AApHjH,IAAI,CAoHkHrC,aAAa,CAAC,EAAE,CAE3I,KAAO,AAACS,CAAAA,EAAQ4B,AAtHX,IAAI,CAsHYwF,YAAY,CAACC,GAAG,EAAC,GAAMrH,EAAMsH,OAAO,EACrDtH,EAAMuH,IAAI,GAEd,KAAO,AAACL,CAAAA,EAAWtF,AAzHd,IAAI,CAyHe4F,WAAW,CAACH,GAAG,EAAC,GACpCH,EAASI,OAAO,EAChBJ,EAASK,IAAI,GAGjBvH,CAAAA,EAAQ4B,AA9HH,IAAI,CA8HItC,KAAK,CAACsF,EAAU,CAAC5E,KAAK,AAAD,IAE1B2E,EAAMC,EAAYuB,EAClBvE,AAjIH,IAAI,CAiIIwF,YAAY,CAAC3C,IAAI,CAACzE,EAAMyH,IAAI,IAGjCzH,EAAMuH,IAAI,IAIlBvH,CAAAA,EAAQ4B,AAxIH,IAAI,CAwIItC,KAAK,CAAC6H,EAAS,CAACnH,KAAK,AAAD,IAEzBmH,EAAW7G,EAAM6F,EACjBvE,AA3IH,IAAI,CA2IIwF,YAAY,CAAC3C,IAAI,CAACzE,EAAMyH,IAAI,IAGjCzH,EAAMuH,IAAI,IAGlB,IAAMG,EAAO9F,AAjJR,IAAI,CAiJStC,KAAK,CAAC6H,EAAS,CAACO,IAAI,CAClCA,GACAP,EAAW7G,EAAM6F,GACjBgB,EAAW7G,EAAM,GAAKsB,AApJrB,IAAI,CAoJsBtC,KAAK,CAAC6H,EAAS,CAACQ,MAAM,EACjD/F,AArJC,IAAI,CAqJA4F,WAAW,CAAC/C,IAAI,CAACiD,EAAKD,IAAI,GAEvC,CACJ,CACJ,CAIA,SAASG,IAEL,IAAMC,EAAWjG,AADJ,IAAI,CACKrC,aAAa,EAAIqC,AAD1B,IAAI,CAC2BrC,aAAa,CAACuI,IAAI,CACxDnH,EAAUiB,AAFH,IAAI,CAEIjB,OAAO,CACtBgB,EAAchB,EAAQK,IAAI,EAAI,CAAC,EAC/B+G,EAAanG,AAJN,IAAI,CAIO6B,WAAW,CAAC7C,MAAM,EAAI,CAAC,CAE3Ce,CAAAA,EAAYE,OAAO,GACfD,AAPK,IAAI,CAOJI,KAAK,EACVJ,AARK,IAAI,CAQJoG,MAAM,CAACrI,OAAO,CAAC,AAACqI,IACjBA,EAAOrH,OAAO,CAACsH,UAAU,CAAG,CAChC,GAKIJ,GACAlH,EAAQuH,oBAAoB,EAC5BvH,EAAQC,MAAM,EACd,CAAClC,EAAQqJ,EAAWpE,KAAK,GACxBhD,CAAAA,AACc,CAAA,IADdA,EAAQuH,oBAAoB,CAACL,EAASM,QAAQ,CAAC,CAC3CC,KAAK,EACNP,EAASQ,KAAK,CAAG,CAAA,IAErB1H,EAAQC,MAAM,CAAC+C,KAAK,CAAG,OAClBjF,EAAQqJ,EAAW3I,CAAC,GACrBuB,CAAAA,EAAQC,MAAM,CAACxB,CAAC,CAAG,CAAA,IAOT,aAAd,IAAI,CAACmB,IAAI,EACTqB,AAjCC,IAAI,CAiCAZ,IAAI,EACTY,AAlCC,IAAI,CAkCAZ,IAAI,CAACI,OAAO,EACjB,CAAA,IAAI,CAACkH,cAAc,CAAG,IAAI,CAACC,YAAY,AAAD,EAItD,CASA,SAASC,EAAkB9G,CAAC,MAEpB+G,EADJ,IAAM9H,EAAU,IAAI,CAACA,OAAO,CAAE8C,EAAc/B,EAAE+B,WAAW,CAAE9B,EAAe,AAAChB,GAAWxB,EAASwB,EAAQK,IAAI,EAAKL,EAAQK,IAAI,CAAG,CAAC,CAEpG,EAAA,IAAxBW,EAAYE,OAAO,GAGnB4G,EAAkB1J,EAAM,CAAA,EAAM,CAC1B2J,UAAY,wBAA2BjF,CAAAA,EAAYiF,SAAS,EAAI,EAAC,EACjER,qBAAsB,CAClBS,KAAM,CACFC,KAAM,CAAC,QAAS,KAAK,AACzB,EACAC,IAAK,CACDD,KAAM,CAAC,aAAc,aAAc,KAAK,AAC5C,EACAE,KAAM,CACFF,KAAM,CAAC,UAAW,MAAM,AAC5B,EACAG,MAAO,CACHH,KAAM,CAAC,KAAM,KAAM,KAAK,AAC5B,CACJ,EACA5H,KAAM,CACFgI,YAAa,CACjB,EACApI,OAAQ,CACJqI,QAAS,EACTlE,MAAO,CACHmE,SAAU,OACd,CACJ,EACAnG,OAAQ,EACRJ,MAAO,CACHwG,KAAM,KACNC,aAAc,CAAA,EACdrF,SAAU,EACVgB,MAAO,CACHsE,aAAc,UAClB,CACJ,EAIAC,MAAO,CAAC,CACA,cACA,CAAC,EAAG,GAAI,IAAI,CACf,CAAE,CACC,SACA,CAAC,EAAG,GAAG,CACV,CAAE,CACC,SACA,CAAC,EAAG,EAAG,GAAG,CACb,CAAE,CACC,OACA,CAAC,EAAG,EAAE,CACT,CAAE,CACC,MACA,CAAC,EAAE,CACN,CAAE,CACC,OACA,CAAC,EAAE,CACN,CAAE,CACC,QACA,CAAC,EAAE,CACN,CAAE,CACC,OACA,KACH,CAAC,AACV,EAAG7F,GAEe,UAAd,IAAI,CAACe,IAAI,GAIL9F,EAAQ+E,EAAYY,QAAQ,GAC5B,CAAC3F,EAAQ+E,EAAY8F,iBAAiB,GACtCd,CAAAA,EAAgBc,iBAAiB,CAAG,GAAE,GAM1C,CAAA,CAAC7K,EAAQ+E,EAAY8F,iBAAiB,GAElC7K,EAAQ+E,EAAYY,QAAQ,CAAA,GAC3B3F,EAAQ+E,EAAY+F,cAAc,GAClC9K,EAAQ+E,EAAY8E,YAAY,GAChC7J,EAAQ+E,EAAY6F,KAAK,GAC1Bb,CAAAA,EAAgBe,cAAc,CAAG,SAAU7E,CAAG,CAAErE,CAAG,EAC/C,IAAMmJ,EAAc,IAAI,CAACxC,YAAY,EACjC,IAAI,CAACA,YAAY,CAAC1H,aAAa,EAC/B,IAAI,CAAC0H,YAAY,CAAC1H,aAAa,CAACuI,IAAI,CACxC,GAAI2B,EAAY,CACZ,IAAMH,EAASb,EAAgBa,KAAK,EAAI,EAAE,CACtCI,EAASrB,EAAQ,EAAGF,EAAW,OACnC,IAAK,IAAIwB,EAAI,EAAGA,EAAIL,EAAMpF,MAAM,CAAEyF,IAAK,CACnC,IAAMC,EAAON,CAAK,CAACK,EAAE,CACrB,GAAIC,GAAQA,CAAI,CAAC,EAAE,GAAKH,EAAWtB,QAAQ,CAAE,CACzCuB,EAAUC,EACV,KACJ,CACJ,CAEA,IAAMC,EAAQ9K,EAAS4K,IAAYJ,CAAK,CAACI,EAAU,EAAE,CACrD,GAAIE,EAAM,CACNzB,EAAWyB,CAAI,CAAC,EAAE,EAAI,OACtB,IAAMC,EAASD,CAAI,CAAC,EAAE,CACtBvB,EAAQwB,GAAUA,CAAM,CAAC,EAAE,EAAI,CAGnC,KACiC,SAAxBJ,EAAWtB,QAAQ,EAExBE,CAAAA,EAAQoB,AAAmB,GAAnBA,EAAWpB,KAAK,AAAI,EAEhC,IAAMyB,EAAY7K,CAAS,CAACkJ,EAAS,CAErC,OADA,IAAI,CAACI,YAAY,CAAGuB,EAAYzB,EACzB,IAAI,CAACpF,KAAK,CAAC8G,IAAI,CAACC,YAAY,CAAC,CAAEF,UAAAA,EAAWzB,MAAAA,EAAOF,SAAAA,CAAS,EAAGxD,EAAKrE,EAAK,IAAI,CAACK,OAAO,CAACsJ,WAAW,CAC1G,CACJ,CAAA,GAIRlL,EAAM,CAAA,EAAM,IAAI,CAAC4B,OAAO,CAAE8H,GACtB,IAAI,CAACzG,KAAK,GAOVrB,EAAQuJ,UAAU,CAAGlL,EAAKyE,EAAYyG,UAAU,CAAE,GAClDvJ,EAAQwJ,UAAU,CAAGnL,EAAKyE,EAAY0G,UAAU,CAAE,IAIlDrL,EAAS6B,EAAQK,IAAI,CAACgI,WAAW,GACjCrI,CAAAA,EAAQyJ,SAAS,CAAGzJ,EAAQ2E,SAAS,CACjC3D,EAAYqH,WAAW,AAAD,EAGtC,CAIA,SAASqB,EAAmB3I,CAAC,EAEzB,IAAM+B,EAAc/B,EAAE+B,WAAW,CAC3B9B,EAAc8B,GAAeA,EAAYzC,IAAI,EAAI,CAAC,EAClDI,EAAUO,EAAYP,OAAO,AAG/BO,CAAAA,EAAYE,OAAO,EAAIT,GACvBrC,EAAM,CAAA,EAAM6C,AAPH,IAAI,CAOIjB,OAAO,CAAES,CAAO,CAAC,EAAE,CAE5C,CAKA,SAASkJ,IAEL,AAAC1I,CAAAA,AADY,IAAI,CACXZ,IAAI,CAACI,OAAO,EAAI,EAAE,AAAD,EAAGzB,OAAO,CAAC,AAAC4B,GAAWA,EAAOgJ,QAAQ,GACjE,CAMA,SAASC,EAAgB9I,CAAC,EACtB,GAAM,CAAEM,MAAAA,CAAK,CAAEiD,mBAAAA,CAAkB,CAAEtE,QAAS,CAAEK,KAAMW,EAAc,CAAC,CAAC,CAAE,CAAE,CAAG,IAAI,CAC/E,GAAIA,EAAYE,OAAO,EAAIoD,EAAoB,CAC3C,IAAMwF,EAAe,AAA+B,EAA/B,IAAI,CAAC9J,OAAO,CAACC,MAAM,CAAC+E,QAAQ,CAC3CA,EAAW3D,EACZL,EAAY+I,UAAU,EACnBD,EAAexF,EAAmBvF,MAAM,CAC5C+K,EAAexF,EAAmBxF,KAAK,CACvCZ,EAAQ6C,EAAEc,QAAQ,EAClBd,EAAEc,QAAQ,CAAC,EAAE,CAAGmD,EAGhBjE,EAAEc,QAAQ,CAAG,CAACmD,EAAU,EAAE,AAElC,CACJ,CAIA,SAASgF,IACL,IAAI,CAACpG,IAAI,CAAC5E,OAAO,CAAC,AAACiC,IACf,AAACA,CAAAA,EAAKZ,IAAI,EAAIY,EAAKZ,IAAI,CAACI,OAAO,EAAI,EAAE,AAAD,EAAGzB,OAAO,CAAC,AAAC4B,IAC5CA,EAAOqJ,WAAW,GAClBrJ,EAAOsJ,kBAAkB,EAC7B,EACJ,EACJ,CAIA,SAASC,EAAUpJ,CAAC,EAChB,GAAM,CAAEV,KAAAA,CAAI,CAAE,CAAG,IAAI,CACrB,AAACA,CAAAA,EAAKI,OAAO,EAAI,EAAE,AAAD,EAAGzB,OAAO,CAAC,AAAC4B,GAAWA,EAAO4D,OAAO,CAACzD,EAAEqJ,UAAU,GACpE/J,EAAKI,OAAO,CAAG,KAAK,CACxB,CAKA,SAAS4J,EAAOtJ,CAAC,EAEb,IAAM+B,EAAc/B,EAAE+B,WAAW,EAAI,CAAC,EAChC9B,EAAc8B,EAAYzC,IAAI,EAAI,CAAC,CACrCW,CAAAA,EAAYE,OAAO,EAAInD,EAAQiD,EAAYsJ,WAAW,GACtDxH,CAAAA,EAAYyH,SAAS,CAAGzH,EAAYgD,SAAS,CAAI9E,EAAYsJ,WAAW,EAEvErJ,AANQ,IAAI,CAMPZ,IAAI,EACVY,CAAAA,AAPS,IAAI,CAORZ,IAAI,CAAG,IAAImK,EAPP,IAAI,CAOyB,EAE1CvJ,AATa,IAAI,CASZwF,YAAY,CAAG,EAAE,CACtBxF,AAVa,IAAI,CAUZ4F,WAAW,CAAG,EAAE,AACzB,CAKA,SAAS4D,EAA4B1J,CAAC,EAClC,IAAmB1B,EAAQH,AAAd,IAAI,CAAeG,KAAK,CAAE4B,EAAO/B,AAAjC,IAAI,CAAkC+B,IAAI,CAAEyJ,EAAWzJ,EAAKyJ,QAAQ,CAAEpI,EAAQrB,EAAKqB,KAAK,CAA0BtB,EAAchB,AAA5BiB,EAAKjB,OAAO,CAAwBK,IAAI,EAAI,CAAC,EAAGsK,EAAY1J,EAAKjB,OAAO,CAACC,MAAM,CAAE+C,EAAQ2H,EAAU3H,KAAK,CAGzNzC,EAAO3C,CAAY,CAACqD,EAAKV,IAAI,CAAC,CAAEiF,EAAiBzE,EAAEyE,cAAc,CAAE5G,EAAgBqC,EAAKrC,aAAa,CAAEgM,EAAU1L,AAHpG,IAAI,CAGqGD,GAAG,CAAGuG,EAAgBqF,EAAe1M,EAASS,CAAa,CAACmC,EAAE+J,KAAK,CAAG,EAAE,EAC1LlM,CAAa,CAACmC,EAAE+J,KAAK,CAAG,EAAE,CAAGtF,EAC7B,AAACvE,CAAAA,EAAKtB,GAAG,EAAI,CAAA,EAAK6F,EAAiB3D,EAAWZ,EAAKY,QAAQ,CAAC,QAAS4H,EAAY5H,EAAWA,CAAQ,CAAC,EAAE,CAAG,EAAGkJ,EAAYlJ,EAAWA,CAAQ,CAAC,EAAE,CAAG,EAAI,EAE1J,GAAIb,AAAwB,CAAA,IAAxBA,EAAYE,OAAO,CAAW,CAC9B,IAAIyB,EAAQjB,EAAKJ,EAAM0J,EA2CvB,GAzCIzK,AAAS,QAATA,EAEAmB,EAAMiB,AADNA,CAAAA,EAAS1B,EAAKS,GAAG,CAAGT,EAAKO,MAAM,AAAD,EACfiI,EAEVlJ,AAAS,WAATA,EAELoC,EAASjB,AADTA,CAAAA,EAAMY,EAAM2I,WAAW,CAAGhK,EAAK0B,MAAM,CAAG1B,EAAKO,MAAM,AAAD,EACnCiI,GAGf9G,EAAS1B,EAAKS,GAAG,CAAGT,EAAKiK,GAAG,CAAIjK,CAAAA,EAAKkK,SAAS,CAACT,EAAWG,EAAcD,IAAY,CAAA,EACpFlJ,EAAMT,EAAKS,GAAG,CAAGT,EAAKiK,GAAG,CAAIjK,CAAAA,EAAKkK,SAAS,CAACT,EAAWE,EAAUC,IAAgB,CAAA,GAGjFtK,AAAS,UAATA,EAEAyK,EAAQ1J,AADRA,CAAAA,EAAOgB,EAAMgD,UAAU,CAAGrE,EAAK+J,KAAK,CAAG/J,EAAKO,MAAM,AAAD,EAClCiI,EAEVlJ,AAAS,SAATA,EAELe,EAAO0J,AADPA,CAAAA,EAAQ/J,EAAKK,IAAI,CAAGL,EAAKO,MAAM,AAAD,EACfiI,GAGfnI,EAAO7B,KAAKC,KAAK,CAACuB,EAAKK,IAAI,CAAIL,CAAAA,EAAKkK,SAAS,CAACT,EAAWG,EAAcD,IAAY,CAAA,GAAMG,EACzFC,EAAQvL,KAAKuE,GAAG,CAChBvE,KAAKC,KAAK,CAACuB,EAAKK,IAAI,CAAIL,CAAAA,EAAKkK,SAAS,CAACT,EAAWE,EAAUC,IAAgB,CAAA,GAAME,EAAW9J,EAAKK,IAAI,CAAGL,EAAKiK,GAAG,GAErHhM,AApCS,IAAI,CAoCRiF,SAAS,CAAG6G,EAAQ1J,EAGzBP,EAAE9B,GAAG,CAACR,CAAC,CAAIuE,AAAU,SAAVA,EACP1B,EACA0B,AAAU,UAAVA,EACIgI,EACA1J,EAAQ,AAAC0J,CAAAA,EAAQ1J,CAAG,EAAK,EAEjCP,EAAE9B,GAAG,CAACiD,CAAC,CAICR,EAAO,AAACiB,CAAAA,EAASjB,CAAE,EAAK,EAE5BrC,EAAO,CACP,IAAM+L,EAAa9I,EAAMC,QAAQ,CAACC,WAAW,CAACnD,GAAQF,EAAcE,EAAMC,OAAO,GAAGP,MAAM,CAG1F,GAAK4L,EAAUU,OAAO,CAUlBtK,EAAE9B,GAAG,CAACiD,CAAC,EAEPkJ,EAAWE,CAAC,CAER,CAAEnM,CAAAA,EAAc,CAAA,MAdA,CACpB,IAAMoM,EAAQ9L,KAAKC,KAAK,CAACP,EAAciM,EAAWI,CAAC,CACnDzK,CAAAA,EAAE9B,GAAG,CAACiD,CAAC,EAGP,AAAEkJ,CAAAA,EAAWE,CAAC,CAAIF,CAAAA,EAAWI,CAAC,CAAGJ,EAAW3I,CAAC,AAADA,CAAC,EAAK,EAE9C,CAAE,CAAA,AAAE8I,CAAAA,EAAQ,CAAA,EAAKH,EAAWI,CAAC,CAAI,CAAA,CACzC,CAQJ,CACAzK,EAAE9B,GAAG,CAACR,CAAC,EAAI,AAACwC,EAAKI,KAAK,EAAIsJ,EAAUlM,CAAC,EAAK,CAC9C,CACJ,CAIA,SAASgN,EAAkBC,CAAG,EAC1B,GAAM,CAAEzK,KAAAA,CAAI,CAAE0K,MAAAA,CAAK,CAAE,CAAGD,EACxB,GAAIzK,EAAKjB,OAAO,CAACK,IAAI,EACjBY,EAAKjB,OAAO,CAACK,IAAI,CAACa,OAAO,CAAE,KAQvB0K,EAPJ,IAAMhB,EAAU3J,EAAKrC,aAAa,CAC5ByI,EAAS,AAACpG,CAAAA,EAAKqF,YAAY,EAAIrF,CAAG,EAAGoG,MAAM,CAAC,EAAE,CAC9CwE,EAAUF,IAAUf,CAAO,CAAC,EAAE,CAC9B5D,EAAS2E,IAAUf,CAAO,CAACA,EAAQrH,MAAM,CAAG,EAAE,CAC9CuI,EAAQzE,GAAUpJ,EAAKoJ,EAAOrH,OAAO,CAAC+L,IAAI,CAAE,SAAUC,CAAC,EACzD,OAAOA,CAAC,CAAC/K,EAAKgL,OAAO,CAAG,IAAM,IAAI,GAAKN,CAC3C,GAEIG,GAASzE,EAAO6E,EAAE,CAAC,WAGnBN,EAAYxN,EAAM0N,GAClBpO,EAAEyO,WAAW,CAACC,KAAK,CAACC,SAAS,CAACC,UAAU,CACnCC,oBAAoB,CAACX,IAI9BF,EAAIG,OAAO,CAAGA,EACdH,EAAI1E,MAAM,CAAGA,EACb0E,EAAII,KAAK,CAAGF,CAChB,CACJ,CAoBA,SAASY,IACL,IAAmBxM,EAAUiB,AAAhB,IAAI,CAAiBjB,OAAO,CAAEgB,EAAchB,EAAQK,IAAI,EAAI,CAAC,EAAGoM,EAAexL,AAA/E,IAAI,CAAgFgC,UAAU,CAAErE,EAAgBqC,AAAhH,IAAI,CAAiHrC,aAAa,CAAE8N,EAAW9N,CAAa,CAAC,EAAE,CAAE+N,EAAY/N,CAAa,CAAC,EAAE,CAAEgO,EAAUhO,CAAa,CAACA,EAAc2E,MAAM,CAAG,EAAE,CAAEsJ,EAAgBjO,CAAa,CAACA,EAAc2E,MAAM,CAAG,EAAE,CAAEuJ,EAAY7L,AAAvT,IAAI,CAAwTqF,YAAY,EAAIrF,AAA5U,IAAI,CAA6UqF,YAAY,CAACtC,GAAG,CAAE+I,EAAY9L,AAA/W,IAAI,CAAgXqF,YAAY,EAAIrF,AAApY,IAAI,CAAqYqF,YAAY,CAAC3G,GAAG,CAAEqE,EAAM8I,GAAa7L,AAA9a,IAAI,CAA+a+C,GAAG,CAAErE,EAAMoN,GAAa9L,AAA3c,IAAI,CAA4ctB,GAAG,CAAEiI,EAAe3G,AAApe,IAAI,CAAqe2G,YAAY,CAAEoF,EACpgB7O,EAAS6F,IACLA,GAAO0I,EAAW9E,GAClB5D,EAAM2I,EAAYM,EAAkB9O,EAAS6F,IAC7C0I,EAAW1I,GACX0I,EAAW9E,EAAe5D,EAAMkJ,EAAoB/O,EAASwB,IAC7DiN,EAAUjN,GACViN,EAAUhF,EAAejI,EAAMwN,EAAkBhP,EAASwB,IAC1DA,GAAOiN,EAAUhF,GACjBjI,EAAMkN,CACkB,EAAA,IAAxB7L,EAAYE,OAAO,EACnB,CAACuL,GACAxL,CAAAA,AAZQ,IAAI,CAYPgL,OAAO,EAAIhL,AAZR,IAAI,CAYSmM,QAAQ,AAAD,IACxBH,CAAAA,GAAkBD,CAAe,GAAM,CAAChN,EAAQqN,WAAW,EAC5DzO,CAAAA,CAAa,CAAC,EAAE,CAAGoF,CAAE,EAEpBkJ,CAAAA,GAAoBC,CAAa,GAAM,CAACnN,EAAQsN,SAAS,EAC1D1O,CAAAA,CAAa,CAACA,EAAc2E,MAAM,CAAG,EAAE,CAAG5D,CAAE,EAGxD,CAKA,SAAS4N,EAAanN,CAAO,MAlzBRnD,EAozBjB,GAAM,CAAE+C,QAAS,CAAEK,KAAMW,EAAc,CAAC,CAAC,CAAE,CAAE,CADhC,IAAI,OAEjB,AAAIA,AAAwB,CAAA,IAAxBA,EAAYE,OAAO,EAAaD,AAFvB,IAAI,CAEwBgC,UAAU,CACxChC,AAHE,IAAI,CAGD2G,YAAY,CAErBxH,EAAQhD,KAAK,CALP,IAAI,EAnzBAH,EAwzBsBuQ,UAvzBhCC,MAAMpB,SAAS,CAAC3L,KAAK,CAACgN,IAAI,CAACzQ,EAAM,IAwzB5C,CAt0BIW,CADOA,EAKRA,GAAiBA,CAAAA,EAAe,CAAC,CAAA,EAJpB,CAACA,EAAa,GAAM,CAAG,EAAE,CAAG,MACxCA,CAAY,CAACA,EAAa,KAAQ,CAAG,EAAE,CAAG,QAC1CA,CAAY,CAACA,EAAa,MAAS,CAAG,EAAE,CAAG,SAC3CA,CAAY,CAACA,EAAa,IAAO,CAAG,EAAE,CAAG,MA80B7C,OAAM4M,EAMFmD,YAAY1M,CAAI,CAAE,CACd,IAAI,CAACA,IAAI,CAAGA,CAChB,CAqBAwD,aAAc,CACV,IAAMxD,EAAO,IAAI,CAACA,IAAI,CAChBqB,EAAQrB,EAAKqB,KAAK,CAClBgB,EAAcrC,EAAKZ,IAAI,CAACiD,WAAW,CACnC7C,EAAWQ,EAAKqF,YAAY,EAAEjG,KAAKI,SACrCQ,EAAKZ,IAAI,CAACI,OAAO,EACjB,EAAE,CACAmN,EAAatK,EAAcrC,EAAKqF,YAAY,CAAGrF,EACjD4M,EAAY,GAAIC,EAAY,SAGhC,AAAI7M,AAAc,IAAdA,EAAKV,IAAI,EAAU,CAAC+B,EAAMyL,QAAQ,EAAItN,EAAQ8C,MAAM,CAC7C,CAACtC,EAAKqF,YAAY,EAE7B,AAAChE,CAAAA,CAAK,CAACrB,EAAK4C,IAAI,CAAC,EAAI,EAAE,AAAD,EAAG7E,OAAO,CAAC,CAACgP,EAAWlD,KACrCkD,EAAUzN,IAAI,GAAKU,EAAKV,IAAI,EAC3ByN,EAAUhO,OAAO,CAACyD,UAAU,GAC7BqK,EAAYhD,EACRkD,IAAcJ,GAEdC,CAAAA,EAAY/C,CAAI,EAG5B,GACQgD,IAAcD,GACjB1P,CAAAA,CAAAA,EAASmF,IACN7C,EAAQ8C,MAAM,GAAKD,CAChB,EACf,CASAqC,aAAa3I,CAAI,CAAE,CACf,IAAMiE,EAAO,IAAI,CAACA,IAAI,CAAEsB,EAAWtB,EAAKqB,KAAK,CAACC,QAAQ,CAAEvC,EAAUiB,EAAKjB,OAAO,CAAEiO,EAAkB1L,EAASvF,IAAI,CAACA,GAC3GkR,QAAQ,CAAC,wBACTC,GAAG,CAAClN,EAAKmN,SAAS,EAQvB,OAPK7L,EAAS2B,UAAU,EACpB+J,EAAgBrI,IAAI,CAAC,CACjBC,OAAQ7F,EAAQ8F,SAAS,CACzB,eAAgB9F,EAAQ2E,SAAS,CACjC0J,OAAQ,CACZ,GAEGJ,CACX,CACJ,QAOApQ,EAAYyQ,CAAC,CAAG,SAAUC,CAAS,EAC/B,OAAO,IAAI,CAACC,UAAU,CAAC,KAAMD,EAAW,CAAA,GAAME,MAAM,CAAC,EACzD,EAEA5Q,EAAY6Q,CAAC,CAAG,SAAUH,CAAS,EAC/B,IAAMnF,EAAO,IAAI,CAAEpD,EAAI,IAAI,IAAI,CAAC2I,IAAI,CAACJ,GACrCK,AAD+D,CAAC,QAAS,eAAgB,UAAW,UAAU,CAClG5P,OAAO,CAAC,SAAU6P,CAAM,EAChCzF,EAAK0F,GAAG,CAACD,EAAQ7I,EAAG,EACxB,GACA,IAAM+I,EAAW,AAAC,CAAA,IAAI,CAACC,GAAG,CAAC,MAAOhJ,GAAK,CAAA,EAAK,EACtCiJ,EAAW,IAAI,IAAI,CAACN,IAAI,CAAC3I,EAAEkJ,OAAO,IACxC,IAAI,CAACJ,GAAG,CAAC,OAAQG,EAAU,IAAI,CAACD,GAAG,CAAC,OAAQhJ,GAAK+I,EAAW,GAC5D,IAAMI,EAAgB,IAAI,IAAI,CAACR,IAAI,CAAC,IAAI,CAACK,GAAG,CAAC,WAAYC,GAAW,EAAG,GAKvE,OAJuC,IAAnC,IAAI,CAACD,GAAG,CAAC,MAAOG,KAChB,IAAI,CAACL,GAAG,CAAC,QAAS9I,EAAG,GACrB,IAAI,CAAC8I,GAAG,CAAC,OAAQ9I,EAAG,EAAI,AAAC,CAAA,GAAK,IAAI,CAACgJ,GAAG,CAAC,MAAOG,EAAa,EAAK,IAE7D,AAAC,CAAA,EACJ1P,KAAK2P,KAAK,CAAC,AAACH,CAAAA,EAASC,OAAO,GAAKC,EAAcD,OAAO,EAAC,EAAK,OAAS,EAAGG,QAAQ,EACxF,EAMiB,CACbC,QA14BJ,SAAiBC,CAAS,CAAEC,CAAU,CAAEC,CAAS,EAsB7C,OArBKF,EAAUG,SAAS,CAACC,QAAQ,CAAC,UAC9BJ,EAAUG,SAAS,CAAC5L,IAAI,CAAC,QACzByL,EAAUlD,SAAS,CAAC3N,qBAAqB,CAAGA,EAC5CH,EAAKgR,EAAUlD,SAAS,CAAE,WAAYkB,GACtChP,EAAKgR,EAAUlD,SAAS,CAAE,YAAalM,GAEvCrC,EAASyR,EAAW,OAAQlF,GAC5BvM,EAASyR,EAAW,wBAAyBzO,GAC7ChD,EAASyR,EAAW,YAAa1M,GACjC/E,EAASyR,EAAW,cAAexL,GACnCjG,EAASyR,EAAW,0BAA2BtI,GAC/CnJ,EAASyR,EAAW,kBAAmB1H,GACvC/J,EAASyR,EAAW,kBAAmB7F,GACvC5L,EAASyR,EAAW,gBAAiB5F,GACrC7L,EAASyR,EAAW,gBAAiB1F,GACrC/L,EAASyR,EAAW,YAAa/C,GACjC1O,EAASyR,EAAW,UAAWpF,GAC/BrM,EAAS0R,EAAY,oBAAqBxF,GAC1ClM,EAAS2R,EAAW,wBAAyBhF,GAC7C3M,EAAS2R,EAAW,cAAehE,IAEhC8D,CACX,CAo3BA,CAmFJ,GACAzS,EAAgBD,EAAU,mCAAoC,CAACA,CAAQ,CAAC,kBAAkB,CAAEA,CAAQ,CAAC,wBAAwB,CAAC,CAAE,SAAUF,CAAU,CAAEiT,CAAQ,EAM1J,OAFAA,EAASN,OAAO,CAACO,AAFPlT,EAESc,IAAI,CAAEoS,AAFflT,EAEiBmT,KAAK,CAAED,AAFxBlT,EAE0BoT,IAAI,EAEjCpT,CACX,EACJ"}
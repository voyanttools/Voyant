{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts Gantt JS v11.4.8 (2024-08-29)\n *\n * Pathfinder\n *\n * (c) 2016-2024 Øystein Moseng\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/pathfinder', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                Highcharts.win.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Gantt/Connection.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Authors: Øystein Moseng, Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { defined, error, merge, objectEach } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const deg2rad = H.deg2rad, max = Math.max, min = Math.min;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The Connection class. Used internally to represent a connection between two\n         * points.\n         *\n         * @private\n         * @class\n         * @name Highcharts.Connection\n         *\n         * @param {Highcharts.Point} from\n         *        Connection runs from this Point.\n         *\n         * @param {Highcharts.Point} to\n         *        Connection runs to this Point.\n         *\n         * @param {Highcharts.ConnectorsOptions} [options]\n         *        Connection options.\n         */\n        class Connection {\n            constructor(from, to, options) {\n                this.init(from, to, options);\n            }\n            /**\n             * Initialize the Connection object. Used as constructor only.\n             *\n             * @function Highcharts.Connection#init\n             *\n             * @param {Highcharts.Point} from\n             *        Connection runs from this Point.\n             *\n             * @param {Highcharts.Point} to\n             *        Connection runs to this Point.\n             *\n             * @param {Highcharts.ConnectorsOptions} [options]\n             *        Connection options.\n             */\n            init(from, to, options) {\n                this.fromPoint = from;\n                this.toPoint = to;\n                this.options = options;\n                this.chart = from.series.chart;\n                this.pathfinder = this.chart.pathfinder;\n            }\n            /**\n             * Add (or update) this connection's path on chart. Stores reference to the\n             * created element on this.graphics.path.\n             *\n             * @function Highcharts.Connection#renderPath\n             *\n             * @param {Highcharts.SVGPathArray} path\n             *        Path to render, in array format. E.g. ['M', 0, 0, 'L', 10, 10]\n             *\n             * @param {Highcharts.SVGAttributes} [attribs]\n             *        SVG attributes for the path.\n             *\n             * @param {Partial<Highcharts.AnimationOptionsObject>} [animation]\n             *        Animation options for the rendering.\n             */\n            renderPath(path, attribs) {\n                const connection = this, chart = this.chart, styledMode = chart.styledMode, pathfinder = this.pathfinder, anim = {};\n                let pathGraphic = connection.graphics && connection.graphics.path;\n                // Add the SVG element of the pathfinder group if it doesn't exist\n                if (!pathfinder.group) {\n                    pathfinder.group = chart.renderer.g()\n                        .addClass('highcharts-pathfinder-group')\n                        .attr({ zIndex: -1 })\n                        .add(chart.seriesGroup);\n                }\n                // Shift the group to compensate for plot area.\n                // Note: Do this always (even when redrawing a path) to avoid issues\n                // when updating chart in a way that changes plot metrics.\n                pathfinder.group.translate(chart.plotLeft, chart.plotTop);\n                // Create path if does not exist\n                if (!(pathGraphic && pathGraphic.renderer)) {\n                    pathGraphic = chart.renderer.path()\n                        .add(pathfinder.group);\n                    if (!styledMode) {\n                        pathGraphic.attr({\n                            opacity: 0\n                        });\n                    }\n                }\n                // Set path attribs and animate to the new path\n                pathGraphic.attr(attribs);\n                anim.d = path;\n                if (!styledMode) {\n                    anim.opacity = 1;\n                }\n                pathGraphic.animate(anim);\n                // Store reference on connection\n                this.graphics = this.graphics || {};\n                this.graphics.path = pathGraphic;\n            }\n            /**\n             * Calculate and add marker graphics for connection to the chart. The\n             * created/updated elements are stored on this.graphics.start and\n             * this.graphics.end.\n             *\n             * @function Highcharts.Connection#addMarker\n             *\n             * @param {string} type\n             *        Marker type, either 'start' or 'end'.\n             *\n             * @param {Highcharts.ConnectorsMarkerOptions} options\n             *        All options for this marker. Not calculated or merged with other\n             *        options.\n             *\n             * @param {Highcharts.SVGPathArray} path\n             *        Connection path in array format. This is used to calculate the\n             *        rotation angle of the markers.\n             */\n            addMarker(type, options, path) {\n                const connection = this, chart = connection.fromPoint.series.chart, pathfinder = chart.pathfinder, renderer = chart.renderer, point = (type === 'start' ?\n                    connection.fromPoint :\n                    connection.toPoint), anchor = point.getPathfinderAnchorPoint(options);\n                let markerVector, radians, rotation, box, width, height, pathVector, segment;\n                if (!options.enabled) {\n                    return;\n                }\n                // Last vector before start/end of path, used to get angle\n                if (type === 'start') {\n                    segment = path[1];\n                }\n                else { // 'end'\n                    segment = path[path.length - 2];\n                }\n                if (segment && segment[0] === 'M' || segment[0] === 'L') {\n                    pathVector = {\n                        x: segment[1],\n                        y: segment[2]\n                    };\n                    // Get angle between pathVector and anchor point and use it to\n                    // create marker position.\n                    radians = point.getRadiansToVector(pathVector, anchor);\n                    markerVector = point.getMarkerVector(radians, options.radius, anchor);\n                    // Rotation of marker is calculated from angle between pathVector\n                    // and markerVector.\n                    // (Note:\n                    //  Used to recalculate radians between markerVector and pathVector,\n                    //  but this should be the same as between pathVector and anchor.)\n                    rotation = -radians / deg2rad;\n                    if (options.width && options.height) {\n                        width = options.width;\n                        height = options.height;\n                    }\n                    else {\n                        width = height = options.radius * 2;\n                    }\n                    // Add graphics object if it does not exist\n                    connection.graphics = connection.graphics || {};\n                    box = {\n                        x: markerVector.x - (width / 2),\n                        y: markerVector.y - (height / 2),\n                        width: width,\n                        height: height,\n                        rotation: rotation,\n                        rotationOriginX: markerVector.x,\n                        rotationOriginY: markerVector.y\n                    };\n                    if (!connection.graphics[type]) {\n                        // Create new marker element\n                        connection.graphics[type] = renderer\n                            .symbol(options.symbol)\n                            .addClass('highcharts-point-connecting-path-' + type + '-marker' +\n                            ' highcharts-color-' + this.fromPoint.colorIndex)\n                            .attr(box)\n                            .add(pathfinder.group);\n                        if (!renderer.styledMode) {\n                            connection.graphics[type].attr({\n                                fill: options.color || connection.fromPoint.color,\n                                stroke: options.lineColor,\n                                'stroke-width': options.lineWidth,\n                                opacity: 0\n                            })\n                                .animate({\n                                opacity: 1\n                            }, point.series.options.animation);\n                        }\n                    }\n                    else {\n                        connection.graphics[type].animate(box);\n                    }\n                }\n            }\n            /**\n             * Calculate and return connection path.\n             * Note: Recalculates chart obstacles on demand if they aren't calculated.\n             *\n             * @function Highcharts.Connection#getPath\n             *\n             * @param {Highcharts.ConnectorsOptions} options\n             *        Connector options. Not calculated or merged with other options.\n             *\n             * @return {object|undefined}\n             *         Calculated SVG path data in array format.\n             */\n            getPath(options) {\n                const pathfinder = this.pathfinder, chart = this.chart, algorithm = pathfinder.algorithms[options.type];\n                let chartObstacles = pathfinder.chartObstacles;\n                if (typeof algorithm !== 'function') {\n                    error('\"' + options.type + '\" is not a Pathfinder algorithm.');\n                    return {\n                        path: [],\n                        obstacles: []\n                    };\n                }\n                // This function calculates obstacles on demand if they don't exist\n                if (algorithm.requiresObstacles && !chartObstacles) {\n                    chartObstacles =\n                        pathfinder.chartObstacles =\n                            pathfinder.getChartObstacles(options);\n                    // If the algorithmMargin was computed, store the result in default\n                    // options.\n                    chart.options.connectors.algorithmMargin =\n                        options.algorithmMargin;\n                    // Cache some metrics too\n                    pathfinder.chartObstacleMetrics =\n                        pathfinder.getObstacleMetrics(chartObstacles);\n                }\n                // Get the SVG path\n                return algorithm(\n                // From\n                this.fromPoint.getPathfinderAnchorPoint(options.startMarker), \n                // To\n                this.toPoint.getPathfinderAnchorPoint(options.endMarker), merge({\n                    chartObstacles: chartObstacles,\n                    lineObstacles: pathfinder.lineObstacles || [],\n                    obstacleMetrics: pathfinder.chartObstacleMetrics,\n                    hardBounds: {\n                        xMin: 0,\n                        xMax: chart.plotWidth,\n                        yMin: 0,\n                        yMax: chart.plotHeight\n                    },\n                    obstacleOptions: {\n                        margin: options.algorithmMargin\n                    },\n                    startDirectionX: pathfinder.getAlgorithmStartDirection(options.startMarker)\n                }, options));\n            }\n            /**\n             * (re)Calculate and (re)draw the connection.\n             *\n             * @function Highcharts.Connection#render\n             */\n            render() {\n                const connection = this, fromPoint = connection.fromPoint, series = fromPoint.series, chart = series.chart, pathfinder = chart.pathfinder, attribs = {};\n                let options = merge(chart.options.connectors, series.options.connectors, fromPoint.options.connectors, connection.options);\n                // Set path attribs\n                if (!chart.styledMode) {\n                    attribs.stroke = options.lineColor || fromPoint.color;\n                    attribs['stroke-width'] = options.lineWidth;\n                    if (options.dashStyle) {\n                        attribs.dashstyle = options.dashStyle;\n                    }\n                }\n                attribs['class'] = // eslint-disable-line dot-notation\n                    'highcharts-point-connecting-path ' +\n                        'highcharts-color-' + fromPoint.colorIndex;\n                options = merge(attribs, options);\n                // Set common marker options\n                if (!defined(options.marker.radius)) {\n                    options.marker.radius = min(max(Math.ceil((options.algorithmMargin || 8) / 2) - 1, 1), 5);\n                }\n                // Get the path\n                const pathResult = connection.getPath(options), path = pathResult.path;\n                // Always update obstacle storage with obstacles from this path.\n                // We don't know if future calls will need this for their algorithm.\n                if (pathResult.obstacles) {\n                    pathfinder.lineObstacles =\n                        pathfinder.lineObstacles || [];\n                    pathfinder.lineObstacles =\n                        pathfinder.lineObstacles.concat(pathResult.obstacles);\n                }\n                // Add the calculated path to the pathfinder group\n                connection.renderPath(path, attribs);\n                // Render the markers\n                connection.addMarker('start', merge(options.marker, options.startMarker), path);\n                connection.addMarker('end', merge(options.marker, options.endMarker), path);\n            }\n            /**\n             * Destroy connection by destroying the added graphics elements.\n             *\n             * @function Highcharts.Connection#destroy\n             */\n            destroy() {\n                if (this.graphics) {\n                    objectEach(this.graphics, function (val) {\n                        val.destroy();\n                    });\n                    delete this.graphics;\n                }\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Declarations\n         *\n         * */\n        /**\n         * The default pathfinder algorithm to use for a chart. It is possible to define\n         * your own algorithms by adding them to the\n         * `Highcharts.Pathfinder.prototype.algorithms`\n         * object before the chart has been created.\n         *\n         * The default algorithms are as follows:\n         *\n         * `straight`:      Draws a straight line between the connecting\n         *                  points. Does not avoid other points when drawing.\n         *\n         * `simpleConnect`: Finds a path between the points using right angles\n         *                  only. Takes only starting/ending points into\n         *                  account, and will not avoid other points.\n         *\n         * `fastAvoid`:     Finds a path between the points using right angles\n         *                  only. Will attempt to avoid other points, but its\n         *                  focus is performance over accuracy. Works well with\n         *                  less dense datasets.\n         *\n         * @typedef {\"fastAvoid\"|\"simpleConnect\"|\"straight\"|string} Highcharts.PathfinderTypeValue\n         */\n        ''; // Keeps doclets above in JS file\n\n        return Connection;\n    });\n    _registerModule(_modules, 'Series/PathUtilities.js', [], function () {\n        /* *\n         *\n         *  (c) 2010-2024 Pawel Lysy\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const getLinkPath = {\n            'default': getDefaultPath,\n            straight: getStraightPath,\n            curved: getCurvedPath\n        };\n        /**\n         *\n         */\n        function getDefaultPath(pathParams) {\n            const { x1, y1, x2, y2, width = 0, inverted = false, radius, parentVisible } = pathParams;\n            const path = [\n                ['M', x1, y1],\n                ['L', x1, y1],\n                ['C', x1, y1, x1, y2, x1, y2],\n                ['L', x1, y2],\n                ['C', x1, y1, x1, y2, x1, y2],\n                ['L', x1, y2]\n            ];\n            return parentVisible ?\n                applyRadius([\n                    ['M', x1, y1],\n                    ['L', x1 + width * (inverted ? -0.5 : 0.5), y1],\n                    ['L', x1 + width * (inverted ? -0.5 : 0.5), y2],\n                    ['L', x2, y2]\n                ], radius) :\n                path;\n        }\n        /**\n         *\n         */\n        function getStraightPath(pathParams) {\n            const { x1, y1, x2, y2, width = 0, inverted = false, parentVisible } = pathParams;\n            return parentVisible ? [\n                ['M', x1, y1],\n                ['L', x1 + width * (inverted ? -1 : 1), y2],\n                ['L', x2, y2]\n            ] : [\n                ['M', x1, y1],\n                ['L', x1, y2],\n                ['L', x1, y2]\n            ];\n        }\n        /**\n         *\n         */\n        function getCurvedPath(pathParams) {\n            const { x1, y1, x2, y2, offset = 0, width = 0, inverted = false, parentVisible } = pathParams;\n            return parentVisible ?\n                [\n                    ['M', x1, y1],\n                    [\n                        'C',\n                        x1 + offset,\n                        y1,\n                        x1 - offset + width * (inverted ? -1 : 1),\n                        y2,\n                        x1 + width * (inverted ? -1 : 1),\n                        y2\n                    ],\n                    ['L', x2, y2]\n                ] :\n                [\n                    ['M', x1, y1],\n                    ['C', x1, y1, x1, y2, x1, y2],\n                    ['L', x2, y2]\n                ];\n        }\n        /**\n         * General function to apply corner radius to a path\n         * @private\n         */\n        function applyRadius(path, r) {\n            const d = [];\n            for (let i = 0; i < path.length; i++) {\n                const x = path[i][1];\n                const y = path[i][2];\n                if (typeof x === 'number' && typeof y === 'number') {\n                    // MoveTo\n                    if (i === 0) {\n                        d.push(['M', x, y]);\n                    }\n                    else if (i === path.length - 1) {\n                        d.push(['L', x, y]);\n                        // CurveTo\n                    }\n                    else if (r) {\n                        const prevSeg = path[i - 1];\n                        const nextSeg = path[i + 1];\n                        if (prevSeg && nextSeg) {\n                            const x1 = prevSeg[1], y1 = prevSeg[2], x2 = nextSeg[1], y2 = nextSeg[2];\n                            // Only apply to breaks\n                            if (typeof x1 === 'number' &&\n                                typeof x2 === 'number' &&\n                                typeof y1 === 'number' &&\n                                typeof y2 === 'number' &&\n                                x1 !== x2 &&\n                                y1 !== y2) {\n                                const directionX = x1 < x2 ? 1 : -1, directionY = y1 < y2 ? 1 : -1;\n                                d.push([\n                                    'L',\n                                    x - directionX * Math.min(Math.abs(x - x1), r),\n                                    y - directionY * Math.min(Math.abs(y - y1), r)\n                                ], [\n                                    'C',\n                                    x,\n                                    y,\n                                    x,\n                                    y,\n                                    x + directionX * Math.min(Math.abs(x - x2), r),\n                                    y + directionY * Math.min(Math.abs(y - y2), r)\n                                ]);\n                            }\n                        }\n                        // LineTo\n                    }\n                    else {\n                        d.push(['L', x, y]);\n                    }\n                }\n            }\n            return d;\n        }\n        const PathUtilities = {\n            applyRadius,\n            getLinkPath\n        };\n\n        return PathUtilities;\n    });\n    _registerModule(_modules, 'Gantt/PathfinderAlgorithms.js', [_modules['Series/PathUtilities.js'], _modules['Core/Utilities.js']], function (PathUtilities, U) {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Author: Øystein Moseng\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { pick } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const { min, max, abs } = Math;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Get index of last obstacle before xMin. Employs a type of binary search, and\n         * thus requires that obstacles are sorted by xMin value.\n         *\n         * @private\n         * @function findLastObstacleBefore\n         *\n         * @param {Array<object>} obstacles\n         *        Array of obstacles to search in.\n         *\n         * @param {number} xMin\n         *        The xMin threshold.\n         *\n         * @param {number} [startIx]\n         *        Starting index to search from. Must be within array range.\n         *\n         * @return {number}\n         *         The index of the last obstacle element before xMin.\n         */\n        function findLastObstacleBefore(obstacles, xMin, startIx) {\n            const min = xMin - 0.0000001; // Make sure we include all obstacles at xMin\n            let left = startIx || 0, // Left limit\n            right = obstacles.length - 1, // Right limit\n            cursor, cmp;\n            while (left <= right) {\n                cursor = (right + left) >> 1;\n                cmp = min - obstacles[cursor].xMin;\n                if (cmp > 0) {\n                    left = cursor + 1;\n                }\n                else if (cmp < 0) {\n                    right = cursor - 1;\n                }\n                else {\n                    return cursor;\n                }\n            }\n            return left > 0 ? left - 1 : 0;\n        }\n        /**\n         * Test if a point lays within an obstacle.\n         *\n         * @private\n         * @function pointWithinObstacle\n         *\n         * @param {Object} obstacle\n         *        Obstacle to test.\n         *\n         * @param {Highcharts.Point} point\n         *        Point with x/y props.\n         *\n         * @return {boolean}\n         *         Whether point is within the obstacle or not.\n         */\n        function pointWithinObstacle(obstacle, point) {\n            return (point.x <= obstacle.xMax &&\n                point.x >= obstacle.xMin &&\n                point.y <= obstacle.yMax &&\n                point.y >= obstacle.yMin);\n        }\n        /**\n         * Find the index of an obstacle that wraps around a point.\n         * Returns -1 if not found.\n         *\n         * @private\n         * @function findObstacleFromPoint\n         *\n         * @param {Array<object>} obstacles\n         *        Obstacles to test.\n         *\n         * @param {Highcharts.Point} point\n         *        Point with x/y props.\n         *\n         * @return {number}\n         *         Ix of the obstacle in the array, or -1 if not found.\n         */\n        function findObstacleFromPoint(obstacles, point) {\n            let i = findLastObstacleBefore(obstacles, point.x + 1) + 1;\n            while (i--) {\n                if (obstacles[i].xMax >= point.x &&\n                    // Optimization using lazy evaluation\n                    pointWithinObstacle(obstacles[i], point)) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n        /**\n         * Get SVG path array from array of line segments.\n         *\n         * @private\n         * @function pathFromSegments\n         *\n         * @param {Array<object>} segments\n         *        The segments to build the path from.\n         *\n         * @return {Highcharts.SVGPathArray}\n         *         SVG path array as accepted by the SVG Renderer.\n         */\n        function pathFromSegments(segments) {\n            const path = [];\n            if (segments.length) {\n                path.push(['M', segments[0].start.x, segments[0].start.y]);\n                for (let i = 0; i < segments.length; ++i) {\n                    path.push(['L', segments[i].end.x, segments[i].end.y]);\n                }\n            }\n            return path;\n        }\n        /**\n         * Limits obstacle max/mins in all directions to bounds. Modifies input\n         * obstacle.\n         *\n         * @private\n         * @function limitObstacleToBounds\n         *\n         * @param {Object} obstacle\n         *        Obstacle to limit.\n         *\n         * @param {Object} bounds\n         *        Bounds to use as limit.\n         *\n         * @return {void}\n         */\n        function limitObstacleToBounds(obstacle, bounds) {\n            obstacle.yMin = max(obstacle.yMin, bounds.yMin);\n            obstacle.yMax = min(obstacle.yMax, bounds.yMax);\n            obstacle.xMin = max(obstacle.xMin, bounds.xMin);\n            obstacle.xMax = min(obstacle.xMax, bounds.xMax);\n        }\n        /**\n         * Get an SVG path from a starting coordinate to an ending coordinate.\n         * Draws a straight line.\n         *\n         * @function Highcharts.Pathfinder.algorithms.straight\n         *\n         * @param {Highcharts.PositionObject} start\n         *        Starting coordinate, object with x/y props.\n         *\n         * @param {Highcharts.PositionObject} end\n         *        Ending coordinate, object with x/y props.\n         *\n         * @return {Object}\n         *         An object with the SVG path in Array form as accepted by the SVG\n         *         renderer, as well as an array of new obstacles making up this\n         *         path.\n         */\n        function straight(start, end) {\n            return {\n                path: [\n                    ['M', start.x, start.y],\n                    ['L', end.x, end.y]\n                ],\n                obstacles: [{ start: start, end: end }]\n            };\n        }\n        /**\n         * Find a path from a starting coordinate to an ending coordinate, using\n         * right angles only, and taking only starting/ending obstacle into\n         * consideration.\n         *\n         * @function Highcharts.Pathfinder.algorithms.simpleConnect\n         *\n         * @param {Highcharts.PositionObject} start\n         *        Starting coordinate, object with x/y props.\n         *\n         * @param {Highcharts.PositionObject} end\n         *        Ending coordinate, object with x/y props.\n         *\n         * @param {Object} options\n         *        Options for the algorithm:\n         *        - chartObstacles: Array of chart obstacles to avoid\n         *        - startDirectionX: Optional. True if starting in the X direction.\n         *          If not provided, the algorithm starts in the direction that is\n         *          the furthest between start/end.\n         *\n         * @return {Object}\n         *         An object with the SVG path in Array form as accepted by the SVG\n         *         renderer, as well as an array of new obstacles making up this\n         *         path.\n         */\n        const simpleConnect = function (start, end, options) {\n            const segments = [], chartObstacles = options.chartObstacles, startObstacleIx = findObstacleFromPoint(chartObstacles, start), endObstacleIx = findObstacleFromPoint(chartObstacles, end);\n            let endSegment, dir = pick(options.startDirectionX, abs(end.x - start.x) > abs(end.y - start.y)) ? 'x' : 'y', startObstacle, endObstacle, waypoint, useMax, endPoint;\n            // eslint-disable-next-line valid-jsdoc\n            /**\n             * Return a clone of a point with a property set from a target object,\n             * optionally with an offset\n             * @private\n             */\n            function copyFromPoint(from, fromKey, to, toKey, offset) {\n                const point = {\n                    x: from.x,\n                    y: from.y\n                };\n                point[fromKey] = to[toKey || fromKey] + (offset || 0);\n                return point;\n            }\n            // eslint-disable-next-line valid-jsdoc\n            /**\n             * Return waypoint outside obstacle.\n             * @private\n             */\n            function getMeOut(obstacle, point, direction) {\n                const useMax = abs(point[direction] - obstacle[direction + 'Min']) >\n                    abs(point[direction] - obstacle[direction + 'Max']);\n                return copyFromPoint(point, direction, obstacle, direction + (useMax ? 'Max' : 'Min'), useMax ? 1 : -1);\n            }\n            // Pull out end point\n            if (endObstacleIx > -1) {\n                endObstacle = chartObstacles[endObstacleIx];\n                waypoint = getMeOut(endObstacle, end, dir);\n                endSegment = {\n                    start: waypoint,\n                    end: end\n                };\n                endPoint = waypoint;\n            }\n            else {\n                endPoint = end;\n            }\n            // If an obstacle envelops the start point, add a segment to get out,\n            // and around it.\n            if (startObstacleIx > -1) {\n                startObstacle = chartObstacles[startObstacleIx];\n                waypoint = getMeOut(startObstacle, start, dir);\n                segments.push({\n                    start: start,\n                    end: waypoint\n                });\n                // If we are going back again, switch direction to get around start\n                // obstacle.\n                if (\n                // Going towards max from start:\n                waypoint[dir] >= start[dir] ===\n                    // Going towards min to end:\n                    waypoint[dir] >= endPoint[dir]) {\n                    dir = dir === 'y' ? 'x' : 'y';\n                    useMax = start[dir] < end[dir];\n                    segments.push({\n                        start: waypoint,\n                        end: copyFromPoint(waypoint, dir, startObstacle, dir + (useMax ? 'Max' : 'Min'), useMax ? 1 : -1)\n                    });\n                    // Switch direction again\n                    dir = dir === 'y' ? 'x' : 'y';\n                }\n            }\n            // We are around the start obstacle. Go towards the end in one\n            // direction.\n            const prevWaypoint = segments.length ?\n                segments[segments.length - 1].end :\n                start;\n            waypoint = copyFromPoint(prevWaypoint, dir, endPoint);\n            segments.push({\n                start: prevWaypoint,\n                end: waypoint\n            });\n            // Final run to end point in the other direction\n            dir = dir === 'y' ? 'x' : 'y';\n            const waypoint2 = copyFromPoint(waypoint, dir, endPoint);\n            segments.push({\n                start: waypoint,\n                end: waypoint2\n            });\n            // Finally add the endSegment\n            segments.push(endSegment);\n            const path = PathUtilities.applyRadius(pathFromSegments(segments), options.radius);\n            return {\n                path,\n                obstacles: segments\n            };\n        };\n        simpleConnect.requiresObstacles = true;\n        /**\n         * Find a path from a starting coordinate to an ending coordinate, taking\n         * obstacles into consideration. Might not always find the optimal path,\n         * but is fast, and usually good enough.\n         *\n         * @function Highcharts.Pathfinder.algorithms.fastAvoid\n         *\n         * @param {Highcharts.PositionObject} start\n         *        Starting coordinate, object with x/y props.\n         *\n         * @param {Highcharts.PositionObject} end\n         *        Ending coordinate, object with x/y props.\n         *\n         * @param {Object} options\n         *        Options for the algorithm.\n         *        - chartObstacles:  Array of chart obstacles to avoid\n         *        - lineObstacles:   Array of line obstacles to jump over\n         *        - obstacleMetrics: Object with metrics of chartObstacles cached\n         *        - hardBounds:      Hard boundaries to not cross\n         *        - obstacleOptions: Options for the obstacles, including margin\n         *        - startDirectionX: Optional. True if starting in the X direction.\n         *                           If not provided, the algorithm starts in the\n         *                           direction that is the furthest between\n         *                           start/end.\n         *\n         * @return {Object}\n         *         An object with the SVG path in Array form as accepted by the SVG\n         *         renderer, as well as an array of new obstacles making up this\n         *         path.\n         */\n        function fastAvoid(start, end, options) {\n            /*\n                Algorithm rules/description\n                - Find initial direction\n                - Determine soft/hard max for each direction.\n                - Move along initial direction until obstacle.\n                - Change direction.\n                - If hitting obstacle, first try to change length of previous line\n                    before changing direction again.\n\n                Soft min/max x = start/destination x +/- widest obstacle + margin\n                Soft min/max y = start/destination y +/- tallest obstacle + margin\n\n                @todo:\n                    - Make retrospective, try changing prev segment to reduce\n                        corners\n                    - Fix logic for breaking out of end-points - not always picking\n                        the best direction currently\n                    - When going around the end obstacle we should not always go the\n                        shortest route, rather pick the one closer to the end point\n            */\n            const dirIsX = pick(options.startDirectionX, abs(end.x - start.x) > abs(end.y - start.y)), dir = dirIsX ? 'x' : 'y', endSegments = [], \n            // Boundaries to stay within. If beyond soft boundary, prefer to\n            // change direction ASAP. If at hard max, always change immediately.\n            metrics = options.obstacleMetrics, softMinX = min(start.x, end.x) - metrics.maxWidth - 10, softMaxX = max(start.x, end.x) + metrics.maxWidth + 10, softMinY = min(start.y, end.y) - metrics.maxHeight - 10, softMaxY = max(start.y, end.y) + metrics.maxHeight + 10;\n            let segments, useMax, extractedEndPoint, forceObstacleBreak = false, // Used in clearPathTo to keep track of\n            // when to force break through an obstacle.\n            // Obstacles\n            chartObstacles = options.chartObstacles, endObstacleIx = findLastObstacleBefore(chartObstacles, softMaxX);\n            const startObstacleIx = findLastObstacleBefore(chartObstacles, softMinX);\n            // eslint-disable-next-line valid-jsdoc\n            /**\n             * How far can you go between two points before hitting an obstacle?\n             * Does not work for diagonal lines (because it doesn't have to).\n             * @private\n             */\n            function pivotPoint(fromPoint, toPoint, directionIsX) {\n                const searchDirection = fromPoint.x < toPoint.x ? 1 : -1;\n                let firstPoint, lastPoint, highestPoint, lowestPoint;\n                if (fromPoint.x < toPoint.x) {\n                    firstPoint = fromPoint;\n                    lastPoint = toPoint;\n                }\n                else {\n                    firstPoint = toPoint;\n                    lastPoint = fromPoint;\n                }\n                if (fromPoint.y < toPoint.y) {\n                    lowestPoint = fromPoint;\n                    highestPoint = toPoint;\n                }\n                else {\n                    lowestPoint = toPoint;\n                    highestPoint = fromPoint;\n                }\n                // Go through obstacle range in reverse if toPoint is before\n                // fromPoint in the X-dimension.\n                let i = searchDirection < 0 ?\n                    // Searching backwards, start at last obstacle before last point\n                    min(findLastObstacleBefore(chartObstacles, lastPoint.x), chartObstacles.length - 1) :\n                    // Forwards. Since we're not sorted by xMax, we have to look\n                    // at all obstacles.\n                    0;\n                // Go through obstacles in this X range\n                while (chartObstacles[i] && (searchDirection > 0 && chartObstacles[i].xMin <= lastPoint.x ||\n                    searchDirection < 0 && chartObstacles[i].xMax >= firstPoint.x)) {\n                    // If this obstacle is between from and to points in a straight\n                    // line, pivot at the intersection.\n                    if (chartObstacles[i].xMin <= lastPoint.x &&\n                        chartObstacles[i].xMax >= firstPoint.x &&\n                        chartObstacles[i].yMin <= highestPoint.y &&\n                        chartObstacles[i].yMax >= lowestPoint.y) {\n                        if (directionIsX) {\n                            return {\n                                y: fromPoint.y,\n                                x: fromPoint.x < toPoint.x ?\n                                    chartObstacles[i].xMin - 1 :\n                                    chartObstacles[i].xMax + 1,\n                                obstacle: chartObstacles[i]\n                            };\n                        }\n                        // Else ...\n                        return {\n                            x: fromPoint.x,\n                            y: fromPoint.y < toPoint.y ?\n                                chartObstacles[i].yMin - 1 :\n                                chartObstacles[i].yMax + 1,\n                            obstacle: chartObstacles[i]\n                        };\n                    }\n                    i += searchDirection;\n                }\n                return toPoint;\n            }\n            /**\n             * Decide in which direction to dodge or get out of an obstacle.\n             * Considers desired direction, which way is shortest, soft and hard\n             * bounds.\n             *\n             * (? Returns a string, either xMin, xMax, yMin or yMax.)\n             *\n             * @private\n             * @function\n             *\n             * @param {Object} obstacle\n             *        Obstacle to dodge/escape.\n             *\n             * @param {Object} fromPoint\n             *        Point with x/y props that's dodging/escaping.\n             *\n             * @param {Object} toPoint\n             *        Goal point.\n             *\n             * @param {boolean} dirIsX\n             *        Dodge in X dimension.\n             *\n             * @param {Object} bounds\n             *        Hard and soft boundaries.\n             *\n             * @return {boolean}\n             *         Use max or not.\n             */\n            function getDodgeDirection(obstacle, fromPoint, toPoint, dirIsX, bounds) {\n                const softBounds = bounds.soft, hardBounds = bounds.hard, dir = dirIsX ? 'x' : 'y', toPointMax = { x: fromPoint.x, y: fromPoint.y }, toPointMin = { x: fromPoint.x, y: fromPoint.y }, maxOutOfSoftBounds = obstacle[dir + 'Max'] >=\n                    softBounds[dir + 'Max'], minOutOfSoftBounds = obstacle[dir + 'Min'] <=\n                    softBounds[dir + 'Min'], maxOutOfHardBounds = obstacle[dir + 'Max'] >=\n                    hardBounds[dir + 'Max'], minOutOfHardBounds = obstacle[dir + 'Min'] <=\n                    hardBounds[dir + 'Min'], \n                // Find out if we should prefer one direction over the other if\n                // we can choose freely\n                minDistance = abs(obstacle[dir + 'Min'] - fromPoint[dir]), maxDistance = abs(obstacle[dir + 'Max'] - fromPoint[dir]);\n                let // If it's a small difference, pick the one leading towards dest\n                // point. Otherwise pick the shortest distance\n                useMax = abs(minDistance - maxDistance) < 10 ?\n                    fromPoint[dir] < toPoint[dir] :\n                    maxDistance < minDistance;\n                // Check if we hit any obstacles trying to go around in either\n                // direction.\n                toPointMin[dir] = obstacle[dir + 'Min'];\n                toPointMax[dir] = obstacle[dir + 'Max'];\n                const minPivot = pivotPoint(fromPoint, toPointMin, dirIsX)[dir] !==\n                    toPointMin[dir], maxPivot = pivotPoint(fromPoint, toPointMax, dirIsX)[dir] !==\n                    toPointMax[dir];\n                useMax = minPivot ?\n                    (maxPivot ? useMax : true) :\n                    (maxPivot ? false : useMax);\n                // `useMax` now contains our preferred choice, bounds not taken into\n                // account. If both or neither direction is out of bounds we want to\n                // use this.\n                // Deal with soft bounds\n                useMax = minOutOfSoftBounds ?\n                    (maxOutOfSoftBounds ? useMax : true) : // Out on min\n                    (maxOutOfSoftBounds ? false : useMax); // Not out on min\n                // Deal with hard bounds\n                useMax = minOutOfHardBounds ?\n                    (maxOutOfHardBounds ? useMax : true) : // Out on min\n                    (maxOutOfHardBounds ? false : useMax); // Not out on min\n                return useMax;\n            }\n            // eslint-disable-next-line valid-jsdoc\n            /**\n             * Find a clear path between point.\n             * @private\n             */\n            function clearPathTo(fromPoint, toPoint, dirIsX) {\n                // Don't waste time if we've hit goal\n                if (fromPoint.x === toPoint.x && fromPoint.y === toPoint.y) {\n                    return [];\n                }\n                const dir = dirIsX ? 'x' : 'y', obstacleMargin = options.obstacleOptions.margin, bounds = {\n                    soft: {\n                        xMin: softMinX,\n                        xMax: softMaxX,\n                        yMin: softMinY,\n                        yMax: softMaxY\n                    },\n                    hard: options.hardBounds\n                };\n                let pivot, segments, waypoint, waypointUseMax, envelopingObstacle, secondEnvelopingObstacle, envelopWaypoint;\n                // If fromPoint is inside an obstacle we have a problem. Break out\n                // by just going to the outside of this obstacle. We prefer to go to\n                // the nearest edge in the chosen direction.\n                envelopingObstacle =\n                    findObstacleFromPoint(chartObstacles, fromPoint);\n                if (envelopingObstacle > -1) {\n                    envelopingObstacle = chartObstacles[envelopingObstacle];\n                    waypointUseMax = getDodgeDirection(envelopingObstacle, fromPoint, toPoint, dirIsX, bounds);\n                    // Cut obstacle to hard bounds to make sure we stay within\n                    limitObstacleToBounds(envelopingObstacle, options.hardBounds);\n                    envelopWaypoint = dirIsX ? {\n                        y: fromPoint.y,\n                        x: envelopingObstacle[waypointUseMax ? 'xMax' : 'xMin'] +\n                            (waypointUseMax ? 1 : -1)\n                    } : {\n                        x: fromPoint.x,\n                        y: envelopingObstacle[waypointUseMax ? 'yMax' : 'yMin'] +\n                            (waypointUseMax ? 1 : -1)\n                    };\n                    // If we crashed into another obstacle doing this, we put the\n                    // waypoint between them instead\n                    secondEnvelopingObstacle = findObstacleFromPoint(chartObstacles, envelopWaypoint);\n                    if (secondEnvelopingObstacle > -1) {\n                        secondEnvelopingObstacle = chartObstacles[secondEnvelopingObstacle];\n                        // Cut obstacle to hard bounds\n                        limitObstacleToBounds(secondEnvelopingObstacle, options.hardBounds);\n                        // Modify waypoint to lay between obstacles\n                        envelopWaypoint[dir] = waypointUseMax ? max(envelopingObstacle[dir + 'Max'] - obstacleMargin + 1, (secondEnvelopingObstacle[dir + 'Min'] +\n                            envelopingObstacle[dir + 'Max']) / 2) :\n                            min((envelopingObstacle[dir + 'Min'] + obstacleMargin - 1), ((secondEnvelopingObstacle[dir + 'Max'] +\n                                envelopingObstacle[dir + 'Min']) / 2));\n                        // We are not going anywhere. If this happens for the first\n                        // time, do nothing. Otherwise, try to go to the extreme of\n                        // the obstacle pair in the current direction.\n                        if (fromPoint.x === envelopWaypoint.x &&\n                            fromPoint.y === envelopWaypoint.y) {\n                            if (forceObstacleBreak) {\n                                envelopWaypoint[dir] = waypointUseMax ?\n                                    max(envelopingObstacle[dir + 'Max'], secondEnvelopingObstacle[dir + 'Max']) + 1 :\n                                    min(envelopingObstacle[dir + 'Min'], secondEnvelopingObstacle[dir + 'Min']) - 1;\n                            }\n                            // Toggle on if off, and the opposite\n                            forceObstacleBreak = !forceObstacleBreak;\n                        }\n                        else {\n                            // This point is not identical to previous.\n                            // Clear break trigger.\n                            forceObstacleBreak = false;\n                        }\n                    }\n                    segments = [{\n                            start: fromPoint,\n                            end: envelopWaypoint\n                        }];\n                }\n                else { // If not enveloping, use standard pivot calculation\n                    pivot = pivotPoint(fromPoint, {\n                        x: dirIsX ? toPoint.x : fromPoint.x,\n                        y: dirIsX ? fromPoint.y : toPoint.y\n                    }, dirIsX);\n                    segments = [{\n                            start: fromPoint,\n                            end: {\n                                x: pivot.x,\n                                y: pivot.y\n                            }\n                        }];\n                    // Pivot before goal, use a waypoint to dodge obstacle\n                    if (pivot[dirIsX ? 'x' : 'y'] !== toPoint[dirIsX ? 'x' : 'y']) {\n                        // Find direction of waypoint\n                        waypointUseMax = getDodgeDirection(pivot.obstacle, pivot, toPoint, !dirIsX, bounds);\n                        // Cut waypoint to hard bounds\n                        limitObstacleToBounds(pivot.obstacle, options.hardBounds);\n                        waypoint = {\n                            x: dirIsX ?\n                                pivot.x :\n                                pivot.obstacle[waypointUseMax ? 'xMax' : 'xMin'] +\n                                    (waypointUseMax ? 1 : -1),\n                            y: dirIsX ?\n                                pivot.obstacle[waypointUseMax ? 'yMax' : 'yMin'] +\n                                    (waypointUseMax ? 1 : -1) :\n                                pivot.y\n                        };\n                        // We're changing direction here, store that to make sure we\n                        // also change direction when adding the last segment array\n                        // after handling waypoint.\n                        dirIsX = !dirIsX;\n                        segments = segments.concat(clearPathTo({\n                            x: pivot.x,\n                            y: pivot.y\n                        }, waypoint, dirIsX));\n                    }\n                }\n                // Get segments for the other direction too\n                // Recursion is our friend\n                segments = segments.concat(clearPathTo(segments[segments.length - 1].end, toPoint, !dirIsX));\n                return segments;\n            }\n            // eslint-disable-next-line valid-jsdoc\n            /**\n             * Extract point to outside of obstacle in whichever direction is\n             * closest. Returns new point outside obstacle.\n             * @private\n             */\n            function extractFromObstacle(obstacle, point, goalPoint) {\n                const dirIsX = min(obstacle.xMax - point.x, point.x - obstacle.xMin) <\n                    min(obstacle.yMax - point.y, point.y - obstacle.yMin), bounds = {\n                    soft: options.hardBounds,\n                    hard: options.hardBounds\n                }, useMax = getDodgeDirection(obstacle, point, goalPoint, dirIsX, bounds);\n                return dirIsX ? {\n                    y: point.y,\n                    x: obstacle[useMax ? 'xMax' : 'xMin'] + (useMax ? 1 : -1)\n                } : {\n                    x: point.x,\n                    y: obstacle[useMax ? 'yMax' : 'yMin'] + (useMax ? 1 : -1)\n                };\n            }\n            // Cut the obstacle array to soft bounds for optimization in large\n            // datasets.\n            chartObstacles =\n                chartObstacles.slice(startObstacleIx, endObstacleIx + 1);\n            // If an obstacle envelops the end point, move it out of there and add\n            // a little segment to where it was.\n            if ((endObstacleIx = findObstacleFromPoint(chartObstacles, end)) > -1) {\n                extractedEndPoint = extractFromObstacle(chartObstacles[endObstacleIx], end, start);\n                endSegments.push({\n                    end: end,\n                    start: extractedEndPoint\n                });\n                end = extractedEndPoint;\n            }\n            // If it's still inside one or more obstacles, get out of there by\n            // force-moving towards the start point.\n            while ((endObstacleIx = findObstacleFromPoint(chartObstacles, end)) > -1) {\n                useMax = end[dir] - start[dir] < 0;\n                extractedEndPoint = {\n                    x: end.x,\n                    y: end.y\n                };\n                extractedEndPoint[dir] = chartObstacles[endObstacleIx][useMax ? dir + 'Max' : dir + 'Min'] + (useMax ? 1 : -1);\n                endSegments.push({\n                    end: end,\n                    start: extractedEndPoint\n                });\n                end = extractedEndPoint;\n            }\n            // Find the path\n            segments = clearPathTo(start, end, dirIsX);\n            // Add the end-point segments\n            segments = segments.concat(endSegments.reverse());\n            return {\n                path: pathFromSegments(segments),\n                obstacles: segments\n            };\n        }\n        fastAvoid.requiresObstacles = true;\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        // Define the available pathfinding algorithms.\n        // Algorithms take up to 3 arguments: starting point, ending point, and an\n        // options object.\n        const algorithms = {\n            fastAvoid,\n            straight,\n            simpleConnect\n        };\n\n        return algorithms;\n    });\n    _registerModule(_modules, 'Gantt/ConnectorsDefaults.js', [], function () {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Authors: Øystein Moseng, Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  API Defaults\n         *\n         * */\n        /*\n         @todo:\n             - Document how to write your own algorithms\n             - Consider adding a Point.pathTo method that wraps creating a connection\n               and rendering it\n        */\n        const connectorsDefaults = {\n            /**\n             * The Pathfinder module allows you to define connections between any two\n             * points, represented as lines - optionally with markers for the start\n             * and/or end points. Multiple algorithms are available for calculating how\n             * the connecting lines are drawn.\n             *\n             * Connector functionality requires Highcharts Gantt to be loaded. In Gantt\n             * charts, the connectors are used to draw dependencies between tasks.\n             *\n             * @see [dependency](series.gantt.data.dependency)\n             *\n             * @sample gantt/pathfinder/demo\n             *         Pathfinder connections\n             *\n             * @declare      Highcharts.ConnectorsOptions\n             * @product      gantt\n             * @optionparent connectors\n             */\n            connectors: {\n                /**\n                 * Enable connectors for this chart. Requires Highcharts Gantt.\n                 *\n                 * @type      {boolean}\n                 * @default   true\n                 * @since     6.2.0\n                 * @apioption connectors.enabled\n                 */\n                /**\n                 * Set the default dash style for this chart's connecting lines.\n                 *\n                 * @type      {string}\n                 * @default   solid\n                 * @since     6.2.0\n                 * @apioption connectors.dashStyle\n                 */\n                /**\n                 * Set the default color for this chart's Pathfinder connecting lines.\n                 * Defaults to the color of the point being connected.\n                 *\n                 * @type      {Highcharts.ColorString}\n                 * @since     6.2.0\n                 * @apioption connectors.lineColor\n                 */\n                /**\n                 * Set the default pathfinder margin to use, in pixels. Some Pathfinder\n                 * algorithms attempt to avoid obstacles, such as other points in the\n                 * chart. These algorithms use this margin to determine how close lines\n                 * can be to an obstacle. The default is to compute this automatically\n                 * from the size of the obstacles in the chart.\n                 *\n                 * To draw connecting lines close to existing points, set this to a low\n                 * number. For more space around existing points, set this number\n                 * higher.\n                 *\n                 * @sample gantt/pathfinder/algorithm-margin\n                 *         Small algorithmMargin\n                 *\n                 * @type      {number}\n                 * @since     6.2.0\n                 * @apioption connectors.algorithmMargin\n                 */\n                /**\n                 * Set the default pathfinder algorithm to use for this chart. It is\n                 * possible to define your own algorithms by adding them to the\n                 * Highcharts.Pathfinder.prototype.algorithms object before the chart\n                 * has been created.\n                 *\n                 * The default algorithms are as follows:\n                 *\n                 * `straight`:      Draws a straight line between the connecting\n                 *                  points. Does not avoid other points when drawing.\n                 *\n                 * `simpleConnect`: Finds a path between the points using right angles\n                 *                  only. Takes only starting/ending points into\n                 *                  account, and will not avoid other points.\n                 *\n                 * `fastAvoid`:     Finds a path between the points using right angles\n                 *                  only. Will attempt to avoid other points, but its\n                 *                  focus is performance over accuracy. Works well with\n                 *                  less dense datasets.\n                 *\n                 * Default value: `straight` is used as default for most series types,\n                 * while `simpleConnect` is used as default for Gantt series, to show\n                 * dependencies between points.\n                 *\n                 * @sample gantt/pathfinder/demo\n                 *         Different types used\n                 *\n                 * @type    {Highcharts.PathfinderTypeValue}\n                 * @default undefined\n                 * @since   6.2.0\n                 */\n                type: 'straight',\n                /**\n                 * The corner radius for the connector line.\n                 *\n                 * @since 11.2.0\n                 */\n                radius: 0,\n                /**\n                 * Set the default pixel width for this chart's Pathfinder connecting\n                 * lines.\n                 *\n                 * @since 6.2.0\n                 */\n                lineWidth: 1,\n                /**\n                 * Marker options for this chart's Pathfinder connectors. Note that\n                 * this option is overridden by the `startMarker` and `endMarker`\n                 * options.\n                 *\n                 * @declare Highcharts.ConnectorsMarkerOptions\n                 * @since   6.2.0\n                 */\n                marker: {\n                    /**\n                     * Set the radius of the connector markers. The default is\n                     * automatically computed based on the algorithmMargin setting.\n                     *\n                     * Setting marker.width and marker.height will override this\n                     * setting.\n                     *\n                     * @type      {number}\n                     * @since     6.2.0\n                     * @apioption connectors.marker.radius\n                     */\n                    /**\n                     * Set the width of the connector markers. If not supplied, this\n                     * is inferred from the marker radius.\n                     *\n                     * @type      {number}\n                     * @since     6.2.0\n                     * @apioption connectors.marker.width\n                     */\n                    /**\n                     * Set the height of the connector markers. If not supplied, this\n                     * is inferred from the marker radius.\n                     *\n                     * @type      {number}\n                     * @since     6.2.0\n                     * @apioption connectors.marker.height\n                     */\n                    /**\n                     * Set the color of the connector markers. By default this is the\n                     * same as the connector color.\n                     *\n                     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                     * @since     6.2.0\n                     * @apioption connectors.marker.color\n                     */\n                    /**\n                     * Set the line/border color of the connector markers. By default\n                     * this is the same as the marker color.\n                     *\n                     * @type      {Highcharts.ColorString}\n                     * @since     6.2.0\n                     * @apioption connectors.marker.lineColor\n                     */\n                    /**\n                     * Enable markers for the connectors.\n                     */\n                    enabled: false,\n                    /**\n                     * Horizontal alignment of the markers relative to the points.\n                     *\n                     * @type {Highcharts.AlignValue}\n                     */\n                    align: 'center',\n                    /**\n                     * Vertical alignment of the markers relative to the points.\n                     *\n                     * @type {Highcharts.VerticalAlignValue}\n                     */\n                    verticalAlign: 'middle',\n                    /**\n                     * Whether or not to draw the markers inside the points.\n                     */\n                    inside: false,\n                    /**\n                     * Set the line/border width of the pathfinder markers.\n                     */\n                    lineWidth: 1\n                },\n                /**\n                 * Marker options specific to the start markers for this chart's\n                 * Pathfinder connectors. Overrides the generic marker options.\n                 *\n                 * @declare Highcharts.ConnectorsStartMarkerOptions\n                 * @extends connectors.marker\n                 * @since   6.2.0\n                 */\n                startMarker: {\n                    /**\n                     * Set the symbol of the connector start markers.\n                     */\n                    symbol: 'diamond'\n                },\n                /**\n                 * Marker options specific to the end markers for this chart's\n                 * Pathfinder connectors. Overrides the generic marker options.\n                 *\n                 * @declare Highcharts.ConnectorsEndMarkerOptions\n                 * @extends connectors.marker\n                 * @since   6.2.0\n                 */\n                endMarker: {\n                    /**\n                     * Set the symbol of the connector end markers.\n                     */\n                    symbol: 'arrow-filled'\n                }\n            }\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * Override Pathfinder connector options for a series. Requires Highcharts Gantt\n         * to be loaded.\n         *\n         * @declare   Highcharts.SeriesConnectorsOptionsObject\n         * @extends   connectors\n         * @since     6.2.0\n         * @excluding enabled, algorithmMargin\n         * @product   gantt\n         * @apioption plotOptions.series.connectors\n         */\n        /**\n         * Connect to a point. This option can be either a string, referring to the ID\n         * of another point, or an object, or an array of either. If the option is an\n         * array, each element defines a connection.\n         *\n         * @sample gantt/pathfinder/demo\n         *         Different connection types\n         *\n         * @declare   Highcharts.XrangePointConnectorsOptionsObject\n         * @type      {string|Array<string|*>|*}\n         * @extends   plotOptions.series.connectors\n         * @since     6.2.0\n         * @excluding enabled\n         * @product   gantt\n         * @requires  highcharts-gantt\n         * @apioption series.xrange.data.connect\n         */\n        /**\n         * The ID of the point to connect to.\n         *\n         * @type      {string}\n         * @since     6.2.0\n         * @product   gantt\n         * @apioption series.xrange.data.connect.to\n         */\n        ''; // Keeps doclets above in JS file\n\n        return connectorsDefaults;\n    });\n    _registerModule(_modules, 'Gantt/PathfinderComposition.js', [_modules['Gantt/ConnectorsDefaults.js'], _modules['Core/Defaults.js'], _modules['Core/Utilities.js']], function (ConnectorsDefaults, D, U) {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Authors: Øystein Moseng, Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { setOptions } = D;\n        const { defined, error, merge } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Get point bounding box using plotX/plotY and shapeArgs. If using\n         * graphic.getBBox() directly, the bbox will be affected by animation.\n         *\n         * @private\n         * @function\n         *\n         * @param {Highcharts.Point} point\n         *        The point to get BB of.\n         *\n         * @return {Highcharts.Dictionary<number>|null}\n         *         Result xMax, xMin, yMax, yMin.\n         */\n        function getPointBB(point) {\n            const shapeArgs = point.shapeArgs;\n            // Prefer using shapeArgs (columns)\n            if (shapeArgs) {\n                return {\n                    xMin: shapeArgs.x || 0,\n                    xMax: (shapeArgs.x || 0) + (shapeArgs.width || 0),\n                    yMin: shapeArgs.y || 0,\n                    yMax: (shapeArgs.y || 0) + (shapeArgs.height || 0)\n                };\n            }\n            // Otherwise use plotX/plotY and bb\n            const bb = point.graphic && point.graphic.getBBox();\n            return bb ? {\n                xMin: point.plotX - bb.width / 2,\n                xMax: point.plotX + bb.width / 2,\n                yMin: point.plotY - bb.height / 2,\n                yMax: point.plotY + bb.height / 2\n            } : null;\n        }\n        /**\n         * Warn if using legacy options. Copy the options over. Note that this will\n         * still break if using the legacy options in chart.update, addSeries etc.\n         * @private\n         */\n        function warnLegacy(chart) {\n            if (chart.options.pathfinder ||\n                chart.series.reduce(function (acc, series) {\n                    if (series.options) {\n                        merge(true, (series.options.connectors = series.options.connectors ||\n                            {}), series.options.pathfinder);\n                    }\n                    return acc || series.options && series.options.pathfinder;\n                }, false)) {\n                merge(true, (chart.options.connectors = chart.options.connectors || {}), chart.options.pathfinder);\n                error('WARNING: Pathfinder options have been renamed. ' +\n                    'Use \"chart.connectors\" or \"series.connectors\" instead.');\n            }\n        }\n        /* *\n         *\n         *  Composition\n         *\n         * */\n        var ConnectionComposition;\n        (function (ConnectionComposition) {\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /** @private */\n            function compose(ChartClass, PathfinderClass, PointClass) {\n                const pointProto = PointClass.prototype;\n                if (!pointProto.getPathfinderAnchorPoint) {\n                    // Initialize Pathfinder for charts\n                    ChartClass.prototype.callbacks.push(function (chart) {\n                        const options = chart.options;\n                        if (options.connectors.enabled !== false) {\n                            warnLegacy(chart);\n                            this.pathfinder = new PathfinderClass(this);\n                            this.pathfinder.update(true); // First draw, defer render\n                        }\n                    });\n                    pointProto.getMarkerVector = pointGetMarkerVector;\n                    pointProto.getPathfinderAnchorPoint = pointGetPathfinderAnchorPoint;\n                    pointProto.getRadiansToVector = pointGetRadiansToVector;\n                    // Set default Pathfinder options\n                    setOptions(ConnectorsDefaults);\n                }\n            }\n            ConnectionComposition.compose = compose;\n            /**\n             * Get coordinates of anchor point for pathfinder connection.\n             *\n             * @private\n             * @function Highcharts.Point#getPathfinderAnchorPoint\n             *\n             * @param {Highcharts.ConnectorsMarkerOptions} markerOptions\n             *        Connection options for position on point.\n             *\n             * @return {Highcharts.PositionObject}\n             *         An object with x/y properties for the position. Coordinates are\n             *         in plot values, not relative to point.\n             */\n            function pointGetPathfinderAnchorPoint(markerOptions) {\n                const bb = getPointBB(this);\n                let x, y;\n                switch (markerOptions.align) { // eslint-disable-line default-case\n                    case 'right':\n                        x = 'xMax';\n                        break;\n                    case 'left':\n                        x = 'xMin';\n                }\n                switch (markerOptions.verticalAlign) { // eslint-disable-line default-case\n                    case 'top':\n                        y = 'yMin';\n                        break;\n                    case 'bottom':\n                        y = 'yMax';\n                }\n                return {\n                    x: x ? bb[x] : (bb.xMin + bb.xMax) / 2,\n                    y: y ? bb[y] : (bb.yMin + bb.yMax) / 2\n                };\n            }\n            /**\n             * Utility to get the angle from one point to another.\n             *\n             * @private\n             * @function Highcharts.Point#getRadiansToVector\n             *\n             * @param {Highcharts.PositionObject} v1\n             *        The first vector, as an object with x/y properties.\n             *\n             * @param {Highcharts.PositionObject} v2\n             *        The second vector, as an object with x/y properties.\n             *\n             * @return {number}\n             *         The angle in degrees\n             */\n            function pointGetRadiansToVector(v1, v2) {\n                let box;\n                if (!defined(v2)) {\n                    box = getPointBB(this);\n                    if (box) {\n                        v2 = {\n                            x: (box.xMin + box.xMax) / 2,\n                            y: (box.yMin + box.yMax) / 2\n                        };\n                    }\n                }\n                return Math.atan2(v2.y - v1.y, v1.x - v2.x);\n            }\n            /**\n             * Utility to get the position of the marker, based on the path angle and\n             * the marker's radius.\n             *\n             * @private\n             * @function Highcharts.Point#getMarkerVector\n             *\n             * @param {number} radians\n             *        The angle in radians from the point center to another vector.\n             *\n             * @param {number} markerRadius\n             *        The radius of the marker, to calculate the additional distance to\n             *        the center of the marker.\n             *\n             * @param {Object} anchor\n             *        The anchor point of the path and marker as an object with x/y\n             *        properties.\n             *\n             * @return {Object}\n             *         The marker vector as an object with x/y properties.\n             */\n            function pointGetMarkerVector(radians, markerRadius, anchor) {\n                const twoPI = Math.PI * 2.0, bb = getPointBB(this), rectWidth = bb.xMax - bb.xMin, rectHeight = bb.yMax - bb.yMin, rAtan = Math.atan2(rectHeight, rectWidth), rectHalfWidth = rectWidth / 2.0, rectHalfHeight = rectHeight / 2.0, rectHorizontalCenter = bb.xMin + rectHalfWidth, rectVerticalCenter = bb.yMin + rectHalfHeight, edgePoint = {\n                    x: rectHorizontalCenter,\n                    y: rectVerticalCenter\n                };\n                let theta = radians, tanTheta = 1, leftOrRightRegion = false, xFactor = 1, yFactor = 1;\n                while (theta < -Math.PI) {\n                    theta += twoPI;\n                }\n                while (theta > Math.PI) {\n                    theta -= twoPI;\n                }\n                tanTheta = Math.tan(theta);\n                if ((theta > -rAtan) && (theta <= rAtan)) {\n                    // Right side\n                    yFactor = -1;\n                    leftOrRightRegion = true;\n                }\n                else if (theta > rAtan && theta <= (Math.PI - rAtan)) {\n                    // Top side\n                    yFactor = -1;\n                }\n                else if (theta > (Math.PI - rAtan) || theta <= -(Math.PI - rAtan)) {\n                    // Left side\n                    xFactor = -1;\n                    leftOrRightRegion = true;\n                }\n                else {\n                    // Bottom side\n                    xFactor = -1;\n                }\n                // Correct the edgePoint according to the placement of the marker\n                if (leftOrRightRegion) {\n                    edgePoint.x += xFactor * (rectHalfWidth);\n                    edgePoint.y += yFactor * (rectHalfWidth) * tanTheta;\n                }\n                else {\n                    edgePoint.x += xFactor * (rectHeight / (2.0 * tanTheta));\n                    edgePoint.y += yFactor * (rectHalfHeight);\n                }\n                if (anchor.x !== rectHorizontalCenter) {\n                    edgePoint.x = anchor.x;\n                }\n                if (anchor.y !== rectVerticalCenter) {\n                    edgePoint.y = anchor.y;\n                }\n                return {\n                    x: edgePoint.x + (markerRadius * Math.cos(theta)),\n                    y: edgePoint.y - (markerRadius * Math.sin(theta))\n                };\n            }\n        })(ConnectionComposition || (ConnectionComposition = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ConnectionComposition;\n    });\n    _registerModule(_modules, 'Gantt/Pathfinder.js', [_modules['Gantt/Connection.js'], _modules['Gantt/PathfinderAlgorithms.js'], _modules['Gantt/PathfinderComposition.js'], _modules['Core/Series/Point.js'], _modules['Core/Utilities.js']], function (Connection, PathfinderAlgorithms, PathfinderComposition, Point, U) {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Authors: Øystein Moseng, Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { addEvent, defined, pick, splat } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const max = Math.max, min = Math.min;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Get point bounding box using plotX/plotY and shapeArgs. If using\n         * graphic.getBBox() directly, the bbox will be affected by animation.\n         *\n         * @private\n         * @function\n         *\n         * @param {Highcharts.Point} point\n         *        The point to get BB of.\n         *\n         * @return {Highcharts.Dictionary<number>|null}\n         *         Result xMax, xMin, yMax, yMin.\n         */\n        function getPointBB(point) {\n            const shapeArgs = point.shapeArgs;\n            // Prefer using shapeArgs (columns)\n            if (shapeArgs) {\n                return {\n                    xMin: shapeArgs.x || 0,\n                    xMax: (shapeArgs.x || 0) + (shapeArgs.width || 0),\n                    yMin: shapeArgs.y || 0,\n                    yMax: (shapeArgs.y || 0) + (shapeArgs.height || 0)\n                };\n            }\n            // Otherwise use plotX/plotY and bb\n            const bb = point.graphic && point.graphic.getBBox();\n            return bb ? {\n                xMin: point.plotX - bb.width / 2,\n                xMax: point.plotX + bb.width / 2,\n                yMin: point.plotY - bb.height / 2,\n                yMax: point.plotY + bb.height / 2\n            } : null;\n        }\n        /**\n         * Compute smallest distance between two rectangles.\n         * @private\n         */\n        function calculateObstacleDistance(a, b, bbMargin) {\n            // Count the distance even if we are slightly off\n            const margin = pick(bbMargin, 10), yOverlap = a.yMax + margin > b.yMin - margin &&\n                a.yMin - margin < b.yMax + margin, xOverlap = a.xMax + margin > b.xMin - margin &&\n                a.xMin - margin < b.xMax + margin, xDistance = yOverlap ? (a.xMin > b.xMax ? a.xMin - b.xMax : b.xMin - a.xMax) : Infinity, yDistance = xOverlap ? (a.yMin > b.yMax ? a.yMin - b.yMax : b.yMin - a.yMax) : Infinity;\n            // If the rectangles collide, try recomputing with smaller margin.\n            // If they collide anyway, discard the obstacle.\n            if (xOverlap && yOverlap) {\n                return (margin ?\n                    calculateObstacleDistance(a, b, Math.floor(margin / 2)) :\n                    Infinity);\n            }\n            return min(xDistance, yDistance);\n        }\n        /**\n         * Calculate margin to place around obstacles for the pathfinder in pixels.\n         * Returns a minimum of 1 pixel margin.\n         *\n         * @private\n         * @function\n         *\n         * @param {Array<object>} obstacles\n         *        Obstacles to calculate margin from.\n         *\n         * @return {number}\n         *         The calculated margin in pixels. At least 1.\n         */\n        function calculateObstacleMargin(obstacles) {\n            const len = obstacles.length, distances = [];\n            let onstacleDistance;\n            // Go over all obstacles and compare them to the others.\n            for (let i = 0; i < len; ++i) {\n                // Compare to all obstacles ahead. We will already have compared this\n                // obstacle to the ones before.\n                for (let j = i + 1; j < len; ++j) {\n                    onstacleDistance =\n                        calculateObstacleDistance(obstacles[i], obstacles[j]);\n                    // TODO: Magic number 80\n                    if (onstacleDistance < 80) { // Ignore large distances\n                        distances.push(onstacleDistance);\n                    }\n                }\n            }\n            // Ensure we always have at least one value, even in very spacious charts\n            distances.push(80);\n            return max(Math.floor(distances.sort(function (a, b) {\n                return (a - b);\n            })[\n            // Discard first 10% of the relevant distances, and then grab\n            // the smallest one.\n            Math.floor(distances.length / 10)] / 2 - 1 // Divide the distance by 2 and subtract 1.\n            ), 1 // 1 is the minimum margin\n            );\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The Pathfinder class.\n         *\n         * @private\n         * @class\n         * @name Highcharts.Pathfinder\n         *\n         * @param {Highcharts.Chart} chart\n         *        The chart to operate on.\n         */\n        class Pathfinder {\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            static compose(ChartClass, PointClass) {\n                PathfinderComposition.compose(ChartClass, Pathfinder, PointClass);\n            }\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(chart) {\n                this.init(chart);\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Initialize the Pathfinder object.\n             *\n             * @function Highcharts.Pathfinder#init\n             *\n             * @param {Highcharts.Chart} chart\n             *        The chart context.\n             */\n            init(chart) {\n                // Initialize pathfinder with chart context\n                this.chart = chart;\n                // Init connection reference list\n                this.connections = [];\n                // Recalculate paths/obstacles on chart redraw\n                addEvent(chart, 'redraw', function () {\n                    this.pathfinder.update();\n                });\n            }\n            /**\n             * Update Pathfinder connections from scratch.\n             *\n             * @function Highcharts.Pathfinder#update\n             *\n             * @param {boolean} [deferRender]\n             *        Whether or not to defer rendering of connections until\n             *        series.afterAnimate event has fired. Used on first render.\n             */\n            update(deferRender) {\n                const chart = this.chart, pathfinder = this, oldConnections = pathfinder.connections;\n                // Rebuild pathfinder connections from options\n                pathfinder.connections = [];\n                chart.series.forEach(function (series) {\n                    if (series.visible && !series.options.isInternal) {\n                        series.points.forEach(function (point) {\n                            const ganttPointOptions = point.options;\n                            // For Gantt series the connect could be\n                            // defined as a dependency\n                            if (ganttPointOptions && ganttPointOptions.dependency) {\n                                ganttPointOptions.connect = ganttPointOptions\n                                    .dependency;\n                            }\n                            const connects = (point.options?.connect &&\n                                splat(point.options.connect));\n                            let to;\n                            if (point.visible && point.isInside !== false && connects) {\n                                connects.forEach(function (connect) {\n                                    to = chart.get(typeof connect === 'string' ?\n                                        connect : connect.to);\n                                    if (to instanceof Point &&\n                                        to.series.visible &&\n                                        to.visible &&\n                                        to.isInside !== false) {\n                                        // Add new connection\n                                        pathfinder.connections.push(new Connection(point, // From\n                                        to, typeof connect === 'string' ?\n                                            {} :\n                                            connect));\n                                    }\n                                });\n                            }\n                        });\n                    }\n                });\n                // Clear connections that should not be updated, and move old info over\n                // to new connections.\n                for (let j = 0, k, found, lenOld = oldConnections.length, lenNew = pathfinder.connections.length; j < lenOld; ++j) {\n                    found = false;\n                    const oldCon = oldConnections[j];\n                    for (k = 0; k < lenNew; ++k) {\n                        const newCon = pathfinder.connections[k];\n                        if ((oldCon.options && oldCon.options.type) ===\n                            (newCon.options && newCon.options.type) &&\n                            oldCon.fromPoint === newCon.fromPoint &&\n                            oldCon.toPoint === newCon.toPoint) {\n                            newCon.graphics = oldCon.graphics;\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        oldCon.destroy();\n                    }\n                }\n                // Clear obstacles to force recalculation. This must be done on every\n                // redraw in case positions have changed. Recalculation is handled in\n                // Connection.getPath on demand.\n                delete this.chartObstacles;\n                delete this.lineObstacles;\n                // Draw the pending connections\n                pathfinder.renderConnections(deferRender);\n            }\n            /**\n             * Draw the chart's connecting paths.\n             *\n             * @function Highcharts.Pathfinder#renderConnections\n             *\n             * @param {boolean} [deferRender]\n             *        Whether or not to defer render until series animation is finished.\n             *        Used on first render.\n             */\n            renderConnections(deferRender) {\n                if (deferRender) {\n                    // Render after series are done animating\n                    this.chart.series.forEach(function (series) {\n                        const render = function () {\n                            // Find pathfinder connections belonging to this series\n                            // that haven't rendered, and render them now.\n                            const pathfinder = series.chart.pathfinder, conns = pathfinder && pathfinder.connections || [];\n                            conns.forEach(function (connection) {\n                                if (connection.fromPoint &&\n                                    connection.fromPoint.series === series) {\n                                    connection.render();\n                                }\n                            });\n                            if (series.pathfinderRemoveRenderEvent) {\n                                series.pathfinderRemoveRenderEvent();\n                                delete series.pathfinderRemoveRenderEvent;\n                            }\n                        };\n                        if (series.options.animation === false) {\n                            render();\n                        }\n                        else {\n                            series.pathfinderRemoveRenderEvent = addEvent(series, 'afterAnimate', render);\n                        }\n                    });\n                }\n                else {\n                    // Go through connections and render them\n                    this.connections.forEach(function (connection) {\n                        connection.render();\n                    });\n                }\n            }\n            /**\n             * Get obstacles for the points in the chart. Does not include connecting\n             * lines from Pathfinder. Applies algorithmMargin to the obstacles.\n             *\n             * @function Highcharts.Pathfinder#getChartObstacles\n             *\n             * @param {Object} options\n             *        Options for the calculation. Currently only\n             *        `options.algorithmMargin`.\n             *\n             * @param {number} options.algorithmMargin\n             *        The algorithm margin to use for the obstacles.\n\n            * @return {Array<object>}\n             *         An array of calculated obstacles. Each obstacle is defined as an\n             *         object with xMin, xMax, yMin and yMax properties.\n             */\n            getChartObstacles(options) {\n                const series = this.chart.series, margin = pick(options.algorithmMargin, 0);\n                let obstacles = [], calculatedMargin;\n                for (let i = 0, sLen = series.length; i < sLen; ++i) {\n                    if (series[i].visible && !series[i].options.isInternal) {\n                        for (let j = 0, pLen = series[i].points.length, bb, point; j < pLen; ++j) {\n                            point = series[i].points[j];\n                            if (point.visible) {\n                                bb = getPointBB(point);\n                                if (bb) {\n                                    obstacles.push({\n                                        xMin: bb.xMin - margin,\n                                        xMax: bb.xMax + margin,\n                                        yMin: bb.yMin - margin,\n                                        yMax: bb.yMax + margin\n                                    });\n                                }\n                            }\n                        }\n                    }\n                }\n                // Sort obstacles by xMin for optimization\n                obstacles = obstacles.sort(function (a, b) {\n                    return a.xMin - b.xMin;\n                });\n                // Add auto-calculated margin if the option is not defined\n                if (!defined(options.algorithmMargin)) {\n                    calculatedMargin =\n                        options.algorithmMargin =\n                            calculateObstacleMargin(obstacles);\n                    obstacles.forEach(function (obstacle) {\n                        obstacle.xMin -= calculatedMargin;\n                        obstacle.xMax += calculatedMargin;\n                        obstacle.yMin -= calculatedMargin;\n                        obstacle.yMax += calculatedMargin;\n                    });\n                }\n                return obstacles;\n            }\n            /**\n             * Utility function to get metrics for obstacles:\n             * - Widest obstacle width\n             * - Tallest obstacle height\n             *\n             * @function Highcharts.Pathfinder#getObstacleMetrics\n             *\n             * @param {Array<object>} obstacles\n             *        An array of obstacles to inspect.\n             *\n             * @return {Object}\n             *         The calculated metrics, as an object with maxHeight and maxWidth\n             *         properties.\n             */\n            getObstacleMetrics(obstacles) {\n                let maxWidth = 0, maxHeight = 0, width, height, i = obstacles.length;\n                while (i--) {\n                    width = obstacles[i].xMax - obstacles[i].xMin;\n                    height = obstacles[i].yMax - obstacles[i].yMin;\n                    if (maxWidth < width) {\n                        maxWidth = width;\n                    }\n                    if (maxHeight < height) {\n                        maxHeight = height;\n                    }\n                }\n                return {\n                    maxHeight: maxHeight,\n                    maxWidth: maxWidth\n                };\n            }\n            /**\n             * Utility to get which direction to start the pathfinding algorithm\n             * (X vs Y), calculated from a set of marker options.\n             *\n             * @function Highcharts.Pathfinder#getAlgorithmStartDirection\n             *\n             * @param {Highcharts.ConnectorsMarkerOptions} markerOptions\n             *        Marker options to calculate from.\n             *\n             * @return {boolean}\n             *         Returns true for X, false for Y, and undefined for autocalculate.\n             */\n            getAlgorithmStartDirection(markerOptions) {\n                const xCenter = markerOptions.align !== 'left' &&\n                    markerOptions.align !== 'right', yCenter = markerOptions.verticalAlign !== 'top' &&\n                    markerOptions.verticalAlign !== 'bottom';\n                return xCenter ?\n                    (yCenter ? void 0 : false) : // When x is centered\n                    (yCenter ? true : void 0); // When x is off-center\n            }\n        }\n        /**\n         * @name Highcharts.Pathfinder#algorithms\n         * @type {Highcharts.Dictionary<Function>}\n         */\n        Pathfinder.prototype.algorithms = PathfinderAlgorithms;\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * The default pathfinder algorithm to use for a chart. It is possible to define\n         * your own algorithms by adding them to the\n         * `Highcharts.Pathfinder.prototype.algorithms`\n         * object before the chart has been created.\n         *\n         * The default algorithms are as follows:\n         *\n         * `straight`:      Draws a straight line between the connecting\n         *                  points. Does not avoid other points when drawing.\n         *\n         * `simpleConnect`: Finds a path between the points using right angles\n         *                  only. Takes only starting/ending points into\n         *                  account, and will not avoid other points.\n         *\n         * `fastAvoid`:     Finds a path between the points using right angles\n         *                  only. Will attempt to avoid other points, but its\n         *                  focus is performance over accuracy. Works well with\n         *                  less dense datasets.\n         *\n         * @typedef {\"fastAvoid\"|\"simpleConnect\"|\"straight\"|string} Highcharts.PathfinderTypeValue\n         */\n        ''; // Keeps doclets above in JS file\n\n        return Pathfinder;\n    });\n    _registerModule(_modules, 'Extensions/ArrowSymbols.js', [], function () {\n        /* *\n         *\n         *  (c) 2017 Highsoft AS\n         *  Authors: Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Creates an arrow symbol. Like a triangle, except not filled.\n         * ```\n         *                   o\n         *             o\n         *       o\n         * o\n         *       o\n         *             o\n         *                   o\n         * ```\n         *\n         * @private\n         * @function\n         *\n         * @param {number} x\n         *        x position of the arrow\n         *\n         * @param {number} y\n         *        y position of the arrow\n         *\n         * @param {number} w\n         *        width of the arrow\n         *\n         * @param {number} h\n         *        height of the arrow\n         *\n         * @return {Highcharts.SVGPathArray}\n         *         Path array\n         */\n        function arrow(x, y, w, h) {\n            return [\n                ['M', x, y + h / 2],\n                ['L', x + w, y],\n                ['L', x, y + h / 2],\n                ['L', x + w, y + h]\n            ];\n        }\n        /**\n         * Creates a half-width arrow symbol. Like a triangle, except not filled.\n         * ```\n         *       o\n         *    o\n         * o\n         *    o\n         *       o\n         * ```\n         *\n         * @private\n         * @function\n         *\n         * @param {number} x\n         *        x position of the arrow\n         *\n         * @param {number} y\n         *        y position of the arrow\n         *\n         * @param {number} w\n         *        width of the arrow\n         *\n         * @param {number} h\n         *        height of the arrow\n         *\n         * @return {Highcharts.SVGPathArray}\n         *         Path array\n         */\n        function arrowHalf(x, y, w, h) {\n            return arrow(x, y, w / 2, h);\n        }\n        /**\n         * @private\n         */\n        function compose(SVGRendererClass) {\n            const symbols = SVGRendererClass.prototype.symbols;\n            symbols.arrow = arrow;\n            symbols['arrow-filled'] = triangleLeft;\n            symbols['arrow-filled-half'] = triangleLeftHalf;\n            symbols['arrow-half'] = arrowHalf;\n            symbols['triangle-left'] = triangleLeft;\n            symbols['triangle-left-half'] = triangleLeftHalf;\n        }\n        /**\n         * Creates a left-oriented triangle.\n         * ```\n         *             o\n         *       ooooooo\n         * ooooooooooooo\n         *       ooooooo\n         *             o\n         * ```\n         *\n         * @private\n         * @function\n         *\n         * @param {number} x\n         *        x position of the triangle\n         *\n         * @param {number} y\n         *        y position of the triangle\n         *\n         * @param {number} w\n         *        width of the triangle\n         *\n         * @param {number} h\n         *        height of the triangle\n         *\n         * @return {Highcharts.SVGPathArray}\n         *         Path array\n         */\n        function triangleLeft(x, y, w, h) {\n            return [\n                ['M', x + w, y],\n                ['L', x, y + h / 2],\n                ['L', x + w, y + h],\n                ['Z']\n            ];\n        }\n        /**\n         * Creates a half-width, left-oriented triangle.\n         * ```\n         *       o\n         *    oooo\n         * ooooooo\n         *    oooo\n         *       o\n         * ```\n         *\n         * @private\n         * @function\n         *\n         * @param {number} x\n         *        x position of the triangle\n         *\n         * @param {number} y\n         *        y position of the triangle\n         *\n         * @param {number} w\n         *        width of the triangle\n         *\n         * @param {number} h\n         *        height of the triangle\n         *\n         * @return {Highcharts.SVGPathArray}\n         *         Path array\n         */\n        function triangleLeftHalf(x, y, w, h) {\n            return triangleLeft(x, y, w / 2, h);\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const ArrowSymbols = {\n            compose\n        };\n\n        return ArrowSymbols;\n    });\n    _registerModule(_modules, 'masters/modules/pathfinder.src.js', [_modules['Core/Globals.js'], _modules['Gantt/Pathfinder.js'], _modules['Extensions/ArrowSymbols.js']], function (Highcharts, Pathfinder, ArrowSymbols) {\n\n        const G = Highcharts;\n        G.Pathfinder = G.Pathfinder || Pathfinder;\n        ArrowSymbols.compose(G.SVGRenderer);\n        G.Pathfinder.compose(G.Chart, G.Point);\n\n        return Highcharts;\n    });\n}));\n"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","win","dispatchEvent","detail","H","U","defined","error","merge","objectEach","deg2rad","max","Math","min","constructor","from","to","options","init","fromPoint","toPoint","chart","series","pathfinder","renderPath","attribs","styledMode","anim","pathGraphic","connection","graphics","group","renderer","g","addClass","attr","zIndex","add","seriesGroup","translate","plotLeft","plotTop","opacity","d","animate","addMarker","type","markerVector","radians","rotation","box","width","height","pathVector","segment","point","anchor","getPathfinderAnchorPoint","enabled","length","x","y","getRadiansToVector","getMarkerVector","radius","rotationOriginX","rotationOriginY","symbol","colorIndex","fill","color","stroke","lineColor","lineWidth","animation","getPath","algorithm","algorithms","chartObstacles","obstacles","requiresObstacles","getChartObstacles","connectors","algorithmMargin","chartObstacleMetrics","getObstacleMetrics","startMarker","endMarker","lineObstacles","obstacleMetrics","hardBounds","xMin","xMax","plotWidth","yMin","yMax","plotHeight","obstacleOptions","margin","startDirectionX","getAlgorithmStartDirection","render","dashStyle","dashstyle","marker","ceil","pathResult","concat","destroy","val","applyRadius","r","i","push","prevSeg","nextSeg","x1","y1","x2","y2","directionX","directionY","abs","getLinkPath","pathParams","inverted","parentVisible","straight","curved","offset","PathUtilities","pick","findLastObstacleBefore","startIx","left","right","cursor","cmp","findObstacleFromPoint","obstacle","pathFromSegments","segments","start","end","limitObstacleToBounds","bounds","simpleConnect","startObstacleIx","endObstacleIx","endSegment","dir","startObstacle","waypoint","useMax","endPoint","copyFromPoint","fromKey","toKey","getMeOut","direction","prevWaypoint","waypoint2","fastAvoid","dirIsX","endSegments","metrics","softMinX","maxWidth","softMaxX","softMinY","maxHeight","softMaxY","extractedEndPoint","forceObstacleBreak","pivotPoint","directionIsX","firstPoint","lastPoint","highestPoint","lowestPoint","searchDirection","getDodgeDirection","softBounds","soft","hard","toPointMax","toPointMin","maxOutOfSoftBounds","minOutOfSoftBounds","maxOutOfHardBounds","minOutOfHardBounds","minDistance","maxDistance","minPivot","maxPivot","slice","extractFromObstacle","goalPoint","clearPathTo","pivot","waypointUseMax","envelopingObstacle","secondEnvelopingObstacle","envelopWaypoint","obstacleMargin","reverse","align","verticalAlign","inside","ConnectorsDefaults","D","ConnectionComposition","setOptions","getPointBB","shapeArgs","bb","graphic","getBBox","plotX","plotY","pointGetPathfinderAnchorPoint","markerOptions","pointGetRadiansToVector","v1","v2","atan2","pointGetMarkerVector","markerRadius","twoPI","PI","rectWidth","rectHeight","rAtan","rectHalfWidth","rectHalfHeight","rectHorizontalCenter","rectVerticalCenter","edgePoint","theta","tanTheta","leftOrRightRegion","xFactor","yFactor","tan","cos","sin","compose","ChartClass","PathfinderClass","PointClass","pointProto","prototype","callbacks","reduce","acc","update","Connection","PathfinderAlgorithms","PathfinderComposition","Point","addEvent","splat","Pathfinder","connections","deferRender","oldConnections","forEach","visible","isInternal","points","ganttPointOptions","dependency","connect","connects","isInside","get","j","k","found","lenOld","lenNew","oldCon","newCon","renderConnections","conns","pathfinderRemoveRenderEvent","calculatedMargin","sLen","pLen","sort","a","b","calculateObstacleMargin","onstacleDistance","len","distances","calculateObstacleDistance","bbMargin","yOverlap","xOverlap","xDistance","Infinity","yDistance","floor","xCenter","yCenter","arrow","w","h","arrowHalf","triangleLeft","triangleLeftHalf","SVGRendererClass","symbols","ArrowSymbols","G","SVGRenderer","Chart"],"mappings":"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"}
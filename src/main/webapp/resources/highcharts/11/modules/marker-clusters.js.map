{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v11.4.8 (2024-08-29)\n *\n * Marker clusters module for Highcharts\n *\n * (c) 2010-2024 Wojciech Chmiel\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/marker-clusters', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                Highcharts.win.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Extensions/MarkerClusters/MarkerClusterDefaults.js', [], function () {\n        /* *\n         *\n         *  Marker clusters module.\n         *\n         *  (c) 2010-2024 Torstein Honsi\n         *\n         *  Author: Wojciech Chmiel\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * Options for marker clusters, the concept of sampling the data\n         * values into larger blocks in order to ease readability and\n         * increase performance of the JavaScript charts.\n         *\n         * Note: marker clusters module is not working with `boost`\n         * and `draggable-points` modules.\n         *\n         * The marker clusters feature requires the marker-clusters.js\n         * file to be loaded, found in the modules directory of the download\n         * package, or online at [code.highcharts.com/modules/marker-clusters.js\n         * ](code.highcharts.com/modules/marker-clusters.js).\n         *\n         * @sample maps/marker-clusters/europe\n         *         Maps marker clusters\n         * @sample highcharts/marker-clusters/basic\n         *         Scatter marker clusters\n         * @sample maps/marker-clusters/optimized-kmeans\n         *         Marker clusters with colorAxis\n         *\n         * @product      highcharts highmaps\n         * @since 8.0.0\n         * @optionparent plotOptions.scatter.cluster\n         *\n         * @private\n         */\n        const cluster = {\n            /**\n             * Whether to enable the marker-clusters module.\n             *\n             * @sample maps/marker-clusters/basic\n             *         Maps marker clusters\n             * @sample highcharts/marker-clusters/basic\n             *         Scatter marker clusters\n             */\n            enabled: false,\n            /**\n             * When set to `false` prevent cluster overlapping - this option\n             * works only when `layoutAlgorithm.type = \"grid\"`.\n             *\n             * @sample highcharts/marker-clusters/grid\n             *         Prevent overlapping\n             */\n            allowOverlap: true,\n            /**\n             * Options for the cluster marker animation.\n             * @type    {boolean|Partial<Highcharts.AnimationOptionsObject>}\n             * @default { \"duration\": 500 }\n             */\n            animation: {\n                /** @ignore-option */\n                duration: 500\n            },\n            /**\n             * Zoom the plot area to the cluster points range when a cluster is clicked.\n             */\n            drillToCluster: true,\n            /**\n             * The minimum amount of points to be combined into a cluster.\n             * This value has to be greater or equal to 2.\n             *\n             * @sample highcharts/marker-clusters/basic\n             *         At least three points in the cluster\n             */\n            minimumClusterSize: 2,\n            /**\n             * Options for layout algorithm. Inside there\n             * are options to change the type of the algorithm, gridSize,\n             * distance or iterations.\n             */\n            layoutAlgorithm: {\n                /**\n                 * Type of the algorithm used to combine points into a cluster.\n                 * There are three available algorithms:\n                 *\n                 * 1) `grid` - grid-based clustering technique. Points are assigned\n                 * to squares of set size depending on their position on the plot\n                 * area. Points inside the grid square are combined into a cluster.\n                 * The grid size can be controlled by `gridSize` property\n                 * (grid size changes at certain zoom levels).\n                 *\n                 * 2) `kmeans` - based on K-Means clustering technique. In the\n                 * first step, points are divided using the grid method (distance\n                 * property is a grid size) to find the initial amount of clusters.\n                 * Next, each point is classified by computing the distance between\n                 * each cluster center and that point. When the closest cluster\n                 * distance is lower than distance property set by a user the point\n                 * is added to this cluster otherwise is classified as `noise`. The\n                 * algorithm is repeated until each cluster center not change its\n                 * previous position more than one pixel. This technique is more\n                 * accurate but also more time consuming than the `grid` algorithm,\n                 * especially for big datasets.\n                 *\n                 * 3) `optimizedKmeans` - based on K-Means clustering technique. This\n                 * algorithm uses k-means algorithm only on the chart initialization\n                 * or when chart extremes have greater range than on initialization.\n                 * When a chart is redrawn the algorithm checks only clustered points\n                 * distance from the cluster center and rebuild it when the point is\n                 * spaced enough to be outside the cluster. It provides performance\n                 * improvement and more stable clusters position yet can be used rather\n                 * on small and sparse datasets.\n                 *\n                 * By default, the algorithm depends on visible quantity of points\n                 * and `kmeansThreshold`. When there are more visible points than the\n                 * `kmeansThreshold` the `grid` algorithm is used, otherwise `kmeans`.\n                 *\n                 * The custom clustering algorithm can be added by assigning a callback\n                 * function as the type property. This function takes an array of\n                 * `processedXData`, `processedYData`, `processedXData` indexes and\n                 * `layoutAlgorithm` options as arguments and should return an object\n                 * with grouped data.\n                 *\n                 * The algorithm should return an object like that:\n                 * <pre>{\n                 *  clusterId1: [{\n                 *      x: 573,\n                 *      y: 285,\n                 *      index: 1 // point index in the data array\n                 *  }, {\n                 *      x: 521,\n                 *      y: 197,\n                 *      index: 2\n                 *  }],\n                 *  clusterId2: [{\n                 *      ...\n                 *  }]\n                 *  ...\n                 * }</pre>\n                 *\n                 * `clusterId` (example above - unique id of a cluster or noise)\n                 * is an array of points belonging to a cluster. If the\n                 * array has only one point or fewer points than set in\n                 * `cluster.minimumClusterSize` it won't be combined into a cluster.\n                 *\n                 * @sample maps/marker-clusters/optimized-kmeans\n                 *         Optimized K-Means algorithm\n                 * @sample highcharts/marker-clusters/kmeans\n                 *         K-Means algorithm\n                 * @sample highcharts/marker-clusters/grid\n                 *         Grid algorithm\n                 * @sample maps/marker-clusters/custom-alg\n                 *         Custom algorithm\n                 *\n                 * @type {string|Function}\n                 * @see [cluster.minimumClusterSize](#plotOptions.scatter.cluster.minimumClusterSize)\n                 * @apioption plotOptions.scatter.cluster.layoutAlgorithm.type\n                 */\n                /**\n                 * When `type` is set to the `grid`,\n                 * `gridSize` is a size of a grid square element either as a number\n                 * defining pixels, or a percentage defining a percentage\n                 * of the plot area width.\n                 *\n                 * @type    {number|string}\n                 */\n                gridSize: 50,\n                /**\n                 * When `type` is set to `kmeans`,\n                 * `iterations` are the number of iterations that this algorithm will be\n                 * repeated to find clusters positions.\n                 *\n                 * @type    {number}\n                 * @apioption plotOptions.scatter.cluster.layoutAlgorithm.iterations\n                 */\n                /**\n                 * When `type` is set to `kmeans`,\n                 * `distance` is a maximum distance between point and cluster center\n                 * so that this point will be inside the cluster. The distance\n                 * is either a number defining pixels or a percentage\n                 * defining a percentage of the plot area width.\n                 *\n                 * @type    {number|string}\n                 */\n                distance: 40,\n                /**\n                 * When `type` is set to `undefined` and there are more visible points\n                 * than the kmeansThreshold the `grid` algorithm is used to find\n                 * clusters, otherwise `kmeans`. It ensures good performance on\n                 * large datasets and better clusters arrangement after the zoom.\n                 */\n                kmeansThreshold: 100\n            },\n            /**\n             * Options for the cluster marker.\n             * @type      {Highcharts.PointMarkerOptionsObject}\n             * @extends   plotOptions.series.marker\n             * @excluding enabledThreshold, states\n             */\n            marker: {\n                /** @internal */\n                symbol: 'cluster',\n                /** @internal */\n                radius: 15,\n                /** @internal */\n                lineWidth: 0,\n                /** @internal */\n                lineColor: \"#ffffff\" /* Palette.backgroundColor */\n            },\n            /**\n             * Fires when the cluster point is clicked and `drillToCluster` is enabled.\n             * One parameter, `event`, is passed to the function. The default action\n             * is to zoom to the cluster points range. This can be prevented\n             * by calling `event.preventDefault()`.\n             *\n             * @type      {Highcharts.MarkerClusterDrillCallbackFunction}\n             * @product   highcharts highmaps\n             * @see [cluster.drillToCluster](#plotOptions.scatter.cluster.drillToCluster)\n             * @apioption plotOptions.scatter.cluster.events.drillToCluster\n             */\n            /**\n             * An array defining zones within marker clusters.\n             *\n             * In styled mode, the color zones are styled with the\n             * `.highcharts-cluster-zone-{n}` class, or custom\n             * classed from the `className`\n             * option.\n             *\n             * @sample highcharts/marker-clusters/basic\n             *         Marker clusters zones\n             * @sample maps/marker-clusters/custom-alg\n             *         Zones on maps\n             *\n             * @type      {Array<*>}\n             * @product   highcharts highmaps\n             * @apioption plotOptions.scatter.cluster.zones\n             */\n            /**\n             * Styled mode only. A custom class name for the zone.\n             *\n             * @sample highcharts/css/color-zones/\n             *         Zones styled by class name\n             *\n             * @type      {string}\n             * @apioption plotOptions.scatter.cluster.zones.className\n             */\n            /**\n             * Settings for the cluster marker belonging to the zone.\n             *\n             * @see [cluster.marker](#plotOptions.scatter.cluster.marker)\n             * @extends   plotOptions.scatter.cluster.marker\n             * @product   highcharts highmaps\n             * @apioption plotOptions.scatter.cluster.zones.marker\n             */\n            /**\n             * The value where the zone starts.\n             *\n             * @type      {number}\n             * @product   highcharts highmaps\n             * @apioption plotOptions.scatter.cluster.zones.from\n             */\n            /**\n             * The value where the zone ends.\n             *\n             * @type      {number}\n             * @product   highcharts highmaps\n             * @apioption plotOptions.scatter.cluster.zones.to\n             */\n            /**\n             * The fill color of the cluster marker in hover state. When\n             * `undefined`, the series' or point's fillColor for normal\n             * state is used.\n             *\n             * @type      {Highcharts.ColorType}\n             * @apioption plotOptions.scatter.cluster.states.hover.fillColor\n             */\n            /**\n             * Options for the cluster data labels.\n             * @type    {Highcharts.DataLabelsOptions}\n             */\n            dataLabels: {\n                /** @internal */\n                enabled: true,\n                /** @internal */\n                format: '{point.clusterPointsAmount}',\n                /** @internal */\n                verticalAlign: 'middle',\n                /** @internal */\n                align: 'center',\n                /** @internal */\n                style: {\n                    color: 'contrast'\n                },\n                /** @internal */\n                inside: true\n            }\n        };\n        const tooltip = {\n            /**\n             * The HTML of the cluster point's in the tooltip. Works only with\n             * marker-clusters module and analogously to\n             * [pointFormat](#tooltip.pointFormat).\n             *\n             * The cluster tooltip can be also formatted using\n             * `tooltip.formatter` callback function and `point.isCluster` flag.\n             *\n             * @sample highcharts/marker-clusters/grid\n             *         Format tooltip for cluster points.\n             *\n             * @sample maps/marker-clusters/europe/\n             *         Format tooltip for clusters using tooltip.formatter\n             *\n             * @type      {string}\n             * @default   Clustered points: {point.clusterPointsAmount}\n             * @apioption tooltip.clusterFormat\n             */\n            clusterFormat: '<span>Clustered points: ' +\n                '{point.clusterPointsAmount}</span><br/>'\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const MarkerClusterDefaults = {\n            cluster,\n            tooltip\n        };\n\n        return MarkerClusterDefaults;\n    });\n    _registerModule(_modules, 'Extensions/MarkerClusters/MarkerClusterScatter.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Extensions/MarkerClusters/MarkerClusterDefaults.js'], _modules['Core/Utilities.js']], function (A, MarkerClusterDefaults, U) {\n        /* *\n         *\n         *  Marker clusters module.\n         *\n         *  (c) 2010-2024 Torstein Honsi\n         *\n         *  Author: Wojciech Chmiel\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { animObject } = A;\n        const { cluster: clusterDefaults } = MarkerClusterDefaults;\n        const { addEvent, defined, error, isArray, isFunction, isObject, isNumber, merge, objectEach, relativeLength, syncTimeout } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const markerClusterAlgorithms = {\n            grid: function (dataX, dataY, dataIndexes, options) {\n                const series = this, grid = {}, gridOffset = this.getGridOffset();\n                let x, y, gridX, gridY, key, i;\n                const scaledGridSize = series.getScaledGridSize(options);\n                for (i = 0; i < dataX.length; i++) {\n                    const p = valuesToPixels(series, { x: dataX[i], y: dataY[i] });\n                    x = p.x - gridOffset.plotLeft;\n                    y = p.y - gridOffset.plotTop;\n                    gridX = Math.floor(x / scaledGridSize);\n                    gridY = Math.floor(y / scaledGridSize);\n                    key = gridY + '-' + gridX;\n                    if (!grid[key]) {\n                        grid[key] = [];\n                    }\n                    grid[key].push({\n                        dataIndex: dataIndexes[i],\n                        x: dataX[i],\n                        y: dataY[i]\n                    });\n                }\n                return grid;\n            },\n            kmeans: function (dataX, dataY, dataIndexes, options) {\n                const series = this, clusters = [], noise = [], group = {}, pointMaxDistance = options.processedDistance ||\n                    clusterDefaults.layoutAlgorithm.distance, iterations = options.iterations, \n                // Max pixel difference beetwen new and old cluster position.\n                maxClusterShift = 1;\n                let currentIteration = 0, repeat = true, pointX = 0, pointY = 0, tempPos, pointClusterDistance = [];\n                options.processedGridSize = options.processedDistance;\n                // Use grid method to get groupedData object.\n                const groupedData = series.markerClusterAlgorithms ?\n                    series.markerClusterAlgorithms.grid.call(series, dataX, dataY, dataIndexes, options) : {};\n                // Find clusters amount and its start positions\n                // based on grid grouped data.\n                for (const key in groupedData) {\n                    if (groupedData[key].length > 1) {\n                        tempPos = getClusterPosition(groupedData[key]);\n                        clusters.push({\n                            posX: tempPos.x,\n                            posY: tempPos.y,\n                            oldX: 0,\n                            oldY: 0,\n                            startPointsLen: groupedData[key].length,\n                            points: []\n                        });\n                    }\n                }\n                // Start kmeans iteration process.\n                while (repeat) {\n                    for (const c of clusters) {\n                        c.points.length = 0;\n                    }\n                    noise.length = 0;\n                    for (let i = 0; i < dataX.length; i++) {\n                        pointX = dataX[i];\n                        pointY = dataY[i];\n                        pointClusterDistance = series.getClusterDistancesFromPoint(clusters, pointX, pointY);\n                        if (pointClusterDistance.length &&\n                            pointClusterDistance[0].distance < pointMaxDistance) {\n                            clusters[pointClusterDistance[0].clusterIndex].points.push({\n                                x: pointX,\n                                y: pointY,\n                                dataIndex: dataIndexes[i]\n                            });\n                        }\n                        else {\n                            noise.push({\n                                x: pointX,\n                                y: pointY,\n                                dataIndex: dataIndexes[i]\n                            });\n                        }\n                    }\n                    // When cluster points array has only one point the\n                    // point should be classified again.\n                    for (let i = 0; i < clusters.length; i++) {\n                        if (clusters[i].points.length === 1) {\n                            pointClusterDistance = series.getClusterDistancesFromPoint(clusters, clusters[i].points[0].x, clusters[i].points[0].y);\n                            if (pointClusterDistance[1].distance < pointMaxDistance) {\n                                // Add point to the next closest cluster.\n                                clusters[pointClusterDistance[1].clusterIndex].points\n                                    .push(clusters[i].points[0]);\n                                // Clear points array.\n                                clusters[pointClusterDistance[0].clusterIndex]\n                                    .points.length = 0;\n                            }\n                        }\n                    }\n                    // Compute a new clusters position and check if it\n                    // is different than the old one.\n                    repeat = false;\n                    for (let i = 0; i < clusters.length; i++) {\n                        tempPos = getClusterPosition(clusters[i].points);\n                        clusters[i].oldX = clusters[i].posX;\n                        clusters[i].oldY = clusters[i].posY;\n                        clusters[i].posX = tempPos.x;\n                        clusters[i].posY = tempPos.y;\n                        // Repeat the algorithm if at least one cluster\n                        // is shifted more than maxClusterShift property.\n                        if (clusters[i].posX > clusters[i].oldX + maxClusterShift ||\n                            clusters[i].posX < clusters[i].oldX - maxClusterShift ||\n                            clusters[i].posY > clusters[i].oldY + maxClusterShift ||\n                            clusters[i].posY < clusters[i].oldY - maxClusterShift) {\n                            repeat = true;\n                        }\n                    }\n                    // If iterations property is set repeat the algorithm\n                    // specified amount of times.\n                    if (iterations) {\n                        repeat = currentIteration < iterations - 1;\n                    }\n                    currentIteration++;\n                }\n                for (let i = 0, iEnd = clusters.length; i < iEnd; ++i) {\n                    group['cluster' + i] = clusters[i].points;\n                }\n                for (let i = 0, iEnd = noise.length; i < iEnd; ++i) {\n                    group['noise' + i] = [noise[i]];\n                }\n                return group;\n            },\n            optimizedKmeans: function (processedXData, processedYData, dataIndexes, options) {\n                const series = this, pointMaxDistance = options.processedDistance ||\n                    clusterDefaults.layoutAlgorithm.gridSize, extremes = series.getRealExtremes(), clusterMarkerOptions = (series.options.cluster || {}).marker;\n                let distance, group = {}, offset, radius;\n                if (!series.markerClusterInfo || (series.initMaxX && series.initMaxX < extremes.maxX ||\n                    series.initMinX && series.initMinX > extremes.minX ||\n                    series.initMaxY && series.initMaxY < extremes.maxY ||\n                    series.initMinY && series.initMinY > extremes.minY)) {\n                    series.initMaxX = extremes.maxX;\n                    series.initMinX = extremes.minX;\n                    series.initMaxY = extremes.maxY;\n                    series.initMinY = extremes.minY;\n                    group = series.markerClusterAlgorithms ?\n                        series.markerClusterAlgorithms.kmeans.call(series, processedXData, processedYData, dataIndexes, options) : {};\n                    series.baseClusters = null;\n                }\n                else {\n                    if (!series.baseClusters) {\n                        series.baseClusters = {\n                            clusters: series.markerClusterInfo.clusters,\n                            noise: series.markerClusterInfo.noise\n                        };\n                    }\n                    for (const cluster of series.baseClusters.clusters) {\n                        cluster.pointsOutside = [];\n                        cluster.pointsInside = [];\n                        for (const dataPoint of cluster.data) {\n                            const dataPointPx = valuesToPixels(series, dataPoint), clusterPx = valuesToPixels(series, cluster);\n                            distance = Math.sqrt(Math.pow(dataPointPx.x - clusterPx.x, 2) +\n                                Math.pow(dataPointPx.y - clusterPx.y, 2));\n                            if (cluster.clusterZone &&\n                                cluster.clusterZone.marker &&\n                                cluster.clusterZone.marker.radius) {\n                                radius = cluster.clusterZone.marker.radius;\n                            }\n                            else if (clusterMarkerOptions &&\n                                clusterMarkerOptions.radius) {\n                                radius = clusterMarkerOptions.radius;\n                            }\n                            else {\n                                radius = clusterDefaults.marker.radius;\n                            }\n                            offset = pointMaxDistance - radius >= 0 ?\n                                pointMaxDistance - radius : radius;\n                            if (distance > radius + offset &&\n                                defined(cluster.pointsOutside)) {\n                                cluster.pointsOutside.push(dataPoint);\n                            }\n                            else if (defined(cluster.pointsInside)) {\n                                cluster.pointsInside.push(dataPoint);\n                            }\n                        }\n                        if (cluster.pointsInside.length) {\n                            group[cluster.id] = cluster.pointsInside;\n                        }\n                        let i = 0;\n                        for (const p of cluster.pointsOutside) {\n                            group[cluster.id + '_noise' + i++] = [p];\n                        }\n                    }\n                    for (const noise of series.baseClusters.noise) {\n                        group[noise.id] = noise.data;\n                    }\n                }\n                return group;\n            }\n        };\n        /* *\n         *\n         *  Variables\n         *\n         * */\n        let baseGeneratePoints;\n        /**\n         * Points that ids are included in the oldPointsStateId array are hidden before\n         * animation. Other ones are destroyed.\n         * @private\n         */\n        let oldPointsStateId = [];\n        let stateIdCounter = 0;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /** @private */\n        function compose(highchartsDefaultOptions, ScatterSeriesClass) {\n            const scatterProto = ScatterSeriesClass.prototype;\n            if (!scatterProto.markerClusterAlgorithms) {\n                baseGeneratePoints = scatterProto.generatePoints;\n                scatterProto.markerClusterAlgorithms = markerClusterAlgorithms;\n                scatterProto.animateClusterPoint = seriesAnimateClusterPoint;\n                scatterProto.destroyClusteredData = seriesDestroyClusteredData;\n                scatterProto.generatePoints = seriesGeneratePoints;\n                scatterProto.getClusterDistancesFromPoint =\n                    seriesGetClusterDistancesFromPoint;\n                scatterProto.getClusteredData = seriesGetClusteredData;\n                scatterProto.getGridOffset = seriesGetGridOffset;\n                scatterProto.getPointsState = seriesGetPointsState;\n                scatterProto.getRealExtremes = seriesGetRealExtremes;\n                scatterProto.getScaledGridSize = seriesGetScaledGridSize;\n                scatterProto.hideClusteredData = seriesHideClusteredData;\n                scatterProto.isValidGroupedDataObject = seriesIsValidGroupedDataObject;\n                scatterProto.preventClusterCollisions = seriesPreventClusterCollisions;\n                // Destroy grouped data on series destroy.\n                addEvent(ScatterSeriesClass, 'destroy', scatterProto.destroyClusteredData);\n                (highchartsDefaultOptions.plotOptions || {}).series = merge((highchartsDefaultOptions.plotOptions || {}).series, MarkerClusterDefaults);\n            }\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function destroyOldPoints(oldState) {\n            if (oldState) {\n                let state;\n                for (const key of Object.keys(oldState)) {\n                    state = oldState[key];\n                    if (state.point && state.point.destroy) {\n                        state.point.destroy();\n                    }\n                }\n            }\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function fadeInElement(elem, opacity, animation) {\n            elem\n                .attr({\n                opacity: opacity\n            })\n                .animate({\n                opacity: 1\n            }, animation);\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function fadeInNewPointAndDestoryOld(newPointObj, oldPoints, animation, opacity) {\n            // Fade in new point.\n            fadeInStatePoint(newPointObj, opacity, animation, true, true);\n            // Destroy old animated points.\n            for (const p of oldPoints) {\n                if (p.point && p.point.destroy) {\n                    p.point.destroy();\n                }\n            }\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function fadeInStatePoint(stateObj, opacity, animation, fadeinGraphic, fadeinDataLabel) {\n            if (stateObj.point) {\n                if (fadeinGraphic && stateObj.point.graphic) {\n                    stateObj.point.graphic.show();\n                    fadeInElement(stateObj.point.graphic, opacity, animation);\n                }\n                if (fadeinDataLabel && stateObj.point.dataLabel) {\n                    stateObj.point.dataLabel.show();\n                    fadeInElement(stateObj.point.dataLabel, opacity, animation);\n                }\n            }\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function getClusterPosition(points) {\n            const pointsLen = points.length;\n            let sumX = 0, sumY = 0;\n            for (let i = 0; i < pointsLen; i++) {\n                sumX += points[i].x;\n                sumY += points[i].y;\n            }\n            return {\n                x: sumX / pointsLen,\n                y: sumY / pointsLen\n            };\n        }\n        /**\n         * Util function.Prepare array with sorted data objects to be compared in\n         * getPointsState method.\n         * @private\n         */\n        function getDataState(clusteredData, stateDataLen) {\n            const state = [];\n            state.length = stateDataLen;\n            clusteredData.clusters.forEach(function (cluster) {\n                cluster.data.forEach(function (elem) {\n                    state[elem.dataIndex] = elem;\n                });\n            });\n            clusteredData.noise.forEach(function (noise) {\n                state[noise.data[0].dataIndex] = noise.data[0];\n            });\n            return state;\n        }\n        /**\n         * Util function. Generate unique stateId for a state element.\n         * @private\n         */\n        function getStateId() {\n            return Math.random().toString(36).substring(2, 7) + '-' + stateIdCounter++;\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function hideStatePoint(stateObj, hideGraphic, hideDataLabel) {\n            if (stateObj.point) {\n                if (hideGraphic && stateObj.point.graphic) {\n                    stateObj.point.graphic.hide();\n                }\n                if (hideDataLabel && stateObj.point.dataLabel) {\n                    stateObj.point.dataLabel.hide();\n                }\n            }\n        }\n        /** @private */\n        function onPointDrillToCluster(event) {\n            const point = event.point || event.target;\n            point.firePointEvent('drillToCluster', event, function (e) {\n                const point = e.point || e.target, series = point.series, xAxis = point.series.xAxis, yAxis = point.series.yAxis, chart = point.series.chart, { inverted, mapView, pointer } = chart, clusterOptions = series.options.cluster, drillToCluster = (clusterOptions || {}).drillToCluster;\n                if (drillToCluster && point.clusteredData) {\n                    const sortedDataX = point.clusteredData\n                        .map((data) => data.x)\n                        .sort((a, b) => a - b), sortedDataY = point.clusteredData\n                        .map((data) => data.y)\n                        .sort((a, b) => a - b), minX = sortedDataX[0], maxX = sortedDataX[sortedDataX.length - 1], minY = sortedDataY[0], maxY = sortedDataY[sortedDataY.length - 1], offsetX = Math.abs((maxX - minX) * 0.1), offsetY = Math.abs((maxY - minY) * 0.1), x1 = Math.min(minX, maxX) - offsetX, x2 = Math.max(minX, maxX) + offsetX, y1 = Math.min(minY, maxY) - offsetY, y2 = Math.max(minY, maxY) + offsetY;\n                    if (mapView) {\n                        mapView.fitToBounds({ x1, x2, y1, y2 });\n                    }\n                    else if (xAxis && yAxis) {\n                        let x1Px = xAxis.toPixels(x1), x2Px = xAxis.toPixels(x2), y1Px = yAxis.toPixels(y1), y2Px = yAxis.toPixels(y2);\n                        if (inverted) {\n                            [x1Px, x2Px, y1Px, y2Px] = [y1Px, y2Px, x1Px, x2Px];\n                        }\n                        if (x1Px > x2Px) {\n                            [x1Px, x2Px] = [x2Px, x1Px];\n                        }\n                        if (y1Px > y2Px) {\n                            [y1Px, y2Px] = [y2Px, y1Px];\n                        }\n                        if (pointer) {\n                            pointer.zoomX = true;\n                            pointer.zoomY = true;\n                        }\n                        chart.transform({\n                            from: {\n                                x: x1Px,\n                                y: y1Px,\n                                width: x2Px - x1Px,\n                                height: y2Px - y1Px\n                            }\n                        });\n                    }\n                }\n            });\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function pixelsToValues(series, pos) {\n            const { chart, xAxis, yAxis } = series;\n            if (chart.mapView) {\n                return chart.mapView.pixelsToProjectedUnits(pos);\n            }\n            return {\n                x: xAxis ? xAxis.toValue(pos.x) : 0,\n                y: yAxis ? yAxis.toValue(pos.y) : 0\n            };\n        }\n        /** @private */\n        function seriesAnimateClusterPoint(clusterObj) {\n            const series = this, chart = series.chart, mapView = chart.mapView, clusterOptions = series.options.cluster, animation = animObject((clusterOptions || {}).animation), animDuration = animation.duration || 500, pointsState = (series.markerClusterInfo || {}).pointsState, newState = (pointsState || {}).newState, oldState = (pointsState || {}).oldState, oldPoints = [];\n            let parentId, oldPointObj, newPointObj, newPointBBox, offset = 0, newX = 0, newY = 0, isOldPointGrahic = false, isCbHandled = false;\n            if (oldState && newState) {\n                newPointObj = newState[clusterObj.stateId];\n                const newPos = valuesToPixels(series, newPointObj);\n                newX = newPos.x - (mapView ? 0 : chart.plotLeft);\n                newY = newPos.y - (mapView ? 0 : chart.plotTop);\n                // Point has one ancestor.\n                if (newPointObj.parentsId.length === 1) {\n                    parentId = (newState || {})[clusterObj.stateId].parentsId[0];\n                    oldPointObj = oldState[parentId];\n                    // If old and new positions are the same do not animate.\n                    if (newPointObj.point &&\n                        newPointObj.point.graphic &&\n                        oldPointObj &&\n                        oldPointObj.point &&\n                        oldPointObj.point.plotX &&\n                        oldPointObj.point.plotY &&\n                        oldPointObj.point.plotX !== newPointObj.point.plotX &&\n                        oldPointObj.point.plotY !== newPointObj.point.plotY) {\n                        newPointBBox = newPointObj.point.graphic.getBBox();\n                        // Marker image does not have the offset (#14342).\n                        offset = (newPointObj.point.graphic &&\n                            newPointObj.point.graphic.isImg) ?\n                            0 : newPointBBox.width / 2;\n                        newPointObj.point.graphic.attr({\n                            x: oldPointObj.point.plotX - offset,\n                            y: oldPointObj.point.plotY - offset\n                        });\n                        newPointObj.point.graphic.animate({\n                            x: newX - (newPointObj.point.graphic.radius || 0),\n                            y: newY - (newPointObj.point.graphic.radius || 0)\n                        }, animation, function () {\n                            isCbHandled = true;\n                            // Destroy old point.\n                            if (oldPointObj.point && oldPointObj.point.destroy) {\n                                oldPointObj.point.destroy();\n                            }\n                        });\n                        // Data label animation.\n                        if (newPointObj.point.dataLabel &&\n                            newPointObj.point.dataLabel.alignAttr &&\n                            oldPointObj.point.dataLabel &&\n                            oldPointObj.point.dataLabel.alignAttr) {\n                            newPointObj.point.dataLabel.attr({\n                                x: oldPointObj.point.dataLabel.alignAttr.x,\n                                y: oldPointObj.point.dataLabel.alignAttr.y\n                            });\n                            newPointObj.point.dataLabel.animate({\n                                x: newPointObj.point.dataLabel.alignAttr.x,\n                                y: newPointObj.point.dataLabel.alignAttr.y\n                            }, animation);\n                        }\n                    }\n                }\n                else if (newPointObj.parentsId.length === 0) {\n                    // Point has no ancestors - new point.\n                    // Hide new point.\n                    hideStatePoint(newPointObj, true, true);\n                    syncTimeout(function () {\n                        // Fade in new point.\n                        fadeInStatePoint(newPointObj, 0.1, animation, true, true);\n                    }, animDuration / 2);\n                }\n                else {\n                    // Point has many ancestors.\n                    // Hide new point before animation.\n                    hideStatePoint(newPointObj, true, true);\n                    newPointObj.parentsId.forEach(function (elem) {\n                        if (oldState && oldState[elem]) {\n                            oldPointObj = oldState[elem];\n                            oldPoints.push(oldPointObj);\n                            if (oldPointObj.point &&\n                                oldPointObj.point.graphic) {\n                                isOldPointGrahic = true;\n                                oldPointObj.point.graphic.show();\n                                oldPointObj.point.graphic.animate({\n                                    x: newX - (oldPointObj.point.graphic.radius || 0),\n                                    y: newY - (oldPointObj.point.graphic.radius || 0),\n                                    opacity: 0.4\n                                }, animation, function () {\n                                    isCbHandled = true;\n                                    fadeInNewPointAndDestoryOld(newPointObj, oldPoints, animation, 0.7);\n                                });\n                                if (oldPointObj.point.dataLabel &&\n                                    oldPointObj.point.dataLabel.y !== -9999 &&\n                                    newPointObj.point &&\n                                    newPointObj.point.dataLabel &&\n                                    newPointObj.point.dataLabel.alignAttr) {\n                                    oldPointObj.point.dataLabel.show();\n                                    oldPointObj.point.dataLabel.animate({\n                                        x: newPointObj.point.dataLabel.alignAttr.x,\n                                        y: newPointObj.point.dataLabel.alignAttr.y,\n                                        opacity: 0.4\n                                    }, animation);\n                                }\n                            }\n                        }\n                    });\n                    // Make sure point is faded in.\n                    syncTimeout(function () {\n                        if (!isCbHandled) {\n                            fadeInNewPointAndDestoryOld(newPointObj, oldPoints, animation, 0.85);\n                        }\n                    }, animDuration);\n                    if (!isOldPointGrahic) {\n                        syncTimeout(function () {\n                            fadeInNewPointAndDestoryOld(newPointObj, oldPoints, animation, 0.1);\n                        }, animDuration / 2);\n                    }\n                }\n            }\n        }\n        /**\n         * Destroy clustered data points.\n         * @private\n         */\n        function seriesDestroyClusteredData() {\n            const clusteredSeriesData = this.markerClusterSeriesData;\n            // Clear previous groups.\n            (clusteredSeriesData || []).forEach(function (point) {\n                if (point && point.destroy) {\n                    point.destroy();\n                }\n            });\n            this.markerClusterSeriesData = null;\n        }\n        /**\n         * Override the generatePoints method by adding a reference to grouped data.\n         * @private\n         */\n        function seriesGeneratePoints() {\n            const series = this, chart = series.chart, mapView = chart.mapView, xData = series.xData, yData = series.yData, clusterOptions = series.options.cluster, realExtremes = series.getRealExtremes(), visibleXData = [], visibleYData = [], visibleDataIndexes = [];\n            let oldPointsState, oldDataLen, oldMarkerClusterInfo, kmeansThreshold, cropDataOffsetX, cropDataOffsetY, seriesMinX, seriesMaxX, seriesMinY, seriesMaxY, type, algorithm, clusteredData, groupedData, layoutAlgOptions, point, i;\n            // For map point series, we need to resolve lon, lat and geometry options\n            // and project them on the plane in order to get x and y. In the regular\n            // series flow, this is not done until the `translate` method because the\n            // resulting [x, y] position depends on inset positions in the MapView.\n            if (mapView && series.is('mappoint') && xData && yData) {\n                (series.options.data || []).forEach((p, i) => {\n                    const xy = series.projectPoint(p);\n                    if (xy) {\n                        xData[i] = xy.x;\n                        yData[i] = xy.y;\n                    }\n                });\n            }\n            if (clusterOptions &&\n                clusterOptions.enabled &&\n                xData &&\n                xData.length &&\n                yData &&\n                yData.length &&\n                !chart.polar) {\n                type = clusterOptions.layoutAlgorithm.type;\n                layoutAlgOptions = clusterOptions.layoutAlgorithm;\n                // Get processed algorithm properties.\n                layoutAlgOptions.processedGridSize = relativeLength(layoutAlgOptions.gridSize ||\n                    clusterDefaults.layoutAlgorithm.gridSize, chart.plotWidth);\n                layoutAlgOptions.processedDistance = relativeLength(layoutAlgOptions.distance ||\n                    clusterDefaults.layoutAlgorithm.distance, chart.plotWidth);\n                kmeansThreshold = layoutAlgOptions.kmeansThreshold ||\n                    clusterDefaults.layoutAlgorithm.kmeansThreshold;\n                // Offset to prevent cluster size changes.\n                const halfGrid = layoutAlgOptions.processedGridSize / 2, p1 = pixelsToValues(series, { x: 0, y: 0 }), p2 = pixelsToValues(series, { x: halfGrid, y: halfGrid });\n                cropDataOffsetX = Math.abs(p1.x - p2.x);\n                cropDataOffsetY = Math.abs(p1.y - p2.y);\n                // Get only visible data.\n                for (i = 0; i < xData.length; i++) {\n                    if (!series.dataMaxX) {\n                        if (!defined(seriesMaxX) ||\n                            !defined(seriesMinX) ||\n                            !defined(seriesMaxY) ||\n                            !defined(seriesMinY)) {\n                            seriesMaxX = seriesMinX = xData[i];\n                            seriesMaxY = seriesMinY = yData[i];\n                        }\n                        else if (isNumber(yData[i]) &&\n                            isNumber(seriesMaxY) &&\n                            isNumber(seriesMinY)) {\n                            seriesMaxX = Math.max(xData[i], seriesMaxX);\n                            seriesMinX = Math.min(xData[i], seriesMinX);\n                            seriesMaxY = Math.max(yData[i] || seriesMaxY, seriesMaxY);\n                            seriesMinY = Math.min(yData[i] || seriesMinY, seriesMinY);\n                        }\n                    }\n                    // Crop data to visible ones with appropriate offset to prevent\n                    // cluster size changes on the edge of the plot area.\n                    if (xData[i] >= (realExtremes.minX - cropDataOffsetX) &&\n                        xData[i] <= (realExtremes.maxX + cropDataOffsetX) &&\n                        (yData[i] || realExtremes.minY) >=\n                            (realExtremes.minY - cropDataOffsetY) &&\n                        (yData[i] || realExtremes.maxY) <=\n                            (realExtremes.maxY + cropDataOffsetY)) {\n                        visibleXData.push(xData[i]);\n                        visibleYData.push(yData[i]);\n                        visibleDataIndexes.push(i);\n                    }\n                }\n                // Save data max values.\n                if (defined(seriesMaxX) && defined(seriesMinX) &&\n                    isNumber(seriesMaxY) && isNumber(seriesMinY)) {\n                    series.dataMaxX = seriesMaxX;\n                    series.dataMinX = seriesMinX;\n                    series.dataMaxY = seriesMaxY;\n                    series.dataMinY = seriesMinY;\n                }\n                if (isFunction(type)) {\n                    algorithm = type;\n                }\n                else if (series.markerClusterAlgorithms) {\n                    if (type && series.markerClusterAlgorithms[type]) {\n                        algorithm = series.markerClusterAlgorithms[type];\n                    }\n                    else {\n                        algorithm = visibleXData.length < kmeansThreshold ?\n                            series.markerClusterAlgorithms.kmeans :\n                            series.markerClusterAlgorithms.grid;\n                    }\n                }\n                else {\n                    algorithm = function () {\n                        return false;\n                    };\n                }\n                groupedData = algorithm.call(this, visibleXData, visibleYData, visibleDataIndexes, layoutAlgOptions);\n                clusteredData = groupedData ? series.getClusteredData(groupedData, clusterOptions) : groupedData;\n                // When animation is enabled get old points state.\n                if (clusterOptions.animation &&\n                    series.markerClusterInfo &&\n                    series.markerClusterInfo.pointsState &&\n                    series.markerClusterInfo.pointsState.oldState) {\n                    // Destroy old points.\n                    destroyOldPoints(series.markerClusterInfo.pointsState.oldState);\n                    oldPointsState = series.markerClusterInfo.pointsState.newState;\n                }\n                else {\n                    oldPointsState = {};\n                }\n                // Save points old state info.\n                oldDataLen = xData.length;\n                oldMarkerClusterInfo = series.markerClusterInfo;\n                if (clusteredData) {\n                    series.processedXData = clusteredData.groupedXData;\n                    series.processedYData = clusteredData.groupedYData;\n                    series.hasGroupedData = true;\n                    series.markerClusterInfo = clusteredData;\n                    series.groupMap = clusteredData.groupMap;\n                }\n                baseGeneratePoints.apply(this);\n                if (clusteredData && series.markerClusterInfo) {\n                    // Mark cluster points. Safe point reference in the cluster object.\n                    (series.markerClusterInfo.clusters || []).forEach(function (cluster) {\n                        point = series.points[cluster.index];\n                        point.isCluster = true;\n                        point.clusteredData = cluster.data;\n                        point.clusterPointsAmount = cluster.data.length;\n                        cluster.point = point;\n                        // Add zoom to cluster range.\n                        addEvent(point, 'click', onPointDrillToCluster);\n                    });\n                    // Safe point reference in the noise object.\n                    (series.markerClusterInfo.noise || []).forEach(function (noise) {\n                        noise.point = series.points[noise.index];\n                    });\n                    // When animation is enabled save points state.\n                    if (clusterOptions.animation &&\n                        series.markerClusterInfo) {\n                        series.markerClusterInfo.pointsState = {\n                            oldState: oldPointsState,\n                            newState: series.getPointsState(clusteredData, oldMarkerClusterInfo, oldDataLen)\n                        };\n                    }\n                    // Record grouped data in order to let it be destroyed the next time\n                    // processData runs.\n                    if (!clusterOptions.animation) {\n                        this.destroyClusteredData();\n                    }\n                    else {\n                        this.hideClusteredData();\n                    }\n                    this.markerClusterSeriesData =\n                        this.hasGroupedData ? this.points : null;\n                }\n            }\n            else {\n                baseGeneratePoints.apply(this);\n            }\n        }\n        /** @private */\n        function seriesGetClusterDistancesFromPoint(clusters, pointX, pointY) {\n            const pointClusterDistance = [];\n            for (let clusterIndex = 0; clusterIndex < clusters.length; clusterIndex++) {\n                const p1 = valuesToPixels(this, { x: pointX, y: pointY }), p2 = valuesToPixels(this, {\n                    x: clusters[clusterIndex].posX,\n                    y: clusters[clusterIndex].posY\n                }), distance = Math.sqrt(Math.pow(p1.x - p2.x, 2) +\n                    Math.pow(p1.y - p2.y, 2));\n                pointClusterDistance.push({ clusterIndex, distance });\n            }\n            return pointClusterDistance.sort((a, b) => a.distance - b.distance);\n        }\n        /** @private */\n        function seriesGetClusteredData(groupedData, options) {\n            const series = this, groupedXData = [], groupedYData = [], clusters = [], // Container for clusters.\n            noise = [], // Container for points not belonging to any cluster.\n            groupMap = [], \n            // Prevent minimumClusterSize lower than 2.\n            minimumClusterSize = Math.max(2, options.minimumClusterSize || 2);\n            let index = 0, stateId, point, points, pointUserOptions, pointsLen, marker, clusterPos, pointOptions, clusterTempPos, zoneOptions, clusterZone, clusterZoneClassName, i, k;\n            // Check if groupedData is valid when user uses a custom algorithm.\n            if (isFunction(options.layoutAlgorithm.type) &&\n                !series.isValidGroupedDataObject(groupedData)) {\n                error('Highcharts marker-clusters module: ' +\n                    'The custom algorithm result is not valid!', false, series.chart);\n                return false;\n            }\n            for (k in groupedData) {\n                if (groupedData[k].length >= minimumClusterSize) {\n                    points = groupedData[k];\n                    stateId = getStateId();\n                    pointsLen = points.length;\n                    // Get zone options for cluster.\n                    if (options.zones) {\n                        for (i = 0; i < options.zones.length; i++) {\n                            if (pointsLen >= options.zones[i].from &&\n                                pointsLen <= options.zones[i].to) {\n                                clusterZone = options.zones[i];\n                                clusterZone.zoneIndex = i;\n                                zoneOptions = options.zones[i].marker;\n                                clusterZoneClassName = options.zones[i].className;\n                            }\n                        }\n                    }\n                    clusterTempPos = getClusterPosition(points);\n                    if (options.layoutAlgorithm.type === 'grid' &&\n                        !options.allowOverlap) {\n                        marker = series.options.marker || {};\n                        clusterPos = series.preventClusterCollisions({\n                            x: clusterTempPos.x,\n                            y: clusterTempPos.y,\n                            key: k,\n                            groupedData: groupedData,\n                            gridSize: series.getScaledGridSize(options.layoutAlgorithm),\n                            defaultRadius: marker.radius || 3 + (marker.lineWidth || 0),\n                            clusterRadius: (zoneOptions && zoneOptions.radius) ?\n                                zoneOptions.radius :\n                                (options.marker || {}).radius ||\n                                    clusterDefaults.marker.radius\n                        });\n                    }\n                    else {\n                        clusterPos = {\n                            x: clusterTempPos.x,\n                            y: clusterTempPos.y\n                        };\n                    }\n                    for (i = 0; i < pointsLen; i++) {\n                        points[i].parentStateId = stateId;\n                    }\n                    clusters.push({\n                        x: clusterPos.x,\n                        y: clusterPos.y,\n                        id: k,\n                        stateId: stateId,\n                        index: index,\n                        data: points,\n                        clusterZone: clusterZone,\n                        clusterZoneClassName: clusterZoneClassName\n                    });\n                    groupedXData.push(clusterPos.x);\n                    groupedYData.push(clusterPos.y);\n                    groupMap.push({\n                        options: {\n                            formatPrefix: 'cluster',\n                            dataLabels: options.dataLabels,\n                            marker: merge(options.marker, {\n                                states: options.states\n                            }, zoneOptions || {})\n                        }\n                    });\n                    // Save cluster data points options.\n                    if (series.options.data && series.options.data.length) {\n                        for (i = 0; i < pointsLen; i++) {\n                            if (isObject(series.options.data[points[i].dataIndex])) {\n                                points[i].options =\n                                    series.options.data[points[i].dataIndex];\n                            }\n                        }\n                    }\n                    index++;\n                    zoneOptions = null;\n                }\n                else {\n                    for (i = 0; i < groupedData[k].length; i++) {\n                        // Points not belonging to any cluster.\n                        point = groupedData[k][i];\n                        stateId = getStateId();\n                        pointOptions = null;\n                        pointUserOptions =\n                            ((series.options || {}).data || [])[point.dataIndex];\n                        groupedXData.push(point.x);\n                        groupedYData.push(point.y);\n                        point.parentStateId = stateId;\n                        noise.push({\n                            x: point.x,\n                            y: point.y,\n                            id: k,\n                            stateId: stateId,\n                            index: index,\n                            data: groupedData[k]\n                        });\n                        if (pointUserOptions &&\n                            typeof pointUserOptions === 'object' &&\n                            !isArray(pointUserOptions)) {\n                            pointOptions = merge(pointUserOptions, { x: point.x, y: point.y });\n                        }\n                        else {\n                            pointOptions = {\n                                userOptions: pointUserOptions,\n                                x: point.x,\n                                y: point.y\n                            };\n                        }\n                        groupMap.push({ options: pointOptions });\n                        index++;\n                    }\n                }\n            }\n            return {\n                clusters: clusters,\n                noise: noise,\n                groupedXData: groupedXData,\n                groupedYData: groupedYData,\n                groupMap: groupMap\n            };\n        }\n        /** @private */\n        function seriesGetGridOffset() {\n            const series = this, chart = series.chart, xAxis = series.xAxis, yAxis = series.yAxis;\n            let plotLeft = 0, plotTop = 0;\n            if (xAxis && series.dataMinX && series.dataMaxX) {\n                plotLeft = xAxis.reversed ?\n                    xAxis.toPixels(series.dataMaxX) : xAxis.toPixels(series.dataMinX);\n            }\n            else {\n                plotLeft = chart.plotLeft;\n            }\n            if (yAxis && series.dataMinY && series.dataMaxY) {\n                plotTop = yAxis.reversed ?\n                    yAxis.toPixels(series.dataMinY) : yAxis.toPixels(series.dataMaxY);\n            }\n            else {\n                plotTop = chart.plotTop;\n            }\n            return { plotLeft, plotTop };\n        }\n        /**\n         * Point state used when animation is enabled to compare and bind old points\n         * with new ones.\n         * @private\n         */\n        function seriesGetPointsState(clusteredData, oldMarkerClusterInfo, dataLength) {\n            const oldDataStateArr = oldMarkerClusterInfo ?\n                getDataState(oldMarkerClusterInfo, dataLength) : [], newDataStateArr = getDataState(clusteredData, dataLength), state = {};\n            // Clear global array before populate with new ids.\n            oldPointsStateId = [];\n            // Build points state structure.\n            clusteredData.clusters.forEach(function (cluster) {\n                state[cluster.stateId] = {\n                    x: cluster.x,\n                    y: cluster.y,\n                    id: cluster.stateId,\n                    point: cluster.point,\n                    parentsId: []\n                };\n            });\n            clusteredData.noise.forEach(function (noise) {\n                state[noise.stateId] = {\n                    x: noise.x,\n                    y: noise.y,\n                    id: noise.stateId,\n                    point: noise.point,\n                    parentsId: []\n                };\n            });\n            let newState, oldState;\n            // Bind new and old state.\n            for (let i = 0; i < newDataStateArr.length; i++) {\n                newState = newDataStateArr[i];\n                oldState = oldDataStateArr[i];\n                if (newState &&\n                    oldState &&\n                    newState.parentStateId &&\n                    oldState.parentStateId &&\n                    state[newState.parentStateId] &&\n                    state[newState.parentStateId].parentsId.indexOf(oldState.parentStateId) === -1) {\n                    state[newState.parentStateId].parentsId.push(oldState.parentStateId);\n                    if (oldPointsStateId.indexOf(oldState.parentStateId) === -1) {\n                        oldPointsStateId.push(oldState.parentStateId);\n                    }\n                }\n            }\n            return state;\n        }\n        /** @private */\n        function seriesGetRealExtremes() {\n            const chart = this.chart, x = chart.mapView ? 0 : chart.plotLeft, y = chart.mapView ? 0 : chart.plotTop, p1 = pixelsToValues(this, {\n                x,\n                y\n            }), p2 = pixelsToValues(this, {\n                x: x + chart.plotWidth,\n                y: x + chart.plotHeight\n            }), realMinX = p1.x, realMaxX = p2.x, realMinY = p1.y, realMaxY = p2.y;\n            return {\n                minX: Math.min(realMinX, realMaxX),\n                maxX: Math.max(realMinX, realMaxX),\n                minY: Math.min(realMinY, realMaxY),\n                maxY: Math.max(realMinY, realMaxY)\n            };\n        }\n        /** @private */\n        function seriesGetScaledGridSize(options) {\n            const series = this, xAxis = series.xAxis, mapView = this.chart.mapView, processedGridSize = options.processedGridSize ||\n                clusterDefaults.layoutAlgorithm.gridSize;\n            let search = true, k = 1, divider = 1;\n            if (!series.gridValueSize) {\n                if (mapView) {\n                    series.gridValueSize = processedGridSize / mapView.getScale();\n                }\n                else {\n                    series.gridValueSize = Math.abs(xAxis.toValue(processedGridSize) - xAxis.toValue(0));\n                }\n            }\n            const gridSize = mapView ?\n                series.gridValueSize * mapView.getScale() :\n                xAxis.toPixels(series.gridValueSize) - xAxis.toPixels(0);\n            const scale = +(processedGridSize / gridSize).toFixed(14);\n            // Find the level and its divider.\n            while (search && scale !== 1) {\n                const level = Math.pow(2, k);\n                if (scale > 0.75 && scale < 1.25) {\n                    search = false;\n                }\n                else if (scale >= (1 / level) && scale < 2 * (1 / level)) {\n                    search = false;\n                    divider = level;\n                }\n                else if (scale <= level && scale > level / 2) {\n                    search = false;\n                    divider = 1 / level;\n                }\n                k++;\n            }\n            return (processedGridSize / divider) / scale;\n        }\n        /**\n         * Hide clustered data points.\n         * @private\n         */\n        function seriesHideClusteredData() {\n            const series = this, clusteredSeriesData = this.markerClusterSeriesData, oldState = ((series.markerClusterInfo || {}).pointsState || {}).oldState || {}, oldPointsId = oldPointsStateId.map((elem) => (oldState[elem].point || {}).id || '');\n            (clusteredSeriesData || []).forEach(function (point) {\n                // If an old point is used in animation hide it, otherwise destroy.\n                if (point &&\n                    oldPointsId.indexOf(point.id) !== -1) {\n                    if (point.graphic) {\n                        point.graphic.hide();\n                    }\n                    if (point.dataLabel) {\n                        point.dataLabel.hide();\n                    }\n                }\n                else {\n                    if (point && point.destroy) {\n                        point.destroy();\n                    }\n                }\n            });\n        }\n        /**\n         * Check if user algorithm result is valid groupedDataObject.\n         * @private\n         */\n        function seriesIsValidGroupedDataObject(groupedData) {\n            let result = false, i;\n            if (!isObject(groupedData)) {\n                return false;\n            }\n            objectEach(groupedData, function (elem) {\n                result = true;\n                if (!isArray(elem) || !elem.length) {\n                    result = false;\n                    return;\n                }\n                for (i = 0; i < elem.length; i++) {\n                    if (!isObject(elem[i]) || (!elem[i].x || !elem[i].y)) {\n                        result = false;\n                        return;\n                    }\n                }\n            });\n            return result;\n        }\n        /** @private */\n        function seriesPreventClusterCollisions(props) {\n            const series = this, [gridY, gridX] = props.key.split('-').map(parseFloat), gridSize = props.gridSize, groupedData = props.groupedData, defaultRadius = props.defaultRadius, clusterRadius = props.clusterRadius, gridXPx = gridX * gridSize, gridYPx = gridY * gridSize, propsPx = valuesToPixels(series, props), gridsToCheckCollision = [], clusterMarkerOptions = (series.options.cluster || {}).marker, zoneOptions = (series.options.cluster || {}).zones, gridOffset = series.getGridOffset();\n            let xPixel = propsPx.x, yPixel = propsPx.y, pointsLen = 0, radius = 0, nextXPixel, nextYPixel, signX, signY, cornerGridX, cornerGridY, i, j, itemX, itemY, nextClusterPos, maxDist, keys;\n            // Distance to the grid start.\n            xPixel -= gridOffset.plotLeft;\n            yPixel -= gridOffset.plotTop;\n            for (i = 1; i < 5; i++) {\n                signX = i % 2 ? -1 : 1;\n                signY = i < 3 ? -1 : 1;\n                cornerGridX = Math.floor((xPixel + signX * clusterRadius) / gridSize);\n                cornerGridY = Math.floor((yPixel + signY * clusterRadius) / gridSize);\n                keys = [\n                    cornerGridY + '-' + cornerGridX,\n                    cornerGridY + '-' + gridX,\n                    gridY + '-' + cornerGridX\n                ];\n                for (j = 0; j < keys.length; j++) {\n                    if (gridsToCheckCollision.indexOf(keys[j]) === -1 &&\n                        keys[j] !== props.key) {\n                        gridsToCheckCollision.push(keys[j]);\n                    }\n                }\n            }\n            for (const item of gridsToCheckCollision) {\n                if (groupedData[item]) {\n                    // Cluster or noise position is already computed.\n                    if (!groupedData[item].posX) {\n                        nextClusterPos = getClusterPosition(groupedData[item]);\n                        groupedData[item].posX = nextClusterPos.x;\n                        groupedData[item].posY = nextClusterPos.y;\n                    }\n                    const pos = valuesToPixels(series, {\n                        x: groupedData[item].posX || 0,\n                        y: groupedData[item].posY || 0\n                    });\n                    nextXPixel = pos.x - gridOffset.plotLeft;\n                    nextYPixel = pos.y - gridOffset.plotTop;\n                    [itemY, itemX] = item.split('-').map(parseFloat);\n                    if (zoneOptions) {\n                        pointsLen = groupedData[item].length;\n                        for (i = 0; i < zoneOptions.length; i++) {\n                            if (pointsLen >= zoneOptions[i].from &&\n                                pointsLen <= zoneOptions[i].to) {\n                                if (defined((zoneOptions[i].marker || {}).radius)) {\n                                    radius = zoneOptions[i].marker.radius || 0;\n                                }\n                                else if (clusterMarkerOptions &&\n                                    clusterMarkerOptions.radius) {\n                                    radius = clusterMarkerOptions.radius;\n                                }\n                                else {\n                                    radius =\n                                        clusterDefaults.marker.radius;\n                                }\n                            }\n                        }\n                    }\n                    if (groupedData[item].length > 1 &&\n                        radius === 0 &&\n                        clusterMarkerOptions &&\n                        clusterMarkerOptions.radius) {\n                        radius = clusterMarkerOptions.radius;\n                    }\n                    else if (groupedData[item].length === 1) {\n                        radius = defaultRadius;\n                    }\n                    maxDist = clusterRadius + radius;\n                    radius = 0;\n                    if (itemX !== gridX &&\n                        Math.abs(xPixel - nextXPixel) < maxDist) {\n                        xPixel = itemX - gridX < 0 ? gridXPx + clusterRadius :\n                            gridXPx + gridSize - clusterRadius;\n                    }\n                    if (itemY !== gridY &&\n                        Math.abs(yPixel - nextYPixel) < maxDist) {\n                        yPixel = itemY - gridY < 0 ? gridYPx + clusterRadius :\n                            gridYPx + gridSize - clusterRadius;\n                    }\n                }\n            }\n            const pos = pixelsToValues(series, {\n                x: xPixel + gridOffset.plotLeft,\n                y: yPixel + gridOffset.plotTop\n            });\n            groupedData[props.key].posX = pos.x;\n            groupedData[props.key].posY = pos.y;\n            return pos;\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function valuesToPixels(series, pos) {\n            const { chart, xAxis, yAxis } = series;\n            if (chart.mapView) {\n                return chart.mapView.projectedUnitsToPixels(pos);\n            }\n            return {\n                x: xAxis ? xAxis.toPixels(pos.x) : 0,\n                y: yAxis ? yAxis.toPixels(pos.y) : 0\n            };\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const MarkerClusterScatter = {\n            compose\n        };\n\n        return MarkerClusterScatter;\n    });\n    _registerModule(_modules, 'Extensions/MarkerClusters/MarkerClusters.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Defaults.js'], _modules['Core/Globals.js'], _modules['Extensions/MarkerClusters/MarkerClusterDefaults.js'], _modules['Extensions/MarkerClusters/MarkerClusterScatter.js'], _modules['Core/Utilities.js']], function (A, D, H, MarkerClusterDefaults, MarkerClusterScatter, U) {\n        /* *\n         *\n         *  Marker clusters module.\n         *\n         *  (c) 2010-2024 Torstein Honsi\n         *\n         *  Author: Wojciech Chmiel\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { animObject } = A;\n        const { defaultOptions } = D;\n        const { composed } = H;\n        const { addEvent, defined, error, isFunction, merge, pushUnique, syncTimeout } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        (defaultOptions.plotOptions || {}).series = merge((defaultOptions.plotOptions || {}).series, MarkerClusterDefaults);\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /** @private */\n        function compose(AxisClass, ChartClass, highchartsDefaultOptions, SeriesClass) {\n            if (pushUnique(composed, 'MarkerClusters')) {\n                const PointClass = SeriesClass.prototype.pointClass, { scatter: ScatterSeries } = SeriesClass.types;\n                addEvent(AxisClass, 'setExtremes', onAxisSetExtremes);\n                addEvent(ChartClass, 'render', onChartRender);\n                addEvent(PointClass, 'drillToCluster', onPointDrillToCluster);\n                addEvent(PointClass, 'update', onPointUpdate);\n                addEvent(SeriesClass, 'afterRender', onSeriesAfterRender);\n                if (ScatterSeries) {\n                    MarkerClusterScatter\n                        .compose(highchartsDefaultOptions, ScatterSeries);\n                }\n            }\n        }\n        /**\n         * Destroy the old tooltip after zoom.\n         * @private\n         */\n        function onAxisSetExtremes() {\n            const chart = this.chart;\n            let animationDuration = 0;\n            for (const series of chart.series) {\n                if (series.markerClusterInfo) {\n                    animationDuration = (animObject((series.options.cluster || {}).animation).duration ||\n                        0);\n                }\n            }\n            syncTimeout(() => {\n                if (chart.tooltip) {\n                    chart.tooltip.destroy();\n                }\n            }, animationDuration);\n        }\n        /**\n         * Handle animation.\n         * @private\n         */\n        function onChartRender() {\n            const chart = this;\n            for (const series of (chart.series || [])) {\n                if (series.markerClusterInfo) {\n                    const options = series.options.cluster, pointsState = (series.markerClusterInfo || {}).pointsState, oldState = (pointsState || {}).oldState;\n                    if ((options || {}).animation &&\n                        series.markerClusterInfo &&\n                        (series.chart.pointer?.pinchDown || []).length === 0 &&\n                        ((series.xAxis || {}).eventArgs || {}).trigger !== 'pan' &&\n                        oldState &&\n                        Object.keys(oldState).length) {\n                        for (const cluster of series.markerClusterInfo.clusters) {\n                            series.animateClusterPoint(cluster);\n                        }\n                        for (const noise of series.markerClusterInfo.noise) {\n                            series.animateClusterPoint(noise);\n                        }\n                    }\n                }\n            }\n        }\n        /** @private */\n        function onPointDrillToCluster(event) {\n            const point = event.point || event.target, series = point.series, clusterOptions = series.options.cluster, onDrillToCluster = ((clusterOptions || {}).events || {}).drillToCluster;\n            if (isFunction(onDrillToCluster)) {\n                onDrillToCluster.call(this, event);\n            }\n        }\n        /**\n         * Override point prototype to throw a warning when trying to update\n         * clustered point.\n         * @private\n         */\n        function onPointUpdate() {\n            const point = this;\n            if (point.dataGroup) {\n                error('Highcharts marker-clusters module: ' +\n                    'Running `Point.update` when point belongs to clustered series' +\n                    ' is not supported.', false, point.series.chart);\n                return false;\n            }\n        }\n        /**\n         * Add classes, change mouse cursor.\n         * @private\n         */\n        function onSeriesAfterRender() {\n            const series = this, clusterZoomEnabled = (series.options.cluster || {}).drillToCluster;\n            if (series.markerClusterInfo && series.markerClusterInfo.clusters) {\n                for (const cluster of series.markerClusterInfo.clusters) {\n                    if (cluster.point && cluster.point.graphic) {\n                        cluster.point.graphic.addClass('highcharts-cluster-point');\n                        // Change cursor to pointer when drillToCluster is enabled.\n                        if (clusterZoomEnabled && cluster.point) {\n                            cluster.point.graphic.css({\n                                cursor: 'pointer'\n                            });\n                            if (cluster.point.dataLabel) {\n                                cluster.point.dataLabel.css({\n                                    cursor: 'pointer'\n                                });\n                            }\n                        }\n                        if (defined(cluster.clusterZone)) {\n                            cluster.point.graphic.addClass(cluster.clusterZoneClassName ||\n                                'highcharts-cluster-zone-' +\n                                    cluster.clusterZone.zoneIndex);\n                        }\n                    }\n                }\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const MarkerClusters = {\n            compose\n        };\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * Function callback when a cluster is clicked.\n         *\n         * @callback Highcharts.MarkerClusterDrillCallbackFunction\n         *\n         * @param {Highcharts.Point} this\n         *        The point where the event occurred.\n         *\n         * @param {Highcharts.PointClickEventObject} event\n         *        Event arguments.\n         */\n        ''; // Keeps doclets above in JS file\n\n        return MarkerClusters;\n    });\n    _registerModule(_modules, 'Extensions/MarkerClusters/MarkerClusterSymbols.js', [], function () {\n        /* *\n         *\n         *  Marker clusters module.\n         *\n         *  (c) 2010-2024 Torstein Honsi\n         *\n         *  Author: Wojciech Chmiel\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Variables\n         *\n         * */\n        let symbols;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Cluster symbol.\n         * @private\n         */\n        function cluster(x, y, width, height) {\n            const w = width / 2, h = height / 2, outerWidth = 1, space = 1, inner = symbols.arc(x + w, y + h, w - space * 4, h - space * 4, {\n                start: Math.PI * 0.5,\n                end: Math.PI * 2.5,\n                open: false\n            }), outer1 = symbols.arc(x + w, y + h, w - space * 3, h - space * 3, {\n                start: Math.PI * 0.5,\n                end: Math.PI * 2.5,\n                innerR: w - outerWidth * 2,\n                open: false\n            }), outer2 = symbols.arc(x + w, y + h, w - space, h - space, {\n                start: Math.PI * 0.5,\n                end: Math.PI * 2.5,\n                innerR: w,\n                open: false\n            });\n            return outer2.concat(outer1, inner);\n        }\n        /**\n         * @private\n         */\n        function compose(SVGRendererClass) {\n            symbols = SVGRendererClass.prototype.symbols;\n            symbols.cluster = cluster;\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const MarkerClusterSymbols = {\n            compose\n        };\n\n        return MarkerClusterSymbols;\n    });\n    _registerModule(_modules, 'masters/modules/marker-clusters.src.js', [_modules['Core/Globals.js'], _modules['Extensions/MarkerClusters/MarkerClusters.js'], _modules['Extensions/MarkerClusters/MarkerClusterSymbols.js']], function (Highcharts, MarkerClusters, MarkerClusterSymbols) {\n\n        const G = Highcharts;\n        MarkerClusters.compose(G.Axis, G.Chart, G.defaultOptions, G.Series);\n        MarkerClusterSymbols.compose(G.SVGRenderer);\n\n        return Highcharts;\n    });\n}));\n"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","win","dispatchEvent","detail","cluster","enabled","allowOverlap","animation","duration","drillToCluster","minimumClusterSize","layoutAlgorithm","gridSize","distance","kmeansThreshold","marker","symbol","radius","lineWidth","lineColor","dataLabels","format","verticalAlign","align","style","color","inside","tooltip","clusterFormat","A","MarkerClusterDefaults","U","baseGeneratePoints","animObject","clusterDefaults","addEvent","defined","error","isArray","isFunction","isObject","isNumber","merge","objectEach","relativeLength","syncTimeout","markerClusterAlgorithms","grid","dataX","dataY","dataIndexes","options","x","y","gridX","key","i","gridOffset","getGridOffset","scaledGridSize","series","getScaledGridSize","length","p","valuesToPixels","plotLeft","plotTop","Math","floor","gridY","push","dataIndex","kmeans","clusters","noise","group","pointMaxDistance","processedDistance","iterations","currentIteration","repeat","pointX","pointY","tempPos","pointClusterDistance","processedGridSize","groupedData","call","getClusterPosition","posX","posY","oldX","oldY","startPointsLen","points","c","getClusterDistancesFromPoint","clusterIndex","iEnd","optimizedKmeans","processedXData","processedYData","extremes","getRealExtremes","clusterMarkerOptions","offset","markerClusterInfo","initMaxX","maxX","initMinX","minX","initMaxY","maxY","initMinY","minY","baseClusters","dataPoint","pointsOutside","pointsInside","data","dataPointPx","clusterPx","sqrt","pow","clusterZone","id","oldPointsStateId","stateIdCounter","fadeInElement","elem","opacity","attr","animate","fadeInNewPointAndDestoryOld","newPointObj","oldPoints","fadeInStatePoint","point","destroy","stateObj","fadeinGraphic","fadeinDataLabel","graphic","show","dataLabel","pointsLen","sumX","sumY","getDataState","clusteredData","stateDataLen","state","forEach","getStateId","random","toString","substring","hideStatePoint","hideGraphic","hideDataLabel","hide","onPointDrillToCluster","event","target","firePointEvent","e","xAxis","yAxis","chart","inverted","mapView","pointer","clusterOptions","sortedDataX","map","sort","a","b","sortedDataY","offsetX","abs","offsetY","x1","min","x2","max","y1","y2","fitToBounds","x1Px","toPixels","x2Px","y1Px","y2Px","zoomX","zoomY","transform","from","width","height","pixelsToValues","pos","pixelsToProjectedUnits","toValue","seriesAnimateClusterPoint","clusterObj","animDuration","pointsState","newState","oldState","oldPointObj","newPointBBox","newX","newY","isOldPointGrahic","isCbHandled","newPos","stateId","parentsId","plotX","plotY","getBBox","isImg","alignAttr","seriesDestroyClusteredData","clusteredSeriesData","markerClusterSeriesData","seriesGeneratePoints","oldPointsState","oldDataLen","oldMarkerClusterInfo","cropDataOffsetX","cropDataOffsetY","seriesMinX","seriesMaxX","seriesMinY","seriesMaxY","type","layoutAlgOptions","xData","yData","realExtremes","visibleXData","visibleYData","visibleDataIndexes","is","xy","projectPoint","polar","plotWidth","halfGrid","p1","p2","dataMaxX","dataMinX","dataMaxY","dataMinY","algorithm","getClusteredData","destroyOldPoints","Object","keys","groupedXData","groupedYData","hasGroupedData","groupMap","index","isCluster","clusterPointsAmount","getPointsState","hideClusteredData","destroyClusteredData","seriesGetClusterDistancesFromPoint","seriesGetClusteredData","pointUserOptions","clusterPos","pointOptions","clusterTempPos","zoneOptions","clusterZoneClassName","k","isValidGroupedDataObject","zones","to","zoneIndex","className","preventClusterCollisions","defaultRadius","clusterRadius","parentStateId","formatPrefix","states","userOptions","seriesGetGridOffset","reversed","seriesGetPointsState","dataLength","oldDataStateArr","newDataStateArr","indexOf","seriesGetRealExtremes","plotHeight","realMinX","realMaxX","realMinY","realMaxY","seriesGetScaledGridSize","search","divider","gridValueSize","getScale","scale","toFixed","level","seriesHideClusteredData","oldPointsId","seriesIsValidGroupedDataObject","result","seriesPreventClusterCollisions","props","split","parseFloat","gridXPx","gridYPx","propsPx","gridsToCheckCollision","xPixel","yPixel","nextXPixel","nextYPixel","signX","signY","cornerGridX","cornerGridY","j","itemX","itemY","nextClusterPos","maxDist","item","projectedUnitsToPixels","compose","highchartsDefaultOptions","ScatterSeriesClass","scatterProto","prototype","generatePoints","animateClusterPoint","plotOptions","D","H","MarkerClusterScatter","defaultOptions","composed","pushUnique","onAxisSetExtremes","animationDuration","onChartRender","pinchDown","eventArgs","trigger","onDrillToCluster","events","onPointUpdate","dataGroup","onSeriesAfterRender","clusterZoomEnabled","addClass","css","cursor","AxisClass","ChartClass","SeriesClass","PointClass","pointClass","scatter","ScatterSeries","types","symbols","w","h","inner","arc","space","start","PI","end","open","outer1","innerR","outerWidth","outer2","concat","SVGRendererClass","MarkerClusters","MarkerClusterSymbols","G","Axis","Chart","Series","SVGRenderer"],"mappings":"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"}
{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v11.4.8 (2024-08-29)\n *\n * Wind barb series module\n *\n * (c) 2010-2024 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/windbarb', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                Highcharts.win.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Extensions/DataGrouping/ApproximationRegistry.js', [], function () {\n        /* *\n         *\n         *  (c) 2010-2024 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        /**\n         * Define the available approximation types. The data grouping\n         * approximations takes an array or numbers as the first parameter. In case\n         * of ohlc, four arrays are sent in as four parameters. Each array consists\n         * only of numbers. In case null values belong to the group, the property\n         * .hasNulls will be set to true on the array.\n         *\n         * @product highstock\n         *\n         * @private\n         */\n        const ApproximationRegistry = {\n        // Approximations added programmatically\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ApproximationRegistry;\n    });\n    _registerModule(_modules, 'Series/OnSeriesComposition.js', [_modules['Series/Column/ColumnSeries.js'], _modules['Core/Globals.js'], _modules['Core/Series/Series.js'], _modules['Core/Utilities.js']], function (ColumnSeries, H, Series, U) {\n        /* *\n         *\n         *  (c) 2010-2024 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { composed } = H;\n        const { prototype: columnProto } = ColumnSeries;\n        const { prototype: seriesProto } = Series;\n        const { defined, pushUnique, stableSort } = U;\n        /* *\n         *\n         *  Composition\n         *\n         * */\n        var OnSeriesComposition;\n        (function (OnSeriesComposition) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * @private\n             */\n            function compose(SeriesClass) {\n                if (pushUnique(composed, 'OnSeries')) {\n                    const seriesProto = SeriesClass.prototype;\n                    seriesProto.getPlotBox = getPlotBox;\n                    seriesProto.translate = translate;\n                }\n                return SeriesClass;\n            }\n            OnSeriesComposition.compose = compose;\n            /**\n             * Override getPlotBox. If the onSeries option is valid, return the plot box\n             * of the onSeries, otherwise proceed as usual.\n             *\n             * @private\n             */\n            function getPlotBox(name) {\n                return seriesProto.getPlotBox.call((this.options.onSeries &&\n                    this.chart.get(this.options.onSeries)) || this, name);\n            }\n            OnSeriesComposition.getPlotBox = getPlotBox;\n            /**\n             * Extend the translate method by placing the point on the related series\n             *\n             * @private\n             */\n            function translate() {\n                columnProto.translate.apply(this);\n                const series = this, options = series.options, chart = series.chart, points = series.points, optionsOnSeries = options.onSeries, onSeries = (optionsOnSeries &&\n                    chart.get(optionsOnSeries)), step = onSeries && onSeries.options.step, onData = (onSeries && onSeries.points), inverted = chart.inverted, xAxis = series.xAxis, yAxis = series.yAxis;\n                let cursor = points.length - 1, point, lastPoint, onKey = options.onKey || 'y', i = onData && onData.length, xOffset = 0, leftPoint, lastX, rightPoint, currentDataGrouping, distanceRatio;\n                // Relate to a master series\n                if (onSeries && onSeries.visible && i) {\n                    xOffset = (onSeries.pointXOffset || 0) + (onSeries.barW || 0) / 2;\n                    currentDataGrouping = onSeries.currentDataGrouping;\n                    lastX = (onData[i - 1].x +\n                        (currentDataGrouping ? currentDataGrouping.totalRange : 0)); // #2374\n                    // sort the data points\n                    stableSort(points, (a, b) => (a.x - b.x));\n                    onKey = 'plot' + onKey[0].toUpperCase() + onKey.substr(1);\n                    while (i-- && points[cursor]) {\n                        leftPoint = onData[i];\n                        point = points[cursor];\n                        point.y = leftPoint.y;\n                        if (leftPoint.x <= point.x &&\n                            typeof leftPoint[onKey] !== 'undefined') {\n                            if (point.x <= lastX) { // #803\n                                point.plotY = leftPoint[onKey];\n                                // Interpolate between points, #666\n                                if (leftPoint.x < point.x &&\n                                    !step) {\n                                    rightPoint = onData[i + 1];\n                                    if (rightPoint &&\n                                        typeof rightPoint[onKey] !== 'undefined') {\n                                        // If the series is spline, calculate Y of the\n                                        // point on the bezier line. #19264\n                                        if (defined(point.plotX) &&\n                                            onSeries.is('spline')) {\n                                            leftPoint = leftPoint;\n                                            rightPoint = rightPoint;\n                                            const p0 = [\n                                                leftPoint.plotX || 0,\n                                                leftPoint.plotY || 0\n                                            ], p3 = [\n                                                rightPoint.plotX || 0,\n                                                rightPoint.plotY || 0\n                                            ], p1 = (leftPoint.controlPoints?.high ||\n                                                p0), p2 = (rightPoint.controlPoints?.low ||\n                                                p3), pixelThreshold = 0.25, maxIterations = 100, calculateCoord = (t, key) => (\n                                            // The parametric formula for the\n                                            // cubic Bezier curve.\n                                            Math.pow(1 - t, 3) * p0[key] +\n                                                3 * (1 - t) * (1 - t) * t *\n                                                    p1[key] + 3 * (1 - t) * t * t *\n                                                p2[key] + t * t * t * p3[key]);\n                                            let tMin = 0, tMax = 1, t;\n                                            // Find `t` of the parametric function of\n                                            // the bezier curve for the given `plotX`.\n                                            for (let i = 0; i < maxIterations; i++) {\n                                                const tMid = (tMin + tMax) / 2;\n                                                const xMid = calculateCoord(tMid, 0);\n                                                if (xMid === null) {\n                                                    break;\n                                                }\n                                                if (Math.abs(xMid - point.plotX) < pixelThreshold) {\n                                                    t = tMid;\n                                                    break;\n                                                }\n                                                if (xMid < point.plotX) {\n                                                    tMin = tMid;\n                                                }\n                                                else {\n                                                    tMax = tMid;\n                                                }\n                                            }\n                                            if (defined(t)) {\n                                                point.plotY =\n                                                    calculateCoord(t, 1);\n                                                point.y =\n                                                    yAxis.toValue(point.plotY, true);\n                                            }\n                                        }\n                                        else {\n                                            // The distance ratio, between 0 and 1\n                                            distanceRatio =\n                                                (point.x - leftPoint.x) /\n                                                    (rightPoint.x - leftPoint.x);\n                                            point.plotY +=\n                                                distanceRatio *\n                                                    // The plotY distance\n                                                    (rightPoint[onKey] - leftPoint[onKey]);\n                                            point.y +=\n                                                distanceRatio *\n                                                    (rightPoint.y - leftPoint.y);\n                                        }\n                                    }\n                                }\n                            }\n                            cursor--;\n                            i++; // Check again for points in the same x position\n                            if (cursor < 0) {\n                                break;\n                            }\n                        }\n                    }\n                }\n                // Add plotY position and handle stacking\n                points.forEach((point, i) => {\n                    let stackIndex;\n                    point.plotX += xOffset; // #2049\n                    // Undefined plotY means the point is either on axis, outside series\n                    // range or hidden series. If the series is outside the range of the\n                    // x axis it should fall through with an undefined plotY, but then\n                    // we must remove the shapeArgs (#847). For inverted charts, we need\n                    // to calculate position anyway, because series.invertGroups is not\n                    // defined\n                    if (typeof point.plotY === 'undefined' || inverted) {\n                        if (point.plotX >= 0 &&\n                            point.plotX <= xAxis.len) {\n                            // We're inside xAxis range\n                            if (inverted) {\n                                point.plotY = xAxis.translate(point.x, 0, 1, 0, 1);\n                                point.plotX = defined(point.y) ?\n                                    yAxis.translate(point.y, 0, 0, 0, 1) :\n                                    0;\n                            }\n                            else {\n                                point.plotY = (xAxis.opposite ? 0 : series.yAxis.len) +\n                                    xAxis.offset; // For the windbarb demo\n                            }\n                        }\n                        else {\n                            point.shapeArgs = {}; // 847\n                        }\n                    }\n                    // If multiple flags appear at the same x, order them into a stack\n                    lastPoint = points[i - 1];\n                    if (lastPoint && lastPoint.plotX === point.plotX) {\n                        if (typeof lastPoint.stackIndex === 'undefined') {\n                            lastPoint.stackIndex = 0;\n                        }\n                        stackIndex = lastPoint.stackIndex + 1;\n                    }\n                    point.stackIndex = stackIndex; // #3639\n                });\n                this.onSeries = onSeries;\n            }\n            OnSeriesComposition.translate = translate;\n        })(OnSeriesComposition || (OnSeriesComposition = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return OnSeriesComposition;\n    });\n    _registerModule(_modules, 'Series/Windbarb/WindbarbPoint.js', [_modules['Series/Column/ColumnSeries.js'], _modules['Core/Utilities.js']], function (ColumnSeries, U) {\n        /* *\n         *\n         *  Wind barb series module\n         *\n         *  (c) 2010-2024 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { isNumber } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        class WindbarbPoint extends ColumnSeries.prototype.pointClass {\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            isValid() {\n                return isNumber(this.value) && this.value >= 0;\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return WindbarbPoint;\n    });\n    _registerModule(_modules, 'Series/Windbarb/WindbarbSeriesDefaults.js', [], function () {\n        /* *\n         *\n         *  Wind barb series module\n         *\n         *  (c) 2010-2024 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * Wind barbs are a convenient way to represent wind speed and direction in\n         * one graphical form. Wind direction is given by the stem direction, and\n         * wind speed by the number and shape of barbs.\n         *\n         * @sample {highcharts|highstock} highcharts/demo/windbarb-series/\n         *         Wind barb series\n         *\n         * @extends      plotOptions.column\n         * @excluding    boostThreshold, marker, connectEnds, connectNulls,\n         *               cropThreshold, dashStyle, dragDrop, gapSize, gapUnit,\n         *               linecap, shadow, stacking, step, boostBlending\n         * @since        6.0.0\n         * @product      highcharts highstock\n         * @requires     modules/windbarb\n         * @optionparent plotOptions.windbarb\n         */\n        const WindbarbSeriesDefaults = {\n            /**\n             * Data grouping options for the wind barbs. In Highcharts, this\n             * requires the `modules/datagrouping.js` module to be loaded. In\n             * Highcharts Stock, data grouping is included.\n             *\n             * @sample  highcharts/plotoptions/windbarb-datagrouping\n             *          Wind barb with data grouping\n             *\n             * @since   7.1.0\n             * @product highcharts highstock\n             */\n            dataGrouping: {\n                /**\n                 * Whether to enable data grouping.\n                 *\n                 * @product highcharts highstock\n                 */\n                enabled: true,\n                /**\n                 * Approximation function for the data grouping. The default\n                 * returns an average of wind speed and a vector average direction\n                 * weighted by wind speed.\n                 *\n                 * @product highcharts highstock\n                 *\n                 * @type {string|Function}\n                 */\n                approximation: 'windbarb',\n                /**\n                 * The approximate data group width.\n                 *\n                 * @product highcharts highstock\n                 */\n                groupPixelWidth: 30\n            },\n            /**\n             * The line width of the wind barb symbols.\n             */\n            lineWidth: 2,\n            /**\n             * The id of another series in the chart that the wind barbs are\n             * projected on. When `null`, the wind symbols are drawn on the X axis,\n             * but offset up or down by the `yOffset` setting.\n             *\n             * @sample {highcharts|highstock} highcharts/plotoptions/windbarb-onseries\n             *         Projected on area series\n             *\n             * @type {string|null}\n             */\n            onSeries: null,\n            states: {\n                hover: {\n                    lineWidthPlus: 0\n                }\n            },\n            tooltip: {\n                /**\n                 * The default point format for the wind barb tooltip. Note the\n                 * `point.beaufort` property that refers to the Beaufort wind scale.\n                 * The names can be internationalized by modifying\n                 * `Highcharts.seriesTypes.windbarb.prototype.beaufortNames`.\n                 */\n                pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.value}</b> ({point.beaufort})<br/>'\n            },\n            /**\n             * Pixel length of the stems.\n             */\n            vectorLength: 20,\n            /**\n             * @default   value\n             */\n            colorKey: 'value',\n            /**\n             * Vertical offset from the cartesian position, in pixels. The default\n             * value makes sure the symbols don't overlap the X axis when `onSeries`\n             * is `null`, and that they don't overlap the linked series when\n             * `onSeries` is given.\n             */\n            yOffset: -20,\n            /**\n             * Horizontal offset from the cartesian position, in pixels. When the\n             * chart is inverted, this option allows translation like\n             * [yOffset](#plotOptions.windbarb.yOffset) in non inverted charts.\n             *\n             * @since 6.1.0\n             */\n            xOffset: 0\n        };\n        /**\n         * A `windbarb` series. If the [type](#series.windbarb.type) option is not\n         * specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.windbarb\n         * @excluding dataParser, dataURL, boostThreshold, boostBlending\n         * @product   highcharts highstock\n         * @requires  modules/windbarb\n         * @apioption series.windbarb\n         */\n        /**\n         * An array of data points for the series. For the `windbarb` series type,\n         * points can be given in the following ways:\n         *\n         * 1. An array of arrays with 3 values. In this case, the values correspond to\n         *    `x,value,direction`. If the first value is a string, it is applied as the\n         *    name of the point, and the `x` value is inferred.\n         *    ```js\n         *       data: [\n         *           [Date.UTC(2017, 0, 1, 0), 3.3, 90],\n         *           [Date.UTC(2017, 0, 1, 1), 12.1, 180],\n         *           [Date.UTC(2017, 0, 1, 2), 11.1, 270]\n         *       ]\n         *    ```\n         *\n         * 2. An array of objects with named values. The following snippet shows only a\n         *    few settings, see the complete options set below. If the total number of\n         *    data points exceeds the series'\n         *    [turboThreshold](#series.area.turboThreshold), this option is not\n         *    available.\n         *    ```js\n         *       data: [{\n         *           x: Date.UTC(2017, 0, 1, 0),\n         *           value: 12.1,\n         *           direction: 90\n         *       }, {\n         *           x: Date.UTC(2017, 0, 1, 1),\n         *           value: 11.1,\n         *           direction: 270\n         *       }]\n         *    ```\n         *\n         * @sample {highcharts} highcharts/chart/reflow-true/\n         *         Numerical values\n         * @sample {highcharts} highcharts/series/data-array-of-arrays/\n         *         Arrays of numeric x and y\n         * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n         *         Arrays of datetime x and y\n         * @sample {highcharts} highcharts/series/data-array-of-name-value/\n         *         Arrays of point.name and y\n         * @sample {highcharts} highcharts/series/data-array-of-objects/\n         *         Config objects\n         *\n         * @type      {Array<Array<(number|string),number,number>|*>}\n         * @extends   series.line.data\n         * @product   highcharts highstock\n         * @apioption series.windbarb.data\n         */\n        /**\n         * The wind speed in meters per second.\n         *\n         * @type      {number|null}\n         * @product   highcharts highstock\n         * @apioption series.windbarb.data.value\n         */\n        /**\n         * The wind direction in degrees, where 0 is north (pointing towards south).\n         *\n         * @type      {number}\n         * @product   highcharts highstock\n         * @apioption series.windbarb.data.direction\n         */\n        ''; // Adds doclets above to transpiled file\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return WindbarbSeriesDefaults;\n    });\n    _registerModule(_modules, 'Series/Windbarb/WindbarbSeries.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Extensions/DataGrouping/ApproximationRegistry.js'], _modules['Core/Globals.js'], _modules['Series/OnSeriesComposition.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js'], _modules['Series/Windbarb/WindbarbPoint.js'], _modules['Series/Windbarb/WindbarbSeriesDefaults.js']], function (A, ApproximationRegistry, H, OnSeriesComposition, SeriesRegistry, U, WindbarbPoint, WindbarbSeriesDefaults) {\n        /* *\n         *\n         *  Wind barb series module\n         *\n         *  (c) 2010-2024 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { animObject } = A;\n        const { column: ColumnSeries } = SeriesRegistry.seriesTypes;\n        const { extend, merge, pick } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Once off, register the windbarb approximation for data grouping. This can\n         * be called anywhere (not necessarily in the translate function), but must\n         * happen after the data grouping module is loaded and before the\n         * wind barb series uses it.\n         * @private\n         */\n        function registerApproximation() {\n            if (!ApproximationRegistry.windbarb) {\n                ApproximationRegistry.windbarb = (values, directions) => {\n                    let vectorX = 0, vectorY = 0;\n                    for (let i = 0, iEnd = values.length; i < iEnd; i++) {\n                        vectorX += values[i] * Math.cos(directions[i] * H.deg2rad);\n                        vectorY += values[i] * Math.sin(directions[i] * H.deg2rad);\n                    }\n                    return [\n                        // Wind speed\n                        values.reduce((sum, value) => (sum + value), 0) / values.length,\n                        // Wind direction\n                        Math.atan2(vectorY, vectorX) / H.deg2rad\n                    ];\n                };\n            }\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.windbarb\n         *\n         * @augments Highcharts.Series\n         */\n        class WindbarbSeries extends ColumnSeries {\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            init(chart, options) {\n                super.init(chart, options);\n            }\n            // Get presentational attributes.\n            pointAttribs(point, state) {\n                const options = this.options;\n                let stroke = point.color || this.color, strokeWidth = this.options.lineWidth;\n                if (state) {\n                    stroke = options.states[state].color || stroke;\n                    strokeWidth =\n                        (options.states[state].lineWidth || strokeWidth) +\n                            (options.states[state].lineWidthPlus || 0);\n                }\n                return {\n                    'stroke': stroke,\n                    'stroke-width': strokeWidth\n                };\n            }\n            // Create a single wind arrow. It is later rotated around the zero\n            // centerpoint.\n            windArrow(point) {\n                const level = point.beaufortLevel, u = this.options.vectorLength / 20;\n                let knots = point.value * 1.943844, barbs, pos = -10;\n                if (point.isNull) {\n                    return [];\n                }\n                if (level === 0) {\n                    return this.chart.renderer.symbols.circle(-10 * u, -10 * u, 20 * u, 20 * u);\n                }\n                // The stem and the arrow head\n                const path = [\n                    ['M', 0, 7 * u], // Base of arrow\n                    ['L', -1.5 * u, 7 * u],\n                    ['L', 0, 10 * u],\n                    ['L', 1.5 * u, 7 * u],\n                    ['L', 0, 7 * u],\n                    ['L', 0, -10 * u] // Top\n                ];\n                // For each full 50 knots, add a pennant\n                barbs = (knots - knots % 50) / 50; // Pennants\n                if (barbs > 0) {\n                    while (barbs--) {\n                        path.push(pos === -10 ? ['L', 0, pos * u] : ['M', 0, pos * u], ['L', 5 * u, pos * u + 2], ['L', 0, pos * u + 4]);\n                        // Substract from the rest and move position for next\n                        knots -= 50;\n                        pos += 7;\n                    }\n                }\n                // For each full 10 knots, add a full barb\n                barbs = (knots - knots % 10) / 10;\n                if (barbs > 0) {\n                    while (barbs--) {\n                        path.push(pos === -10 ? ['L', 0, pos * u] : ['M', 0, pos * u], ['L', 7 * u, pos * u]);\n                        knots -= 10;\n                        pos += 3;\n                    }\n                }\n                // For each full 5 knots, add a half barb\n                barbs = (knots - knots % 5) / 5; // Half barbs\n                if (barbs > 0) {\n                    while (barbs--) {\n                        path.push(pos === -10 ? ['L', 0, pos * u] : ['M', 0, pos * u], ['L', 4 * u, pos * u]);\n                        knots -= 5;\n                        pos += 3;\n                    }\n                }\n                return path;\n            }\n            drawPoints() {\n                const chart = this.chart, yAxis = this.yAxis, inverted = chart.inverted, shapeOffset = this.options.vectorLength / 2;\n                for (const point of this.points) {\n                    const plotX = point.plotX, plotY = point.plotY;\n                    // Check if it's inside the plot area, but only for the X\n                    // dimension.\n                    if (this.options.clip === false ||\n                        chart.isInsidePlot(plotX, 0)) {\n                        // Create the graphic the first time\n                        if (!point.graphic) {\n                            point.graphic = this.chart.renderer\n                                .path()\n                                .add(this.markerGroup)\n                                .addClass('highcharts-point ' +\n                                'highcharts-color-' +\n                                pick(point.colorIndex, point.series.colorIndex));\n                        }\n                        // Position the graphic\n                        point.graphic\n                            .attr({\n                            d: this.windArrow(point),\n                            translateX: plotX + this.options.xOffset,\n                            translateY: plotY + this.options.yOffset,\n                            rotation: point.direction\n                        });\n                        if (!this.chart.styledMode) {\n                            point.graphic\n                                .attr(this.pointAttribs(point));\n                        }\n                    }\n                    else if (point.graphic) {\n                        point.graphic = point.graphic.destroy();\n                    }\n                    // Set the tooltip anchor position\n                    point.tooltipPos = [\n                        plotX + this.options.xOffset +\n                            (inverted && !this.onSeries ? shapeOffset : 0),\n                        plotY + this.options.yOffset -\n                            (inverted ?\n                                0 :\n                                shapeOffset + yAxis.pos - chart.plotTop)\n                    ]; // #6327\n                }\n            }\n            // Fade in the arrows on initializing series.\n            animate(init) {\n                if (init) {\n                    this.markerGroup.attr({\n                        opacity: 0.01\n                    });\n                }\n                else {\n                    this.markerGroup.animate({\n                        opacity: 1\n                    }, animObject(this.options.animation));\n                }\n            }\n            markerAttribs() {\n                return {};\n            }\n            getExtremes() {\n                return {};\n            }\n            shouldShowTooltip(plotX, plotY, options = {}) {\n                options.ignoreX = this.chart.inverted;\n                options.ignoreY = !options.ignoreX;\n                return super.shouldShowTooltip(plotX, plotY, options);\n            }\n        }\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        WindbarbSeries.defaultOptions = merge(ColumnSeries.defaultOptions, WindbarbSeriesDefaults);\n        OnSeriesComposition.compose(WindbarbSeries);\n        extend(WindbarbSeries.prototype, {\n            beaufortFloor: [\n                0, 0.3, 1.6, 3.4, 5.5, 8.0, 10.8, 13.9, 17.2, 20.8,\n                24.5, 28.5, 32.7\n            ], // @todo dictionary with names?\n            beaufortName: [\n                'Calm', 'Light air', 'Light breeze',\n                'Gentle breeze', 'Moderate breeze', 'Fresh breeze',\n                'Strong breeze', 'Near gale', 'Gale', 'Strong gale', 'Storm',\n                'Violent storm', 'Hurricane'\n            ],\n            invertible: false,\n            parallelArrays: ['x', 'value', 'direction'],\n            pointArrayMap: ['value', 'direction'],\n            pointClass: WindbarbPoint,\n            trackerGroups: ['markerGroup'],\n            translate: function () {\n                const beaufortFloor = this.beaufortFloor, beaufortName = this.beaufortName;\n                OnSeriesComposition.translate.call(this);\n                for (const point of this.points) {\n                    let level = 0;\n                    // Find the beaufort level (zero based)\n                    for (; level < beaufortFloor.length; level++) {\n                        if (beaufortFloor[level] > point.value) {\n                            break;\n                        }\n                    }\n                    point.beaufortLevel = level - 1;\n                    point.beaufort = beaufortName[level - 1];\n                }\n            }\n        });\n        SeriesRegistry.registerSeriesType('windbarb', WindbarbSeries);\n        registerApproximation();\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return WindbarbSeries;\n    });\n    _registerModule(_modules, 'masters/modules/windbarb.src.js', [_modules['Core/Globals.js']], function (Highcharts) {\n\n\n        return Highcharts;\n    });\n}));\n"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","win","dispatchEvent","detail","ColumnSeries","H","Series","U","OnSeriesComposition","composed","prototype","columnProto","seriesProto","defined","pushUnique","stableSort","getPlotBox","name","call","options","onSeries","chart","get","translate","series","points","optionsOnSeries","step","onData","inverted","xAxis","yAxis","cursor","length","point","lastPoint","onKey","i","xOffset","leftPoint","lastX","rightPoint","currentDataGrouping","distanceRatio","visible","pointXOffset","barW","x","totalRange","a","b","toUpperCase","substr","y","plotY","plotX","is","p0","p3","p1","controlPoints","high","p2","low","calculateCoord","t","key","Math","pow","tMin","tMax","tMid","xMid","abs","toValue","forEach","stackIndex","len","opposite","offset","shapeArgs","compose","SeriesClass","isNumber","WindbarbPoint","pointClass","isValid","value","dataGrouping","enabled","approximation","groupPixelWidth","lineWidth","states","hover","lineWidthPlus","tooltip","pointFormat","vectorLength","colorKey","yOffset","A","ApproximationRegistry","SeriesRegistry","WindbarbSeriesDefaults","animObject","column","seriesTypes","extend","merge","pick","WindbarbSeries","init","pointAttribs","state","stroke","color","strokeWidth","windArrow","level","beaufortLevel","u","knots","barbs","pos","isNull","renderer","symbols","circle","push","drawPoints","shapeOffset","clip","isInsidePlot","graphic","add","markerGroup","addClass","colorIndex","attr","d","translateX","translateY","rotation","direction","styledMode","destroy","tooltipPos","plotTop","animate","opacity","animation","markerAttribs","getExtremes","shouldShowTooltip","ignoreX","ignoreY","defaultOptions","beaufortFloor","beaufortName","invertible","parallelArrays","pointArrayMap","trackerGroups","beaufort","registerSeriesType","windbarb","values","directions","vectorX","vectorY","iEnd","cos","deg2rad","sin","reduce","sum","atan2"],"mappings":"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"}
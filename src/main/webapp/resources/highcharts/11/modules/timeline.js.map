{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v11.4.8 (2024-08-29)\n *\n * Timeline series\n *\n * (c) 2010-2024 Highsoft AS\n * Author: Daniel Studencki\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/timeline', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                Highcharts.win.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Series/Timeline/TimelinePoint.js', [_modules['Core/Series/Point.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (Point, SeriesRegistry, U) {\n        /* *\n         *\n         *  Timeline Series.\n         *\n         *  (c) 2010-2024 Highsoft AS\n         *\n         *  Author: Daniel Studencki\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { line: { prototype: { pointClass: LinePoint } }, pie: { prototype: { pointClass: PiePoint } } } = SeriesRegistry.seriesTypes;\n        const { defined, isNumber, merge, objectEach, pick } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        class TimelinePoint extends LinePoint {\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            alignConnector() {\n                const point = this, series = point.series, dataLabel = point.dataLabel, connector = dataLabel.connector, dlOptions = (dataLabel.options || {}), connectorWidth = dlOptions.connectorWidth || 0, chart = point.series.chart, bBox = connector.getBBox(), plotPos = {\n                    x: bBox.x + (dataLabel.translateX || 0),\n                    y: bBox.y + (dataLabel.translateY || 0)\n                };\n                // Include a half of connector width in order to run animation,\n                // when connectors are aligned to the plot area edge.\n                if (chart.inverted) {\n                    plotPos.y -= connectorWidth / 2;\n                }\n                else {\n                    plotPos.x += connectorWidth / 2;\n                }\n                const isVisible = chart.isInsidePlot(plotPos.x, plotPos.y);\n                connector[isVisible ? 'animate' : 'attr']({\n                    d: point.getConnectorPath()\n                });\n                connector.addClass('highcharts-color-' + point.colorIndex);\n                if (!series.chart.styledMode) {\n                    connector.attr({\n                        stroke: dlOptions.connectorColor || point.color,\n                        'stroke-width': dlOptions.connectorWidth,\n                        opacity: dataLabel[defined(dataLabel.newOpacity) ? 'newOpacity' : 'opacity']\n                    });\n                }\n            }\n            drawConnector() {\n                const point = this, { dataLabel, series } = point;\n                if (dataLabel) {\n                    if (!dataLabel.connector) {\n                        dataLabel.connector = series.chart.renderer\n                            .path(point.getConnectorPath())\n                            .attr({\n                            zIndex: -1\n                        })\n                            .add(dataLabel);\n                    }\n                    if (point.series.chart.isInsidePlot(// #10507\n                    dataLabel.x || 0, dataLabel.y || 0)) {\n                        point.alignConnector();\n                    }\n                }\n            }\n            getConnectorPath() {\n                const { plotX = 0, plotY = 0, series, dataLabel } = this, chart = series.chart, xAxisLen = series.xAxis.len, inverted = chart.inverted, direction = inverted ? 'x2' : 'y2';\n                if (dataLabel) {\n                    const targetDLPos = dataLabel.targetPosition, negativeDistance = ((dataLabel.alignAttr || dataLabel)[direction[0]] <\n                        series.yAxis.len / 2);\n                    let coords = {\n                        x1: plotX,\n                        y1: plotY,\n                        x2: plotX,\n                        y2: isNumber(targetDLPos.y) ? targetDLPos.y : dataLabel.y\n                    };\n                    // Recalculate coords when the chart is inverted.\n                    if (inverted) {\n                        coords = {\n                            x1: plotY,\n                            y1: xAxisLen - plotX,\n                            x2: targetDLPos.x || dataLabel.x,\n                            y2: xAxisLen - plotX\n                        };\n                    }\n                    // Subtract data label width or height from expected coordinate so\n                    // that the connector would start from the appropriate edge.\n                    if (negativeDistance) {\n                        coords[direction] += dataLabel[inverted ? 'width' : 'height'] || 0;\n                    }\n                    // Change coordinates so that they will be relative to data label.\n                    objectEach(coords, (_coord, i) => {\n                        coords[i] -= (dataLabel.alignAttr || dataLabel)[i[0]];\n                    });\n                    return chart.renderer.crispLine([\n                        ['M', coords.x1, coords.y1],\n                        ['L', coords.x2, coords.y2]\n                    ], dataLabel.options?.connectorWidth || 0);\n                }\n                return [];\n            }\n            constructor(series, options) {\n                super(series, options);\n                this.name ?? (this.name = 'Event');\n                this.y = 1;\n            }\n            isValid() {\n                return this.options.y !== null;\n            }\n            setState() {\n                const proceed = super.setState;\n                // Prevent triggering the setState method on null points.\n                if (!this.isNull) {\n                    proceed.apply(this, arguments);\n                }\n            }\n            setVisible(visible, redraw) {\n                const point = this, series = point.series;\n                redraw = pick(redraw, series.options.ignoreHiddenPoint);\n                PiePoint.prototype.setVisible.call(point, visible, false);\n                // Process new data\n                series.processData();\n                if (redraw) {\n                    series.chart.redraw();\n                }\n            }\n            applyOptions(options, x) {\n                options = Point.prototype.optionsToObject.call(this, options);\n                this.userDLOptions = merge(this.userDLOptions, options.dataLabels);\n                return super.applyOptions(options, x);\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return TimelinePoint;\n    });\n    _registerModule(_modules, 'Series/Timeline/TimelineSeriesDefaults.js', [], function () {\n        /* *\n         *\n         *  Timeline Series.\n         *\n         *  (c) 2010-2024 Highsoft AS\n         *\n         *  Author: Daniel Studencki\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * The timeline series presents given events along a drawn line.\n         *\n         * @sample highcharts/series-timeline/alternate-labels\n         *         Timeline series\n         * @sample highcharts/series-timeline/inverted\n         *         Inverted timeline\n         * @sample highcharts/series-timeline/datetime-axis\n         *         With true datetime axis\n         *\n         * @extends      plotOptions.line\n         * @excluding    animationLimit, boostThreshold, connectEnds, connectNulls,\n         *               cropThreshold, dashStyle, findNearestPointBy,\n         *               getExtremesFromAll, negativeColor, pointInterval,\n         *               pointIntervalUnit, pointPlacement, pointStart,\n         *               softThreshold, stacking, step, threshold, turboThreshold,\n         *               zoneAxis, zones, dataSorting, boostBlending\n         * @product      highcharts\n         * @since        7.0.0\n         * @requires     modules/timeline\n         * @optionparent plotOptions.timeline\n         */\n        const TimelineSeriesDefaults = {\n            colorByPoint: true,\n            stickyTracking: false,\n            ignoreHiddenPoint: true,\n            /**\n             * @ignore\n             */\n            legendType: 'point',\n            /**\n             * Pixel width of the graph line.\n             */\n            lineWidth: 4,\n            tooltip: {\n                headerFormat: '<span style=\"color:{point.color}\">\\u25CF</span> ' +\n                    '<span style=\"font-size: 0.8em\"> {point.key}</span><br/>',\n                pointFormat: '{point.description}'\n            },\n            states: {\n                hover: {\n                    lineWidthPlus: 0\n                }\n            },\n            /**\n             * @declare Highcharts.TimelineDataLabelsOptionsObject\n             */\n            dataLabels: {\n                enabled: true,\n                allowOverlap: true,\n                /**\n                 * Whether to position data labels alternately. For example, if\n                 * [distance](#plotOptions.timeline.dataLabels.distance)\n                 * is set equal to `100`, then data labels will be positioned\n                 * alternately (on both sides of the point) at a distance of 100px.\n                 *\n                 * @sample {highcharts} highcharts/series-timeline/alternate-disabled\n                 *         Alternate disabled\n                 */\n                alternate: true,\n                backgroundColor: \"#ffffff\" /* Palette.backgroundColor */,\n                borderWidth: 1,\n                borderColor: \"#999999\" /* Palette.neutralColor40 */,\n                borderRadius: 3,\n                color: \"#333333\" /* Palette.neutralColor80 */,\n                /**\n                 * The color of the line connecting the data label to the point.\n                 * The default color is the same as the point's color.\n                 *\n                 * In styled mode, the connector stroke is given in the\n                 * `.highcharts-data-label-connector` class.\n                 *\n                 * @sample {highcharts} highcharts/series-timeline/connector-styles\n                 *         Custom connector width and color\n                 *\n                 * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 * @apioption plotOptions.timeline.dataLabels.connectorColor\n                 */\n                /**\n                 * The width of the line connecting the data label to the point.\n                 *\n                 * In styled mode, the connector stroke width is given in the\n                 * `.highcharts-data-label-connector` class.\n                 *\n                 * @sample {highcharts} highcharts/series-timeline/connector-styles\n                 *         Custom connector width and color\n                 */\n                connectorWidth: 1,\n                /**\n                 * A pixel value defining the distance between the data label and\n                 * the point. Negative numbers puts the label on top of the point in a\n                 * non-inverted chart. Defaults to 100 for horizontal and 20 for\n                 * vertical timeline (`chart.inverted: true`).\n                 */\n                distance: void 0,\n                // eslint-disable-next-line jsdoc/require-description\n                /**\n                 * @type    {Highcharts.TimelineDataLabelsFormatterCallbackFunction}\n                 * @default function () {\n                 *   let format;\n                 *\n                 *   if (!this.series.chart.styledMode) {\n                 *       format = '<span style=\"color:' + this.point.color +\n                 *           '\">● </span>';\n                 *   } else {\n                 *       format = '<span class=\"highcharts-color-' +\n                 *          this.point.colorIndex + '\">● </span>';\n                 *   }\n                 *   format += '<span>' + (this.key || '') + '</span><br/>' +\n                 *       (this.point.label || '');\n                 *   return format;\n                 * }\n                 */\n                formatter: function () {\n                    let format;\n                    if (!this.series.chart.styledMode) {\n                        format = '<span style=\"color:' + this.point.color +\n                            '\">● </span>';\n                    }\n                    else {\n                        format = '<span class=\"highcharts-color-' +\n                            this.point.colorIndex + '\">● </span>';\n                    }\n                    format += '<span class=\"highcharts-strong\">' +\n                        (this.key || '') + '</span><br/>' +\n                        (this.point.label || '');\n                    return format;\n                },\n                style: {\n                    /** @internal */\n                    textOutline: 'none',\n                    /** @internal */\n                    fontWeight: 'normal',\n                    /** @internal */\n                    fontSize: '0.8em'\n                },\n                /**\n                 * Shadow options for the data label.\n                 *\n                 * @type {boolean|Highcharts.CSSObject}\n                 */\n                shadow: false,\n                /**\n                 * @type      {number}\n                 * @apioption plotOptions.timeline.dataLabels.width\n                 */\n                verticalAlign: 'middle'\n            },\n            marker: {\n                enabledThreshold: 0,\n                symbol: 'square',\n                radius: 6,\n                lineWidth: 2,\n                height: 15\n            },\n            showInLegend: false,\n            colorKey: 'x',\n            legendSymbol: 'rectangle'\n        };\n        /**\n         * The `timeline` series. If the [type](#series.timeline.type) option is\n         * not specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.timeline\n         * @excluding animationLimit, boostThreshold, connectEnds, connectNulls,\n         *            cropThreshold, dashStyle, dataParser, dataURL, findNearestPointBy,\n         *            getExtremesFromAll, negativeColor, pointInterval,\n         *            pointIntervalUnit, pointPlacement, pointStart, softThreshold,\n         *            stacking, stack, step, threshold, turboThreshold, zoneAxis, zones,\n         *            dataSorting, boostBlending\n         * @product   highcharts\n         * @requires  modules/timeline\n         * @apioption series.timeline\n         */\n        /**\n         * An array of data points for the series. For the `timeline` series type,\n         * points can be given with three general parameters, `name`, `label`,\n         * and `description`:\n         *\n         * Example:\n         *\n         * ```js\n         * series: [{\n         *    type: 'timeline',\n         *    data: [{\n         *        name: 'Jan 2018',\n         *        label: 'Some event label',\n         *        description: 'Description to show in tooltip'\n         *    }]\n         * }]\n         * ```\n         * If all points additionally have the `x` values, and xAxis type is set to\n         * `datetime`, then events are laid out on a true time axis, where their\n         * placement reflects the actual time between them.\n         *\n         * @sample {highcharts} highcharts/series-timeline/alternate-labels\n         *         Alternate labels\n         * @sample {highcharts} highcharts/series-timeline/datetime-axis\n         *         Real time intervals\n         *\n         * @type      {Array<*>}\n         * @extends   series.line.data\n         * @excluding marker, y\n         * @product   highcharts\n         * @apioption series.timeline.data\n         */\n        /**\n         * The name of event.\n         *\n         * @type      {string}\n         * @product   highcharts\n         * @apioption series.timeline.data.name\n         */\n        /**\n         * The label of event.\n         *\n         * @type      {string}\n         * @product   highcharts\n         * @apioption series.timeline.data.label\n         */\n        /**\n         * The description of event. This description will be shown in tooltip.\n         *\n         * @type      {string}\n         * @product   highcharts\n         * @apioption series.timeline.data.description\n         */\n        ''; // Adds doclets above to transpiled file\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return TimelineSeriesDefaults;\n    });\n    _registerModule(_modules, 'Series/Timeline/TimelineSeries.js', [_modules['Core/Series/SeriesRegistry.js'], _modules['Series/Timeline/TimelinePoint.js'], _modules['Series/Timeline/TimelineSeriesDefaults.js'], _modules['Core/Utilities.js']], function (SeriesRegistry, TimelinePoint, TimelineSeriesDefaults, U) {\n        /* *\n         *\n         *  Timeline Series.\n         *\n         *  (c) 2010-2024 Highsoft AS\n         *\n         *  Author: Daniel Studencki\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { column: ColumnSeries, line: LineSeries } = SeriesRegistry.seriesTypes;\n        const { addEvent, arrayMax, arrayMin, defined, extend, merge, pick } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The timeline series type.\n         *\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.timeline\n         *\n         * @augments Highcharts.Series\n         */\n        class TimelineSeries extends LineSeries {\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            alignDataLabel(point, dataLabel, _options, _alignTo) {\n                const series = this, isInverted = series.chart.inverted, visiblePoints = series.visibilityMap.filter((point) => !!point), visiblePointsCount = series.visiblePointsCount || 0, pointIndex = visiblePoints.indexOf(point), isFirstOrLast = (!pointIndex || pointIndex === visiblePointsCount - 1), dataLabelsOptions = series.options.dataLabels, userDLOptions = point.userDLOptions || {}, \n                // Define multiplier which is used to calculate data label\n                // width. If data labels are alternate, they have two times more\n                // space to adapt (excepting first and last ones, which has only\n                // one and half), than in case of placing all data labels side\n                // by side.\n                multiplier = dataLabelsOptions.alternate ?\n                    (isFirstOrLast ? 1.5 : 2) :\n                    1, availableSpace = Math.floor(series.xAxis.len / visiblePointsCount), pad = dataLabel.padding;\n                let distance, targetDLWidth, styles;\n                // Adjust data label width to the currently available space.\n                if (point.visible) {\n                    distance = Math.abs(userDLOptions.x || point.options.dataLabels.x);\n                    if (isInverted) {\n                        targetDLWidth = ((distance - pad) * 2 - ((point.itemHeight || 0) / 2));\n                        styles = {\n                            width: pick(dataLabelsOptions.style?.width, `${series.yAxis.len * 0.4}px`),\n                            // Apply ellipsis when data label height is exceeded.\n                            textOverflow: (dataLabel.width || 0) / targetDLWidth *\n                                (dataLabel.height || 0) / 2 > availableSpace *\n                                multiplier ?\n                                'ellipsis' : 'none'\n                        };\n                    }\n                    else {\n                        styles = {\n                            width: (userDLOptions.width ||\n                                dataLabelsOptions.width ||\n                                availableSpace * multiplier - (pad * 2)) + 'px'\n                        };\n                    }\n                    dataLabel.css(styles);\n                    if (!series.chart.styledMode) {\n                        dataLabel.shadow(dataLabelsOptions.shadow);\n                    }\n                }\n                super.alignDataLabel.apply(series, arguments);\n            }\n            bindAxes() {\n                const series = this;\n                super.bindAxes();\n                // Initially set the linked xAxis type to category.\n                if (!series.xAxis.userOptions.type) {\n                    series.xAxis.categories = series.xAxis.hasNames = true;\n                }\n            }\n            distributeDL() {\n                const series = this, dataLabelsOptions = series.options.dataLabels, inverted = series.chart.inverted;\n                let visibilityIndex = 1;\n                if (dataLabelsOptions) {\n                    const distance = pick(dataLabelsOptions.distance, inverted ? 20 : 100);\n                    for (const point of series.points) {\n                        const defaults = {\n                            [inverted ? 'x' : 'y']: dataLabelsOptions.alternate && visibilityIndex % 2 ?\n                                -distance : distance\n                        };\n                        if (inverted) {\n                            defaults.align = (dataLabelsOptions.alternate && visibilityIndex % 2) ? 'right' : 'left';\n                        }\n                        point.options.dataLabels = merge(defaults, point.userDLOptions);\n                        visibilityIndex++;\n                    }\n                }\n            }\n            generatePoints() {\n                super.generatePoints();\n                const series = this, points = series.points;\n                for (let i = 0, iEnd = points.length; i < iEnd; ++i) {\n                    points[i].applyOptions({\n                        x: series.xData[i]\n                    }, series.xData[i]);\n                }\n            }\n            getVisibilityMap() {\n                const series = this, map = (series.data.length ?\n                    series.data :\n                    series.userOptions.data || []).map((point) => (point && point.visible !== false && !point.isNull ?\n                    point :\n                    false));\n                return map;\n            }\n            getXExtremes(xData) {\n                const series = this, filteredData = xData.filter((_x, i) => (series.points[i].isValid() &&\n                    series.points[i].visible));\n                return {\n                    min: arrayMin(filteredData),\n                    max: arrayMax(filteredData)\n                };\n            }\n            init() {\n                const series = this;\n                super.init.apply(series, arguments);\n                series.eventsToUnbind.push(addEvent(series, 'afterTranslate', function () {\n                    let lastPlotX, closestPointRangePx = Number.MAX_VALUE;\n                    for (const point of series.points) {\n                        // Set the isInside parameter basing also on the real point\n                        // visibility, in order to avoid showing hidden points\n                        // in drawPoints method.\n                        point.isInside = point.isInside && point.visible;\n                        // New way of calculating closestPointRangePx value, which\n                        // respects the real point visibility is needed.\n                        if (point.visible && !point.isNull) {\n                            if (defined(lastPlotX)) {\n                                closestPointRangePx = Math.min(closestPointRangePx, Math.abs(point.plotX - lastPlotX));\n                            }\n                            lastPlotX = point.plotX;\n                        }\n                    }\n                    series.closestPointRangePx = closestPointRangePx;\n                }));\n                // Distribute data labels before rendering them. Distribution is\n                // based on the 'dataLabels.distance' and 'dataLabels.alternate'\n                // property.\n                series.eventsToUnbind.push(addEvent(series, 'drawDataLabels', function () {\n                    // Distribute data labels basing on defined algorithm.\n                    series.distributeDL(); // @todo use this scope for series\n                }));\n                series.eventsToUnbind.push(addEvent(series, 'afterDrawDataLabels', function () {\n                    let dataLabel; // @todo use this scope for series\n                    // Draw or align connector for each point.\n                    for (const point of series.points) {\n                        dataLabel = point.dataLabel;\n                        if (dataLabel) {\n                            // Within this wrap method is necessary to save the\n                            // current animation params, because the data label\n                            // target position (after animation) is needed to align\n                            // connectors.\n                            dataLabel.animate = function (params) {\n                                if (this.targetPosition) {\n                                    this.targetPosition = params;\n                                }\n                                return this.renderer.Element.prototype\n                                    .animate.apply(this, arguments);\n                            };\n                            // Initialize the targetPosition field within data label\n                            // object. It's necessary because there is need to know\n                            // expected position of specific data label, when\n                            // aligning connectors. This field is overridden inside\n                            // of SVGElement.animate() wrapped method.\n                            if (!dataLabel.targetPosition) {\n                                dataLabel.targetPosition = {};\n                            }\n                            point.drawConnector();\n                        }\n                    }\n                }));\n                series.eventsToUnbind.push(addEvent(series.chart, 'afterHideOverlappingLabel', function () {\n                    for (const p of series.points) {\n                        if (p.dataLabel &&\n                            p.dataLabel.connector &&\n                            p.dataLabel.oldOpacity !== p.dataLabel.newOpacity) {\n                            p.alignConnector();\n                        }\n                    }\n                }));\n            }\n            markerAttribs(point, state) {\n                const series = this, seriesMarkerOptions = series.options.marker, pointMarkerOptions = point.marker || {}, symbol = (pointMarkerOptions.symbol || seriesMarkerOptions.symbol), width = pick(pointMarkerOptions.width, seriesMarkerOptions.width, series.closestPointRangePx), height = pick(pointMarkerOptions.height, seriesMarkerOptions.height);\n                let seriesStateOptions, pointStateOptions, radius = 0;\n                // Call default markerAttribs method, when the xAxis type\n                // is set to datetime.\n                if (series.xAxis.dateTime) {\n                    return super.markerAttribs(point, state);\n                }\n                // Handle hover and select states\n                if (state) {\n                    seriesStateOptions =\n                        seriesMarkerOptions.states[state] || {};\n                    pointStateOptions = pointMarkerOptions.states &&\n                        pointMarkerOptions.states[state] || {};\n                    radius = pick(pointStateOptions.radius, seriesStateOptions.radius, radius + (seriesStateOptions.radiusPlus || 0));\n                }\n                point.hasImage = (symbol && symbol.indexOf('url') === 0);\n                const attribs = {\n                    x: Math.floor(point.plotX) - (width / 2) - (radius / 2),\n                    y: point.plotY - (height / 2) - (radius / 2),\n                    width: width + radius,\n                    height: height + radius\n                };\n                return (series.chart.inverted) ? {\n                    y: (attribs.x && attribs.width) &&\n                        series.xAxis.len - attribs.x - attribs.width,\n                    x: attribs.y && attribs.y,\n                    width: attribs.height,\n                    height: attribs.width\n                } : attribs;\n            }\n            processData() {\n                const series = this;\n                let visiblePoints = 0, i;\n                series.visibilityMap = series.getVisibilityMap();\n                // Calculate currently visible points.\n                for (const point of series.visibilityMap) {\n                    if (point) {\n                        visiblePoints++;\n                    }\n                }\n                series.visiblePointsCount = visiblePoints;\n                for (i = 0; i < series.xData.length; i++) {\n                    series.yData[i] = 1;\n                }\n                super.processData.call(this, arguments);\n                return;\n            }\n        }\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        TimelineSeries.defaultOptions = merge(LineSeries.defaultOptions, TimelineSeriesDefaults);\n        extend(TimelineSeries.prototype, {\n            // Use a group of trackers from TrackerMixin\n            drawTracker: ColumnSeries.prototype.drawTracker,\n            pointClass: TimelinePoint,\n            trackerGroups: ['markerGroup', 'dataLabelsGroup']\n        });\n        SeriesRegistry.registerSeriesType('timeline', TimelineSeries);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Declarations\n         *\n         * */\n        /**\n         * Callback JavaScript function to format the data label as a string. Note that\n         * if a `format` is defined, the format takes precedence and the formatter is\n         * ignored.\n         *\n         * @callback Highcharts.TimelineDataLabelsFormatterCallbackFunction\n         *\n         * @param {Highcharts.PointLabelObject|Highcharts.TimelineDataLabelsFormatterContextObject} this\n         *        Data label context to format\n         *\n         * @return {number|string|null|undefined}\n         *         Formatted data label text\n         */\n        /**\n         * @interface Highcharts.TimelineDataLabelsFormatterContextObject\n         * @extends Highcharts.PointLabelObject\n         */ /**\n        * @name Highcharts.TimelineDataLabelsFormatterContextObject#key\n        * @type {string|undefined}\n        */ /**\n        * @name Highcharts.TimelineDataLabelsFormatterContextObject#point\n        * @type {Highcharts.Point}\n        */ /**\n        * @name Highcharts.TimelineDataLabelsFormatterContextObject#series\n        * @type {Highcharts.Series}\n        */\n        ''; // Dettach doclets above\n\n        return TimelineSeries;\n    });\n    _registerModule(_modules, 'masters/modules/timeline.src.js', [_modules['Core/Globals.js']], function (Highcharts) {\n\n\n        return Highcharts;\n    });\n}));\n"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","win","dispatchEvent","detail","Point","SeriesRegistry","U","line","prototype","pointClass","LinePoint","pie","PiePoint","seriesTypes","defined","isNumber","merge","objectEach","pick","alignConnector","series","point","dataLabel","connector","dlOptions","options","connectorWidth","chart","bBox","getBBox","plotPos","x","translateX","y","translateY","inverted","isVisible","isInsidePlot","d","getConnectorPath","addClass","colorIndex","styledMode","attr","stroke","connectorColor","color","opacity","newOpacity","drawConnector","renderer","zIndex","add","plotX","plotY","xAxisLen","xAxis","len","direction","targetDLPos","targetPosition","negativeDistance","alignAttr","yAxis","coords","x1","y1","x2","y2","_coord","i","crispLine","constructor","name","isValid","setState","proceed","isNull","arguments","setVisible","visible","redraw","ignoreHiddenPoint","call","processData","applyOptions","optionsToObject","userDLOptions","dataLabels","colorByPoint","stickyTracking","legendType","lineWidth","tooltip","headerFormat","pointFormat","states","hover","lineWidthPlus","enabled","allowOverlap","alternate","backgroundColor","borderWidth","borderColor","borderRadius","distance","formatter","key","label","style","textOutline","fontWeight","fontSize","shadow","verticalAlign","marker","enabledThreshold","symbol","radius","height","showInLegend","colorKey","legendSymbol","TimelinePoint","TimelineSeriesDefaults","column","ColumnSeries","LineSeries","addEvent","arrayMax","arrayMin","extend","TimelineSeries","alignDataLabel","_options","_alignTo","targetDLWidth","styles","isInverted","visiblePoints","visibilityMap","filter","visiblePointsCount","pointIndex","indexOf","dataLabelsOptions","multiplier","isFirstOrLast","availableSpace","Math","floor","pad","padding","abs","itemHeight","width","textOverflow","css","bindAxes","userOptions","type","categories","hasNames","distributeDL","visibilityIndex","points","defaults","align","generatePoints","iEnd","length","xData","getVisibilityMap","data","map","getXExtremes","filteredData","_x","min","max","init","eventsToUnbind","push","lastPlotX","closestPointRangePx","Number","MAX_VALUE","isInside","animate","params","Element","p","oldOpacity","markerAttribs","state","seriesMarkerOptions","pointMarkerOptions","seriesStateOptions","dateTime","pointStateOptions","radiusPlus","hasImage","attribs","yData","defaultOptions","drawTracker","trackerGroups","registerSeriesType"],"mappings":"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"}
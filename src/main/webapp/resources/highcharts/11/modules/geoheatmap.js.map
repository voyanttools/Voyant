{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v11.4.8 (2024-08-29)\n *\n * (c) 2009-2024\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/geoheatmap', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                Highcharts.win.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Series/GeoHeatmap/GeoHeatmapPoint.js', [_modules['Core/Utilities.js'], _modules['Core/Series/SeriesRegistry.js']], function (U, SeriesRegistry) {\n        /* *\n         *\n         *  (c) 2010-2024 Highsoft AS\n         *\n         *  Authors: Magdalena Gut, Piotr Madej\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { map: { prototype: { pointClass: MapPoint } } } = SeriesRegistry.seriesTypes;\n        const { isNumber } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        class GeoHeatmapPoint extends MapPoint {\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * @private\n             */\n            applyOptions(options, x) {\n                const point = super.applyOptions.call(this, options, x), { lat, lon } = point.options;\n                if (isNumber(lon) && isNumber(lat)) {\n                    const { colsize = 1, rowsize = 1 } = this.series.options, x1 = lon - colsize / 2, y1 = lat - rowsize / 2;\n                    point.geometry = point.options.geometry = {\n                        type: 'Polygon',\n                        // A rectangle centered in lon/lat\n                        coordinates: [\n                            [\n                                [x1, y1],\n                                [x1 + colsize, y1],\n                                [x1 + colsize, y1 + rowsize],\n                                [x1, y1 + rowsize],\n                                [x1, y1]\n                            ]\n                        ]\n                    };\n                }\n                return point;\n                /* eslint-enable valid-jsdoc */\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return GeoHeatmapPoint;\n    });\n    _registerModule(_modules, 'Series/InterpolationUtilities.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  (c) 2010-2024 Hubert Kozik\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { doc } = H;\n        const { defined, pick } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Find color of point based on color axis.\n         *\n         * @function Highcharts.colorFromPoint\n         *\n         * @param {number | null} value\n         *        Value to find corresponding color on the color axis.\n         *\n         * @param {Highcharts.Point} point\n         *        Point to find it's color from color axis.\n         *\n         * @return {number[]}\n         *        Color in RGBa array.\n         */\n        function colorFromPoint(value, point) {\n            const colorAxis = point.series.colorAxis;\n            if (colorAxis) {\n                const rgba = (colorAxis.toColor(value || 0, point)\n                    .split(')')[0]\n                    .split('(')[1]\n                    .split(',')\n                    .map((s) => pick(parseFloat(s), parseInt(s, 10))));\n                rgba[3] = pick(rgba[3], 1.0) * 255;\n                if (!defined(value) || !point.visible) {\n                    rgba[3] = 0;\n                }\n                return rgba;\n            }\n            return [0, 0, 0, 0];\n        }\n        /**\n         * Method responsible for creating a canvas for interpolation image.\n         * @private\n         */\n        function getContext(series) {\n            const { canvas, context } = series;\n            if (canvas && context) {\n                context.clearRect(0, 0, canvas.width, canvas.height);\n            }\n            else {\n                series.canvas = doc.createElement('canvas');\n                series.context = series.canvas.getContext('2d', {\n                    willReadFrequently: true\n                }) || void 0;\n                return series.context;\n            }\n            return context;\n        }\n        const InterpolationUtilities = {\n            colorFromPoint,\n            getContext\n        };\n\n        return InterpolationUtilities;\n    });\n    _registerModule(_modules, 'Series/GeoHeatmap/GeoHeatmapSeries.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Series/GeoHeatmap/GeoHeatmapPoint.js'], _modules['Core/Globals.js'], _modules['Series/InterpolationUtilities.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (A, GeoHeatmapPoint, H, IU, SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2024 Highsoft AS\n         *\n         *  Authors: Magdalena Gut, Piotr Madej\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { animObject, stop } = A;\n        const { noop } = H;\n        const { colorFromPoint, getContext } = IU;\n        const { seriesTypes: { map: MapSeries } } = SeriesRegistry;\n        const { addEvent, extend, isNumber, isObject, merge, pick } = U;\n        /**\n         * Normalize longitute value to -180:180 range.\n         * @private\n         */\n        function normalizeLonValue(lon) {\n            return lon - Math.floor((lon + 180) / 360) * 360;\n        }\n        /**\n         * Get proper point's position for PixelData array.\n         * @private\n         */\n        function scaledPointPos(lon, lat, canvasWidth, canvasHeight, colsize, rowsize) {\n            return Math.ceil((canvasWidth * (canvasHeight - 1 - (lat + 90) / rowsize)) +\n                ((lon + 180) / colsize));\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The Geo Heatmap series type.\n         *\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.geoheatmap\n         *\n         * @augments Highcharts.Series\n         */\n        class GeoHeatmapSeries extends MapSeries {\n            constructor() {\n                /* *\n                 *\n                 *  Static Properties\n                 *\n                 * */\n                super(...arguments);\n                this.isDirtyCanvas = true;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * For updated colsize and rowsize options\n             * @private\n             */\n            update() {\n                const series = this;\n                series.options = merge(series.options, arguments[0]);\n                if (series.getInterpolation().enabled) {\n                    series.isDirtyCanvas = true;\n                    series.points.forEach((point) => {\n                        if (point.graphic) {\n                            point.graphic.destroy();\n                            delete point.graphic;\n                        }\n                    });\n                }\n                super.update.apply(series, arguments);\n            }\n            /**\n             * Override translate method to not fire if not needed.\n             * @private\n             */\n            translate() {\n                if (this.getInterpolation().enabled &&\n                    this.image &&\n                    !this.isDirty &&\n                    !this.isDirtyData) {\n                    return;\n                }\n                super.translate.apply(this, arguments);\n            }\n            /**\n             * Create the extended object out of the boolean\n             * @private\n             */\n            getInterpolation() {\n                if (!isObject(this.options.interpolation)) {\n                    return {\n                        blur: 1,\n                        enabled: this.options.interpolation\n                    };\n                }\n                return this.options.interpolation;\n            }\n            /**\n             * Overriding drawPoints original method to apply new features.\n             * @private\n             */\n            drawPoints() {\n                const series = this, chart = series.chart, mapView = chart.mapView, seriesOptions = series.options;\n                if (series.getInterpolation().enabled && mapView && series.bounds) {\n                    const ctx = series.context || getContext(series), { canvas, colorAxis, image, chart, points } = series, [colsize, rowsize] = [\n                        pick(seriesOptions.colsize, 1),\n                        pick(seriesOptions.rowsize, 1)\n                    ], \n                    // Calculate dimensions based on series bounds\n                    topLeft = mapView.projectedUnitsToPixels({\n                        x: series.bounds.x1,\n                        y: series.bounds.y2\n                    }), bottomRight = mapView.projectedUnitsToPixels({\n                        x: series.bounds.x2,\n                        y: series.bounds.y1\n                    });\n                    if (canvas && ctx && colorAxis && topLeft && bottomRight) {\n                        const dimensions = {\n                            x: topLeft.x,\n                            y: topLeft.y,\n                            width: bottomRight.x - topLeft.x,\n                            height: bottomRight.y - topLeft.y\n                        };\n                        if (\n                        // Do not calculate new canvas if not necessary\n                        series.isDirtyCanvas ||\n                            // Calculate new canvas if data is dirty\n                            series.isDirtyData ||\n                            // Always calculate new canvas for Orthographic projection\n                            mapView.projection.options.name === 'Orthographic') {\n                            series.isDirtyCanvas = true;\n                            const canvasWidth = canvas.width = ~~(360 / colsize) + 1, canvasHeight = canvas.height = ~~(180 / rowsize) + 1, canvasArea = canvasWidth * canvasHeight, pixelData = new Uint8ClampedArray(canvasArea * 4);\n                            series.directTouch = false; // Needed for tooltip\n                            // First pixelData represents the geo coordinates\n                            for (let i = 0; i < points.length; i++) {\n                                const p = points[i], sourceArr = new Uint8ClampedArray(colorFromPoint(p.value, p)), { lon, lat } = p.options;\n                                if (isNumber(lon) && isNumber(lat)) {\n                                    pixelData.set(sourceArr, scaledPointPos(lon, lat, canvasWidth, canvasHeight, colsize, rowsize) * 4);\n                                }\n                            }\n                            const blur = series.getInterpolation().blur, blurFactor = blur === 0 ? 1 : blur * 11, upscaledWidth = ~~(canvasWidth * blurFactor), upscaledHeight = ~~(canvasHeight * blurFactor), projectedWidth = ~~dimensions.width, projectedHeight = ~~dimensions.height, img = new ImageData(pixelData, canvasWidth, canvasHeight);\n                            canvas.width = upscaledWidth;\n                            canvas.height = upscaledHeight;\n                            // Next step is to upscale pixelData to big image to get\n                            // the blur on the interpolation\n                            ctx.putImageData(img, 0, 0);\n                            // Now we have an unscaled version of our ImageData\n                            // let's make the compositing mode to 'copy' so that\n                            // our next drawing op erases whatever was there\n                            // previously just like putImageData would have done\n                            ctx.globalCompositeOperation = 'copy';\n                            // Now we can draw ourself over ourself\n                            ctx.drawImage(canvas, 0, 0, img.width, img.height, // Grab the ImageData\n                            0, 0, canvas.width, canvas.height // Scale it\n                            );\n                            // Add projection to upscaled ImageData\n                            const cartesianImageData = ctx.getImageData(0, 0, canvas.width, canvas.height), projectedPixelData = this.getProjectedImageData(mapView, projectedWidth, projectedHeight, cartesianImageData, canvas, dimensions.x, dimensions.y), projectedImg = new ImageData(projectedPixelData, projectedWidth, projectedHeight);\n                            ctx.globalCompositeOperation = 'copy';\n                            canvas.width = projectedWidth;\n                            canvas.height = projectedHeight;\n                            ctx.putImageData(projectedImg, 0, 0);\n                        }\n                        if (image) {\n                            if (chart.renderer.globalAnimation && chart.hasRendered) {\n                                const startX = Number(image.attr('x')), startY = Number(image.attr('y')), startWidth = Number(image.attr('width')), startHeight = Number(image.attr('height'));\n                                const step = (now, fx) => {\n                                    image.attr({\n                                        x: (startX + (dimensions.x - startX) * fx.pos),\n                                        y: (startY + (dimensions.y - startY) * fx.pos),\n                                        width: (startWidth + (dimensions.width - startWidth) * fx.pos),\n                                        height: (startHeight + (dimensions.height - startHeight) * fx.pos)\n                                    });\n                                };\n                                const animOptions = merge(animObject(chart.renderer.globalAnimation)), userStep = animOptions.step;\n                                animOptions.step =\n                                    function () {\n                                        if (userStep) {\n                                            userStep.apply(this, arguments);\n                                        }\n                                        step.apply(this, arguments);\n                                    };\n                                image\n                                    .attr(merge({ animator: 0 }, series.isDirtyCanvas ? {\n                                    href: canvas.toDataURL('image/png', 1)\n                                } : void 0))\n                                    .animate({ animator: 1 }, animOptions);\n                                // When dragging or first rendering, animation is off\n                            }\n                            else {\n                                stop(image);\n                                image.attr(merge(dimensions, series.isDirtyCanvas ? {\n                                    href: canvas.toDataURL('image/png', 1)\n                                } : void 0));\n                            }\n                        }\n                        else {\n                            series.image = chart.renderer.image(canvas.toDataURL('image/png', 1))\n                                .attr(dimensions)\n                                .add(series.group);\n                        }\n                        series.isDirtyCanvas = false;\n                    }\n                }\n                else {\n                    super.drawPoints.apply(series, arguments);\n                }\n            }\n            /**\n             * Project ImageData to actual mapView projection used on a chart.\n             * @private\n             */\n            getProjectedImageData(mapView, projectedWidth, projectedHeight, cartesianImageData, canvas, horizontalShift, verticalShift) {\n                const projectedPixelData = new Uint8ClampedArray(projectedWidth * projectedHeight * 4), lambda = pick(mapView.projection.options.rotation?.[0], 0), widthFactor = canvas.width / 360, heightFactor = -1 * canvas.height / 180;\n                let y = -1;\n                // For each pixel on the map plane, find the map\n                // coordinate and get the color value\n                for (let i = 0; i < projectedPixelData.length; i += 4) {\n                    const x = (i / 4) % projectedWidth;\n                    if (x === 0) {\n                        y++;\n                    }\n                    const projectedCoords = mapView.pixelsToLonLat({\n                        x: horizontalShift + x,\n                        y: verticalShift + y\n                    });\n                    if (projectedCoords) {\n                        // Normalize lon values\n                        if (projectedCoords.lon > -180 - lambda &&\n                            projectedCoords.lon < 180 - lambda) {\n                            projectedCoords.lon =\n                                normalizeLonValue(projectedCoords.lon);\n                        }\n                        const projected = [\n                            projectedCoords.lon,\n                            projectedCoords.lat\n                        ], cvs2PixelX = projected[0] * widthFactor + canvas.width / 2, cvs2PixelY = projected[1] * heightFactor +\n                            canvas.height / 2;\n                        if (cvs2PixelX >= 0 &&\n                            cvs2PixelX <= canvas.width &&\n                            cvs2PixelY >= 0 &&\n                            cvs2PixelY <= canvas.height) {\n                            const redPos = (\n                            // Rows\n                            Math.floor(cvs2PixelY) *\n                                canvas.width * 4 +\n                                // Columns\n                                Math.round(cvs2PixelX) * 4);\n                            projectedPixelData[i] =\n                                cartesianImageData.data[redPos];\n                            projectedPixelData[i + 1] =\n                                cartesianImageData.data[redPos + 1];\n                            projectedPixelData[i + 2] =\n                                cartesianImageData.data[redPos + 2];\n                            projectedPixelData[i + 3] =\n                                cartesianImageData.data[redPos + 3];\n                        }\n                    }\n                }\n                return projectedPixelData;\n            }\n            searchPoint(e, compareX) {\n                const series = this, chart = this.chart, mapView = chart.mapView;\n                if (mapView &&\n                    series.bounds &&\n                    series.image &&\n                    chart.tooltip &&\n                    chart.tooltip.options.enabled) {\n                    if (\n                    // If user drags map do not build k-d-tree\n                    !chart.pointer.hasDragged &&\n                        // If user zooms in/out map do not build k-d-tree\n                        (+series.image.attr('animator') <= 0.01 ||\n                            +series.image.attr('animator') >= 0.99)) {\n                        const topLeft = mapView.projectedUnitsToPixels({\n                            x: series.bounds.x1,\n                            y: series.bounds.y2\n                        }), bottomRight = mapView.projectedUnitsToPixels({\n                            x: series.bounds.x2,\n                            y: series.bounds.y1\n                        });\n                        chart.pointer.normalize(e);\n                        if (e.lon && e.lat &&\n                            topLeft && bottomRight &&\n                            e.chartX - chart.plotLeft > topLeft.x &&\n                            e.chartX - chart.plotLeft < bottomRight.x &&\n                            e.chartY - chart.plotTop > topLeft.y &&\n                            e.chartY - chart.plotTop < bottomRight.y) {\n                            return this.searchKDTree({\n                                clientX: e.chartX,\n                                lon: normalizeLonValue(e.lon),\n                                lat: e.lat\n                            }, compareX, e);\n                        }\n                    }\n                    else {\n                        chart.tooltip.destroy();\n                    }\n                }\n            }\n        }\n        /**\n         * A `geoheatmap` series is a variety of heatmap series, composed into\n         * the map projection, where the units are expressed in the latitude\n         * and longitude, and individual values contained in a matrix are\n         * represented as colors.\n         *\n         * @sample maps/demo/geoheatmap-europe/\n         *         GeoHeatmap Chart with interpolation on Europe map\n         * @sample maps/series-geoheatmap/geoheatmap-equalearth/\n         *         GeoHeatmap Chart on the Equal Earth Projection\n         *\n         * @extends      plotOptions.map\n         * @since        11.0.0\n         * @product      highmaps\n         * @excluding    allAreas, dragDrop, findNearestPointBy, geometry, joinBy,\n         * negativeColor, onPoint, stickyTracking\n         * @requires     modules/geoheatmap\n         * @optionparent plotOptions.geoheatmap\n         */\n        GeoHeatmapSeries.defaultOptions = merge(MapSeries.defaultOptions, {\n            nullColor: 'transparent',\n            tooltip: {\n                pointFormat: 'Lat: {point.lat}, Lon: {point.lon}, Value: {point.value}<br/>'\n            },\n            /**\n             * The border width of each geoheatmap tile.\n             *\n             * In styled mode, the border stroke width is given in the\n             * `.highcharts-point` class.\n             *\n             * @sample maps/demo/geoheatmap-orthographic/\n             *         borderWidth set to 1 to create a grid\n             *\n             * @type      {number|null}\n             * @default   0\n             * @product   highmaps\n             * @apioption plotOptions.geoheatmap.borderWidth\n             */\n            borderWidth: 0,\n            /**\n             * The column size - how many longitude units each column in the\n             * geoheatmap should span.\n             *\n             * @sample maps/demo/geoheatmap-europe/\n             *         1 by default, set to 5\n             *\n             * @product   highmaps\n             * @apioption plotOptions.geoheatmap.colsize\n             */\n            colsize: 1,\n            /**\n             * The main color of the series. In heat maps this color is rarely\n             * used, as we mostly use the color to denote the value of each\n             * point. Unless options are set in the [colorAxis](#colorAxis), the\n             * default value is pulled from the [options.colors](#colors) array.\n             *\n             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n             * @product   highmaps\n             * @apioption plotOptions.geoheatmap.color\n             */\n            /**\n             * The rowsize size - how many latitude units each row in the\n             * geoheatmap should span.\n             *\n             * @sample maps/demo/geoheatmap-europe/\n             *         1 by default, set to 5\n             *\n             * @product   highmaps\n             * @apioption plotOptions.geoheatmap.rowsize\n             */\n            rowsize: 1,\n            stickyTracking: true,\n            /**\n             * Make the geoheatmap render its data points as an interpolated\n             * image. It can be used to show a Temperature Map-like charts.\n             *\n             * @sample maps/demo/geoheatmap-earth-statistics\n             *         Advanced demo of GeoHeatmap interpolation with multiple\n             *         datasets\n             *\n             * @type      {boolean|Highcharts.InterpolationOptionsObject}\n             * @since     11.2.0\n             * @product   highmaps\n             */\n            interpolation: {\n                /**\n                 * Enable or disable the interpolation of the geoheatmap series.\n                 *\n                 * @since 11.2.0\n                 */\n                enabled: false,\n                /**\n                 * Represents how much blur should be added to the interpolated\n                 * image. Works best in the range of 0-1, all higher values\n                 * would need a lot more performance of the machine to calculate\n                 * more detailed interpolation.\n                 *\n                 *  * **Note:** Useful, if the data is spread into wide range of\n                 *  longitude and latitude values.\n                 *\n                 * @sample maps/series-geoheatmap/turkey-fire-areas\n                 *         Simple demo of GeoHeatmap interpolation\n                 *\n                 * @since  11.2.0\n                 */\n                blur: 1\n            }\n        });\n        addEvent(GeoHeatmapSeries, 'afterDataClassLegendClick', function () {\n            this.isDirtyCanvas = true;\n            this.drawPoints();\n        });\n        extend(GeoHeatmapSeries.prototype, {\n            type: 'geoheatmap',\n            applyJitter: noop,\n            pointClass: GeoHeatmapPoint,\n            pointArrayMap: ['lon', 'lat', 'value'],\n            kdAxisArray: ['lon', 'lat'] // Search k-d-tree by lon/lat values\n        });\n        SeriesRegistry.registerSeriesType('geoheatmap', GeoHeatmapSeries);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * A `geoheatmap` series. If the [type](#series.map.type) option is not\n         * specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.geoheatmap\n         * @excluding allAreas, dataParser, dataURL, dragDrop, findNearestPointBy,\n         *            joinBy, marker, mapData, negativeColor, onPoint, shadow,\n         *            stickyTracking\n         * @product   highmaps\n         * @apioption series.geoheatmap\n         */\n        /**\n         * An array of data points for the series. For the `geoheatmap` series\n         * type, points can be given in the following ways:\n         *\n         * 1.  An array of arrays with 3 or 2 values. In this case, the values\n         * correspond to `lon,lat,value`. The `value` refers to the color on the `colorAxis`.\n         *\n         *  ```js\n         *     data: [\n         *         [51.50, -0.12, 7],\n         *         [54.59, -5.93, 4],\n         *         [55.8, -4.25, 3]\n         *     ]\n         *  ```\n         *\n         * 2.  An array of objects with named values. The following snippet shows only a\n         * few settings, see the complete options set below. If the total number of data\n         * points exceeds the series' [turboThreshold](#series.heatmap.turboThreshold),\n         * this option is not available.\n         *\n         *  ```js\n         *     data: [{\n         *         lat: 51.50,\n         *         lon: -0.12,\n         *         value: 7,\n         *         name: \"London\"\n         *     }, {\n         *         lat: 54.59,\n         *         lon: -5.93,\n         *         value: 4,\n         *         name: \"Belfast\"\n         *     }]\n         *  ```\n         *\n         * @sample maps/demo/geoheatmap-europe/\n         *         GeoHeatmap Chart with interpolation on Europe map\n         * @sample maps/series-geoheatmap/geoheatmap-equalearth/\n         *         GeoHeatmap Chart on the Equal Earth Projection\n         *\n         * @type      {Array<Array<number>|*>}\n         * @extends   series.map.data\n         * @product   highmaps\n         * @apioption series.geoheatmap.data\n         */\n        /**\n         * Individual color for the point. By default the color is either used\n         * to denote the value, or pulled from the global `colors` array.\n         *\n         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n         * @product   highmaps\n         * @apioption series.geoheatmap.data.color\n         */\n        /**\n         * The value of the point, resulting in a color controlled by options\n         * as set in the [colorAxis](#colorAxis) configuration.\n         *\n         * @type      {number|null}\n         * @product   highmaps\n         * @apioption series.geoheatmap.data.value\n         */\n        /**\n         * Detailed options for interpolation object.\n         *\n         * @interface Highcharts.InterpolationOptionsObject\n         */ /**\n        *  Enable or disable the interpolation.\n        *\n        * @name Highcharts.InterpolationOptionsObject#enabled\n        * @type {boolean}\n        */ /**\n        * Represents how much blur should be added to the interpolated\n        * image. Works best in the range of 0-1, all higher values\n        * would need a lot more performance of the machine to calculate\n        * more detailed interpolation.\n        *\n        * @name Highcharts.InterpolationOptionsObject#blur\n        * @type {number}\n        */\n        ''; // Adds doclets above to the transpiled file\n\n        return GeoHeatmapSeries;\n    });\n    _registerModule(_modules, 'masters/modules/geoheatmap.src.js', [_modules['Core/Globals.js']], function (Highcharts) {\n\n\n        return Highcharts;\n    });\n}));\n"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","win","dispatchEvent","detail","U","SeriesRegistry","map","prototype","pointClass","MapPoint","seriesTypes","isNumber","applyOptions","options","x","point","call","lat","lon","colsize","rowsize","series","x1","y1","geometry","type","coordinates","H","doc","defined","pick","colorFromPoint","value","colorAxis","rgba","toColor","split","s","parseFloat","parseInt","visible","getContext","canvas","context","clearRect","width","height","createElement","willReadFrequently","A","GeoHeatmapPoint","IU","animObject","stop","noop","MapSeries","addEvent","extend","isObject","merge","normalizeLonValue","Math","floor","GeoHeatmapSeries","constructor","arguments","isDirtyCanvas","update","getInterpolation","enabled","points","forEach","graphic","destroy","translate","image","isDirty","isDirtyData","interpolation","blur","drawPoints","mapView","chart","seriesOptions","bounds","ctx","topLeft","projectedUnitsToPixels","y","y2","bottomRight","x2","dimensions","projection","name","canvasWidth","canvasHeight","pixelData","Uint8ClampedArray","canvasArea","directTouch","i","length","p","sourceArr","set","scaledPointPos","ceil","blurFactor","projectedWidth","projectedHeight","img","ImageData","putImageData","globalCompositeOperation","drawImage","cartesianImageData","getImageData","projectedImg","getProjectedImageData","renderer","globalAnimation","hasRendered","startX","Number","attr","startY","startWidth","startHeight","step","now","fx","pos","animOptions","userStep","animator","href","toDataURL","animate","add","group","horizontalShift","verticalShift","projectedPixelData","lambda","rotation","widthFactor","heightFactor","projectedCoords","pixelsToLonLat","projected","cvs2PixelX","cvs2PixelY","redPos","round","data","searchPoint","e","compareX","tooltip","pointer","hasDragged","normalize","chartX","plotLeft","chartY","plotTop","searchKDTree","clientX","defaultOptions","nullColor","pointFormat","borderWidth","stickyTracking","applyJitter","pointArrayMap","kdAxisArray","registerSeriesType"],"mappings":"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"}
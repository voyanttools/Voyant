{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v11.4.8 (2024-08-29)\n *\n * (c) 2009-2024 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/series-label', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                Highcharts.win.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Extensions/SeriesLabel/SeriesLabelDefaults.js', [], function () {\n        /* *\n         *\n         *  (c) 2009-2024 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        /**\n         * Series labels are placed as close to the series as possible in a\n         * natural way, seeking to avoid other series. The goal of this\n         * feature is to make the chart more easily readable, like if a\n         * human designer placed the labels in the optimal position.\n         *\n         * The series labels currently work with series types having a\n         * `graph` or an `area`.\n         *\n         * @sample highcharts/series-label/line-chart\n         *         Line chart\n         * @sample highcharts/demo/streamgraph\n         *         Stream graph\n         * @sample highcharts/series-label/stock-chart\n         *         Stock chart\n         *\n         * @declare  Highcharts.SeriesLabelOptionsObject\n         * @since    6.0.0\n         * @product  highcharts highstock gantt\n         * @requires modules/series-label\n         * @optionparent plotOptions.series.label\n         */\n        const SeriesLabelDefaults = {\n            /**\n             * Enable the series label per series.\n             */\n            enabled: true,\n            /**\n             * Allow labels to be placed distant to the graph if necessary,\n             * and draw a connector line to the graph. Setting this option\n             * to true may decrease the performance significantly, since the\n             * algorithm with systematically search for open spaces in the\n             * whole plot area. Visually, it may also result in a more\n             * cluttered chart, though more of the series will be labeled.\n             */\n            connectorAllowed: false,\n            /**\n             * If the label is closer than this to a neighbour graph, draw a\n             * connector.\n             */\n            connectorNeighbourDistance: 24,\n            /**\n             * A format string for the label, with support for a subset of\n             * HTML. Variables are enclosed by curly brackets. Available\n             * variables are `name`, `options.xxx`, `color` and other\n             * members from the `series` object. Use this option also to set\n             * a static text for the label.\n             *\n             * @type string\n             * @since 8.1.0\n             */\n            format: void 0,\n            /**\n             * Callback function to format each of the series' labels. The\n             * `this` keyword refers to the series object. By default the\n             * `formatter` is undefined and the `series.name` is rendered.\n             *\n             * @type {Highcharts.FormatterCallbackFunction<Series>}\n             * @since 8.1.0\n             */\n            formatter: void 0,\n            /**\n             * For area-like series, allow the font size to vary so that\n             * small areas get a smaller font size. The default applies this\n             * effect to area-like series but not line-like series.\n             *\n             * @type {number|null}\n             */\n            minFontSize: null,\n            /**\n             * For area-like series, allow the font size to vary so that\n             * small areas get a smaller font size. The default applies this\n             * effect to area-like series but not line-like series.\n             *\n             * @type {number|null}\n             */\n            maxFontSize: null,\n            /**\n             * Draw the label on the area of an area series. By default it\n             * is drawn on the area. Set it to `false` to draw it next to\n             * the graph instead.\n             *\n             * @type {boolean|null}\n             */\n            onArea: null,\n            /**\n             * Styles for the series label. The color defaults to the series\n             * color, or a contrast color if `onArea`.\n             *\n             * @type {Highcharts.CSSObject}\n             */\n            style: {\n                /** @internal */\n                fontSize: '0.8em',\n                /** @internal */\n                fontWeight: 'bold'\n            },\n            /**\n             * Whether to use HTML to render the series label.\n             */\n            useHTML: false,\n            /**\n             * An array of boxes to avoid when laying out the labels. Each\n             * item has a `left`, `right`, `top` and `bottom` property.\n             *\n             * @type {Array<Highcharts.LabelIntersectBoxObject>}\n             */\n            boxesToAvoid: []\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return SeriesLabelDefaults;\n    });\n    _registerModule(_modules, 'Extensions/SeriesLabel/SeriesLabelUtilities.js', [], function () {\n        /* *\n         *\n         *  (c) 2009-2024 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Counter-clockwise, part of the fast line intersection logic.\n         *\n         * @private\n         * @function ccw\n         */\n        function ccw(x1, y1, x2, y2, x3, y3) {\n            const cw = ((y3 - y1) * (x2 - x1)) - ((y2 - y1) * (x3 - x1));\n            return cw > 0 ? true : !(cw < 0);\n        }\n        /**\n         * Detect if two lines intersect.\n         *\n         * @private\n         * @function intersectLine\n         */\n        function intersectLine(x1, y1, x2, y2, x3, y3, x4, y4) {\n            return ccw(x1, y1, x3, y3, x4, y4) !== ccw(x2, y2, x3, y3, x4, y4) &&\n                ccw(x1, y1, x2, y2, x3, y3) !== ccw(x1, y1, x2, y2, x4, y4);\n        }\n        /**\n         * Detect if a box intersects with a line.\n         *\n         * @private\n         * @function boxIntersectLine\n         */\n        function boxIntersectLine(x, y, w, h, x1, y1, x2, y2) {\n            return (intersectLine(x, y, x + w, y, x1, y1, x2, y2) || // Top of label\n                intersectLine(x + w, y, x + w, y + h, x1, y1, x2, y2) || // Right\n                intersectLine(x, y + h, x + w, y + h, x1, y1, x2, y2) || // Bottom\n                intersectLine(x, y, x, y + h, x1, y1, x2, y2) // Left of label\n            );\n        }\n        /**\n         * @private\n         */\n        function intersectRect(r1, r2) {\n            return !(r2.left > r1.right ||\n                r2.right < r1.left ||\n                r2.top > r1.bottom ||\n                r2.bottom < r1.top);\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const SeriesLabelUtilities = {\n            boxIntersectLine,\n            intersectRect\n        };\n\n        return SeriesLabelUtilities;\n    });\n    _registerModule(_modules, 'Extensions/SeriesLabel/SeriesLabel.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Templating.js'], _modules['Core/Defaults.js'], _modules['Core/Globals.js'], _modules['Extensions/SeriesLabel/SeriesLabelDefaults.js'], _modules['Extensions/SeriesLabel/SeriesLabelUtilities.js'], _modules['Core/Utilities.js']], function (A, T, D, H, SeriesLabelDefaults, SLU, U) {\n        /* *\n         *\n         *  (c) 2009-2024 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /*\n         * Highcharts module to place labels next to a series in a natural position.\n         *\n         * TODO:\n         * - add column support (box collision detection, boxesToAvoid logic)\n         * - add more options (connector, format, formatter)\n         *\n         * https://jsfiddle.net/highcharts/L2u9rpwr/\n         * https://jsfiddle.net/highcharts/y5A37/\n         * https://jsfiddle.net/highcharts/264Nm/\n         * https://jsfiddle.net/highcharts/y5A37/\n         */\n        const { animObject } = A;\n        const { format } = T;\n        const { setOptions } = D;\n        const { composed } = H;\n        const { boxIntersectLine, intersectRect } = SLU;\n        const { addEvent, extend, fireEvent, isNumber, pick, pushUnique, syncTimeout } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const labelDistance = 3;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Check whether a proposed label position is clear of other elements.\n         * @private\n         */\n        function checkClearPoint(series, x, y, bBox, checkDistance) {\n            const chart = series.chart, seriesLabelOptions = series.options.label || {}, onArea = pick(seriesLabelOptions.onArea, !!series.area), findDistanceToOthers = (onArea || seriesLabelOptions.connectorAllowed), leastDistance = 16, boxesToAvoid = chart.boxesToAvoid;\n            let distToOthersSquared = Number.MAX_VALUE, // Distance to other graphs\n            distToPointSquared = Number.MAX_VALUE, dist, connectorPoint, withinRange, xDist, yDist, i, j;\n            /**\n             * Get the weight in order to determine the ideal position. Larger distance\n             * to other series gives more weight. Smaller distance to the actual point\n             * (connector points only) gives more weight.\n             * @private\n             */\n            function getWeight(distToOthersSquared, distToPointSquared) {\n                return distToOthersSquared - distToPointSquared;\n            }\n            // First check for collision with existing labels\n            for (i = 0; boxesToAvoid && i < boxesToAvoid.length; i += 1) {\n                if (intersectRect(boxesToAvoid[i], {\n                    left: x,\n                    right: x + bBox.width,\n                    top: y,\n                    bottom: y + bBox.height\n                })) {\n                    return false;\n                }\n            }\n            // For each position, check if the lines around the label intersect with any\n            // of the graphs.\n            for (i = 0; i < chart.series.length; i += 1) {\n                const serie = chart.series[i], points = serie.interpolatedPoints && [...serie.interpolatedPoints];\n                if (serie.visible && points) {\n                    // Avoid the sides of the plot area\n                    const stepY = chart.plotHeight / 10;\n                    for (let chartY = chart.plotTop; chartY <= chart.plotTop + chart.plotHeight; chartY += stepY) {\n                        points.unshift({\n                            chartX: chart.plotLeft,\n                            chartY\n                        });\n                        points.push({\n                            chartX: chart.plotLeft + chart.plotWidth,\n                            chartY\n                        });\n                    }\n                    for (j = 1; j < points.length; j += 1) {\n                        if (\n                        // To avoid processing, only check intersection if the X\n                        // values are close to the box.\n                        points[j].chartX >= x - leastDistance &&\n                            points[j - 1].chartX <= x + bBox.width +\n                                leastDistance\n                        /* @todo condition above is not the same as below\n                        (\n                            points[j].chartX >=\n                            (x - leastDistance)\n                        ) && (\n                            points[j - 1].chartX <=\n                            (x + bBox.width + leastDistance)\n                        ) */\n                        ) {\n                            // If any of the box sides intersect with the line, return.\n                            if (boxIntersectLine(x, y, bBox.width, bBox.height, points[j - 1].chartX, points[j - 1].chartY, points[j].chartX, points[j].chartY)) {\n                                return false;\n                            }\n                            // But if it is too far away (a padded box doesn't\n                            // intersect), also return.\n                            if (series === serie && !withinRange && checkDistance) {\n                                withinRange = boxIntersectLine(x - leastDistance, y - leastDistance, bBox.width + 2 * leastDistance, bBox.height + 2 * leastDistance, points[j - 1].chartX, points[j - 1].chartY, points[j].chartX, points[j].chartY);\n                            }\n                        }\n                        // Find the squared distance from the center of the label. On\n                        // area series, avoid its own graph.\n                        if ((findDistanceToOthers || withinRange) &&\n                            (series !== serie || onArea)) {\n                            xDist = x + bBox.width / 2 - points[j].chartX;\n                            yDist = y + bBox.height / 2 - points[j].chartY;\n                            distToOthersSquared = Math.min(distToOthersSquared, xDist * xDist + yDist * yDist);\n                        }\n                    }\n                    // Do we need a connector?\n                    if (!onArea &&\n                        findDistanceToOthers &&\n                        series === serie &&\n                        ((checkDistance && !withinRange) ||\n                            distToOthersSquared < Math.pow(seriesLabelOptions.connectorNeighbourDistance || 1, 2))) {\n                        for (j = 1; j < points.length; j += 1) {\n                            dist = Math.min((Math.pow(x + bBox.width / 2 - points[j].chartX, 2) +\n                                Math.pow(y + bBox.height / 2 - points[j].chartY, 2)), (Math.pow(x - points[j].chartX, 2) +\n                                Math.pow(y - points[j].chartY, 2)), (Math.pow(x + bBox.width - points[j].chartX, 2) +\n                                Math.pow(y - points[j].chartY, 2)), (Math.pow(x + bBox.width - points[j].chartX, 2) +\n                                Math.pow(y + bBox.height - points[j].chartY, 2)), (Math.pow(x - points[j].chartX, 2) +\n                                Math.pow(y + bBox.height - points[j].chartY, 2)));\n                            if (dist < distToPointSquared) {\n                                distToPointSquared = dist;\n                                connectorPoint = points[j];\n                            }\n                        }\n                        withinRange = true;\n                    }\n                }\n            }\n            return !checkDistance || withinRange ? {\n                x,\n                y,\n                weight: getWeight(distToOthersSquared, connectorPoint ? distToPointSquared : 0),\n                connectorPoint\n            } : false;\n        }\n        /**\n         * @private\n         */\n        function compose(ChartClass, SVGRendererClass) {\n            if (pushUnique(composed, 'SeriesLabel')) {\n                // Leave both events, we handle animation differently (#9815)\n                addEvent(ChartClass, 'load', onChartRedraw);\n                addEvent(ChartClass, 'redraw', onChartRedraw);\n                SVGRendererClass.prototype.symbols.connector = symbolConnector;\n                setOptions({ plotOptions: { series: { label: SeriesLabelDefaults } } });\n            }\n        }\n        /**\n         * The main initialize method that runs on chart level after initialization and\n         * redraw. It runs in  a timeout to prevent locking, and loops over all series,\n         * taking all series and labels into account when placing the labels.\n         *\n         * @private\n         * @function Highcharts.Chart#drawSeriesLabels\n         */\n        function drawSeriesLabels(chart) {\n            // Console.time('drawSeriesLabels');\n            chart.boxesToAvoid = [];\n            const labelSeries = chart.labelSeries || [], boxesToAvoid = chart.boxesToAvoid;\n            // Avoid data labels\n            chart.series.forEach((s) => (s.points || []).forEach((p) => (p.dataLabels || []).forEach((label) => {\n                const { width, height } = label.getBBox(), left = (label.translateX || 0) + (s.xAxis ? s.xAxis.pos : s.chart.plotLeft), top = (label.translateY || 0) + (s.yAxis ? s.yAxis.pos : s.chart.plotTop);\n                boxesToAvoid.push({\n                    left,\n                    top,\n                    right: left + width,\n                    bottom: top + height\n                });\n            })));\n            // Build the interpolated points\n            labelSeries.forEach(function (series) {\n                const seriesLabelOptions = series.options.label || {};\n                series.interpolatedPoints = getPointsOnGraph(series);\n                boxesToAvoid.push(...(seriesLabelOptions.boxesToAvoid || []));\n            });\n            chart.series.forEach(function (series) {\n                const labelOptions = series.options.label;\n                if (!labelOptions || (!series.xAxis && !series.yAxis)) {\n                    return;\n                }\n                const colorClass = ('highcharts-color-' + pick(series.colorIndex, 'none')), isNew = !series.labelBySeries, minFontSize = labelOptions.minFontSize, maxFontSize = labelOptions.maxFontSize, inverted = chart.inverted, paneLeft = (inverted ? series.yAxis.pos : series.xAxis.pos), paneTop = (inverted ? series.xAxis.pos : series.yAxis.pos), paneWidth = chart.inverted ? series.yAxis.len : series.xAxis.len, paneHeight = chart.inverted ? series.xAxis.len : series.yAxis.len, points = series.interpolatedPoints, onArea = pick(labelOptions.onArea, !!series.area), results = [], xData = series.xData || [];\n                let bBox, x, y, clearPoint, i, best, label = series.labelBySeries, dataExtremes, areaMin, areaMax;\n                // Stay within the area data bounds (#10038)\n                if (onArea && !inverted) {\n                    dataExtremes = [\n                        series.xAxis.toPixels(xData[0]),\n                        series.xAxis.toPixels(xData[xData.length - 1])\n                    ];\n                    areaMin = Math.min.apply(Math, dataExtremes);\n                    areaMax = Math.max.apply(Math, dataExtremes);\n                }\n                /**\n                 * @private\n                 */\n                function insidePane(x, y, bBox) {\n                    const leftBound = Math.max(paneLeft, pick(areaMin, -Infinity)), rightBound = Math.min(paneLeft + paneWidth, pick(areaMax, Infinity));\n                    return (x > leftBound &&\n                        x <= rightBound - bBox.width &&\n                        y >= paneTop &&\n                        y <= paneTop + paneHeight - bBox.height);\n                }\n                /**\n                 * @private\n                 */\n                function destroyLabel() {\n                    if (label) {\n                        series.labelBySeries = label.destroy();\n                    }\n                }\n                if (series.visible && !series.boosted && points) {\n                    if (!label) {\n                        let labelText = series.name;\n                        if (typeof labelOptions.format === 'string') {\n                            labelText = format(labelOptions.format, series, chart);\n                        }\n                        else if (labelOptions.formatter) {\n                            labelText = labelOptions.formatter.call(series);\n                        }\n                        series.labelBySeries = label = chart.renderer\n                            .label(labelText, 0, 0, 'connector', 0, 0, labelOptions.useHTML)\n                            .addClass('highcharts-series-label ' +\n                            'highcharts-series-label-' + series.index + ' ' +\n                            (series.options.className || '') + ' ' +\n                            colorClass);\n                        if (!chart.renderer.styledMode) {\n                            const color = typeof series.color === 'string' ?\n                                series.color : \"#666666\" /* Palette.neutralColor60 */;\n                            label.css(extend({\n                                color: onArea ?\n                                    chart.renderer.getContrast(color) :\n                                    color\n                            }, labelOptions.style || {}));\n                            label.attr({\n                                opacity: chart.renderer.forExport ? 1 : 0,\n                                stroke: series.color,\n                                'stroke-width': 1\n                            });\n                        }\n                        // Adapt label sizes to the sum of the data\n                        if (minFontSize && maxFontSize) {\n                            label.css({\n                                fontSize: labelFontSize(series, minFontSize, maxFontSize)\n                            });\n                        }\n                        label\n                            .attr({\n                            padding: 0,\n                            zIndex: 3\n                        })\n                            .add();\n                    }\n                    bBox = label.getBBox();\n                    bBox.width = Math.round(bBox.width);\n                    // Ideal positions are centered above or below a point on right side\n                    // of chart\n                    for (i = points.length - 1; i > 0; i -= 1) {\n                        if (onArea) {\n                            // Centered\n                            x = (points[i].chartCenterX ?? points[i].chartX) -\n                                bBox.width / 2;\n                            y = (points[i].chartCenterY ?? points[i].chartY) -\n                                bBox.height / 2;\n                            if (insidePane(x, y, bBox)) {\n                                best = checkClearPoint(series, x, y, bBox);\n                            }\n                            if (best) {\n                                results.push(best);\n                            }\n                        }\n                        else {\n                            // Right - up\n                            x = points[i].chartX + labelDistance;\n                            y = points[i].chartY - bBox.height - labelDistance;\n                            if (insidePane(x, y, bBox)) {\n                                best = checkClearPoint(series, x, y, bBox, true);\n                            }\n                            if (best) {\n                                results.push(best);\n                            }\n                            // Right - down\n                            x = points[i].chartX + labelDistance;\n                            y = points[i].chartY + labelDistance;\n                            if (insidePane(x, y, bBox)) {\n                                best = checkClearPoint(series, x, y, bBox, true);\n                            }\n                            if (best) {\n                                results.push(best);\n                            }\n                            // Left - down\n                            x = points[i].chartX - bBox.width - labelDistance;\n                            y = points[i].chartY + labelDistance;\n                            if (insidePane(x, y, bBox)) {\n                                best = checkClearPoint(series, x, y, bBox, true);\n                            }\n                            if (best) {\n                                results.push(best);\n                            }\n                            // Left - up\n                            x = points[i].chartX - bBox.width - labelDistance;\n                            y = points[i].chartY - bBox.height - labelDistance;\n                            if (insidePane(x, y, bBox)) {\n                                best = checkClearPoint(series, x, y, bBox, true);\n                            }\n                            if (best) {\n                                results.push(best);\n                            }\n                        }\n                    }\n                    // Brute force, try all positions on the chart in a 16x16 grid\n                    if (labelOptions.connectorAllowed && !results.length && !onArea) {\n                        for (x = paneLeft + paneWidth - bBox.width; x >= paneLeft; x -= 16) {\n                            for (y = paneTop; y < paneTop + paneHeight - bBox.height; y += 16) {\n                                clearPoint = checkClearPoint(series, x, y, bBox, true);\n                                if (clearPoint) {\n                                    results.push(clearPoint);\n                                }\n                            }\n                        }\n                    }\n                    if (results.length) {\n                        results.sort((a, b) => b.weight - a.weight);\n                        best = results[0];\n                        (chart.boxesToAvoid || []).push({\n                            left: best.x,\n                            right: best.x + bBox.width,\n                            top: best.y,\n                            bottom: best.y + bBox.height\n                        });\n                        // Move it if needed\n                        const dist = Math.sqrt(Math.pow(Math.abs(best.x - (label.x || 0)), 2) +\n                            Math.pow(Math.abs(best.y - (label.y || 0)), 2));\n                        if (dist && series.labelBySeries) {\n                            // Move fast and fade in - pure animation movement is\n                            // distractive...\n                            let attr = {\n                                opacity: chart.renderer.forExport ? 1 : 0,\n                                x: best.x,\n                                y: best.y\n                            }, anim = {\n                                opacity: 1\n                            };\n                            // ... unless we're just moving a short distance\n                            if (dist <= 10) {\n                                anim = {\n                                    x: attr.x,\n                                    y: attr.y\n                                };\n                                attr = {};\n                            }\n                            // Default initial animation to a fraction of the series\n                            // animation (#9396)\n                            let animationOptions;\n                            if (isNew) {\n                                animationOptions = animObject(series.options.animation);\n                                animationOptions.duration *= 0.2;\n                            }\n                            series.labelBySeries\n                                .attr(extend(attr, {\n                                anchorX: best.connectorPoint &&\n                                    (best.connectorPoint.plotX || 0) + paneLeft,\n                                anchorY: best.connectorPoint &&\n                                    (best.connectorPoint.plotY || 0) + paneTop\n                            }))\n                                .animate(anim, animationOptions);\n                            // Record closest point to stick to for sync redraw\n                            series.options.kdNow = true;\n                            series.buildKDTree();\n                            const closest = series.searchPoint({\n                                chartX: best.x,\n                                chartY: best.y\n                            }, true);\n                            if (closest) {\n                                label.closest = [\n                                    closest,\n                                    best.x - (closest.plotX || 0),\n                                    best.y - (closest.plotY || 0)\n                                ];\n                            }\n                        }\n                    }\n                    else {\n                        destroyLabel();\n                    }\n                }\n                else {\n                    destroyLabel();\n                }\n            });\n            fireEvent(chart, 'afterDrawSeriesLabels');\n            // Console.timeEnd('drawSeriesLabels');\n        }\n        /**\n         * Points to avoid. In addition to actual data points, the label should avoid\n         * interpolated positions.\n         *\n         * @private\n         * @function Highcharts.Series#getPointsOnGraph\n         */\n        function getPointsOnGraph(series) {\n            if (!series.xAxis && !series.yAxis) {\n                return;\n            }\n            const distance = 16, points = series.points, interpolated = [], graph = series.graph || series.area, node = graph && graph.element, inverted = series.chart.inverted, xAxis = series.xAxis, yAxis = series.yAxis, paneLeft = inverted ? yAxis.pos : xAxis.pos, paneTop = inverted ? xAxis.pos : yAxis.pos, paneHeight = inverted ? xAxis.len : yAxis.len, paneWidth = inverted ? yAxis.len : xAxis.len, seriesLabelOptions = series.options.label || {}, onArea = pick(seriesLabelOptions.onArea, !!series.area), translatedThreshold = yAxis.getThreshold(series.options.threshold), grid = {}, chartCenterKey = inverted ? 'chartCenterX' : 'chartCenterY';\n            let i, deltaX, deltaY, delta, len, n, j;\n            /**\n             * Push the point to the interpolated points, but only if that position in\n             * the grid has not been occupied. As a performance optimization, we divide\n             * the plot area into a grid and only add one point per series (#9815).\n             * @private\n             */\n            function pushDiscrete(point) {\n                const cellSize = 8, key = Math.round((point.plotX || 0) / cellSize) + ',' +\n                    Math.round((point.plotY || 0) / cellSize);\n                if (!grid[key]) {\n                    grid[key] = 1;\n                    interpolated.push(point);\n                }\n            }\n            // For splines, get the point at length (possible caveat: peaks are not\n            // correctly detected)\n            if (series.getPointSpline &&\n                node &&\n                node.getPointAtLength &&\n                !onArea &&\n                // Not performing well on complex series, node.getPointAtLength is too\n                // heavy (#9815)\n                points.length < (series.chart.plotSizeX || 0) / distance) {\n                // If it is animating towards a path definition, use that briefly, and\n                // reset\n                const d = graph.toD && graph.attr('d');\n                if (graph.toD) {\n                    graph.attr({ d: graph.toD });\n                }\n                len = node.getTotalLength();\n                for (i = 0; i < len; i += distance) {\n                    const domPoint = node.getPointAtLength(i), plotX = inverted ? paneWidth - domPoint.y : domPoint.x, plotY = inverted ? paneHeight - domPoint.x : domPoint.y;\n                    pushDiscrete({\n                        chartX: paneLeft + plotX,\n                        chartY: paneTop + plotY,\n                        plotX,\n                        plotY\n                    });\n                }\n                if (d) {\n                    graph.attr({ d });\n                }\n                // Last point\n                const point = points[points.length - 1], pos = point.pos();\n                pushDiscrete({\n                    chartX: paneLeft + (pos?.[0] || 0),\n                    chartY: paneTop + (pos?.[1] || 0)\n                });\n                // Interpolate\n            }\n            else {\n                len = points.length;\n                let last;\n                for (i = 0; i < len; i += 1) {\n                    const point = points[i], [plotX, plotY] = point.pos() || [], { plotHigh } = point;\n                    if (isNumber(plotX) && isNumber(plotY)) {\n                        const ctlPoint = {\n                            plotX,\n                            plotY,\n                            // Absolute coordinates so we can compare different panes\n                            chartX: paneLeft + plotX,\n                            chartY: paneTop + plotY\n                        };\n                        if (onArea) {\n                            // Vertically centered inside area\n                            if (plotHigh) {\n                                ctlPoint.plotY = plotHigh;\n                                ctlPoint.chartY = paneTop + plotHigh;\n                            }\n                            if (inverted) {\n                                ctlPoint.chartCenterX = paneLeft + paneWidth - ((plotHigh ? plotHigh : point.plotY || 0) +\n                                    pick(point.yBottom, translatedThreshold)) / 2;\n                            }\n                            else {\n                                ctlPoint.chartCenterY = paneTop + ((plotHigh ? plotHigh : plotY) +\n                                    pick(point.yBottom, translatedThreshold)) / 2;\n                            }\n                        }\n                        // Add interpolated points\n                        if (last) {\n                            deltaX = Math.abs(ctlPoint.chartX - last.chartX);\n                            deltaY = Math.abs(ctlPoint.chartY - last.chartY);\n                            delta = Math.max(deltaX, deltaY);\n                            if (delta > distance) {\n                                n = Math.ceil(delta / distance);\n                                for (j = 1; j < n; j += 1) {\n                                    pushDiscrete({\n                                        chartX: last.chartX +\n                                            (ctlPoint.chartX - last.chartX) * (j / n),\n                                        chartY: last.chartY +\n                                            (ctlPoint.chartY - last.chartY) * (j / n),\n                                        [chartCenterKey]: (last[chartCenterKey] || 0) +\n                                            ((ctlPoint[chartCenterKey] || 0) -\n                                                (last[chartCenterKey] || 0)) * (j / n),\n                                        plotX: (last.plotX || 0) +\n                                            (plotX - (last.plotX || 0)) * (j / n),\n                                        plotY: (last.plotY || 0) +\n                                            (plotY - (last.plotY || 0)) * (j / n)\n                                    });\n                                }\n                            }\n                        }\n                        // Add the real point in order to find positive and negative\n                        // peaks\n                        pushDiscrete(ctlPoint);\n                        last = ctlPoint;\n                    }\n                }\n            }\n            // Get the bounding box so we can do a quick check first if the bounding\n            // boxes overlap.\n            /*\n            interpolated.bBox = node.getBBox();\n            interpolated.bBox.x += paneLeft;\n            interpolated.bBox.y += paneTop;\n            */\n            return interpolated;\n        }\n        /**\n         * Overridable function to return series-specific font sizes for the labels. By\n         * default it returns bigger font sizes for series with the greater sum of y\n         * values.\n         * @private\n         */\n        function labelFontSize(series, minFontSize, maxFontSize) {\n            return minFontSize + (((series.sum || 0) / (series.chart.labelSeriesMaxSum || 0)) *\n                (maxFontSize - minFontSize)) + 'px';\n        }\n        /**\n         * Prepare drawing series labels.\n         * @private\n         */\n        function onChartRedraw(e) {\n            if (this.renderer) {\n                const chart = this;\n                let delay = animObject(chart.renderer.globalAnimation).duration;\n                chart.labelSeries = [];\n                chart.labelSeriesMaxSum = 0;\n                if (chart.seriesLabelTimer) {\n                    U.clearTimeout(chart.seriesLabelTimer);\n                }\n                // Which series should have labels\n                chart.series.forEach(function (series) {\n                    const seriesLabelOptions = series.options.label || {}, label = series.labelBySeries, closest = label && label.closest;\n                    if (seriesLabelOptions.enabled &&\n                        series.visible &&\n                        (series.graph || series.area) &&\n                        !series.boosted &&\n                        chart.labelSeries) {\n                        chart.labelSeries.push(series);\n                        if (seriesLabelOptions.minFontSize &&\n                            seriesLabelOptions.maxFontSize &&\n                            series.yData) {\n                            series.sum = series.yData.reduce((pv, cv) => (pv || 0) + (cv || 0), 0);\n                            chart.labelSeriesMaxSum = Math.max(chart.labelSeriesMaxSum || 0, series.sum || 0);\n                        }\n                        // The labels are processing heavy, wait until the animation is\n                        // done\n                        if (e.type === 'load') {\n                            delay = Math.max(delay, animObject(series.options.animation).duration);\n                        }\n                        // Keep the position updated to the axis while redrawing\n                        if (closest) {\n                            if (typeof closest[0].plotX !== 'undefined') {\n                                label.animate({\n                                    x: closest[0].plotX + closest[1],\n                                    y: closest[0].plotY + closest[2]\n                                });\n                            }\n                            else {\n                                label.attr({ opacity: 0 });\n                            }\n                        }\n                    }\n                });\n                chart.seriesLabelTimer = syncTimeout(function () {\n                    if (chart.series && chart.labelSeries) { // #7931, chart destroyed\n                        drawSeriesLabels(chart);\n                    }\n                }, chart.renderer.forExport || !delay ? 0 : delay);\n            }\n        }\n        /**\n         * General symbol definition for labels with connector.\n         * @private\n         */\n        function symbolConnector(x, y, w, h, options) {\n            const anchorX = options && options.anchorX, anchorY = options && options.anchorY;\n            let path, yOffset, lateral = w / 2;\n            if (isNumber(anchorX) && isNumber(anchorY)) {\n                path = [['M', anchorX, anchorY]];\n                // Prefer 45 deg connectors\n                yOffset = y - anchorY;\n                if (yOffset < 0) {\n                    yOffset = -h - yOffset;\n                }\n                if (yOffset < w) {\n                    lateral = anchorX < x + (w / 2) ? yOffset : w - yOffset;\n                }\n                // Anchor below label\n                if (anchorY > y + h) {\n                    path.push(['L', x + lateral, y + h]);\n                    // Anchor above label\n                }\n                else if (anchorY < y) {\n                    path.push(['L', x + lateral, y]);\n                    // Anchor left of label\n                }\n                else if (anchorX < x) {\n                    path.push(['L', x, y + h / 2]);\n                    // Anchor right of label\n                }\n                else if (anchorX > x + w) {\n                    path.push(['L', x + w, y + h / 2]);\n                }\n            }\n            return path || [];\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const SeriesLabel = {\n            compose\n        };\n        /* *\n         *\n         *  API Declarations\n         *\n         * */\n        /**\n         * Containing the position of a box that should be avoided by labels.\n         *\n         * @interface Highcharts.LabelIntersectBoxObject\n         */ /**\n        * @name Highcharts.LabelIntersectBoxObject#bottom\n        * @type {number}\n        */ /**\n        * @name Highcharts.LabelIntersectBoxObject#left\n        * @type {number}\n        */ /**\n        * @name Highcharts.LabelIntersectBoxObject#right\n        * @type {number}\n        */ /**\n        * @name Highcharts.LabelIntersectBoxObject#top\n        * @type {number}\n        */\n        (''); // Keeps doclets above in JS file\n\n        return SeriesLabel;\n    });\n    _registerModule(_modules, 'masters/modules/series-label.src.js', [_modules['Core/Globals.js'], _modules['Extensions/SeriesLabel/SeriesLabel.js']], function (Highcharts, SeriesLabel) {\n\n        const G = Highcharts;\n        SeriesLabel.compose(G.Chart, G.SVGRenderer);\n\n        return Highcharts;\n    });\n}));\n"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","win","dispatchEvent","detail","enabled","connectorAllowed","connectorNeighbourDistance","format","formatter","minFontSize","maxFontSize","onArea","style","fontSize","fontWeight","useHTML","boxesToAvoid","ccw","x1","y1","x2","y2","x3","y3","cw","intersectLine","x4","y4","boxIntersectLine","x","y","w","h","intersectRect","r1","r2","left","right","top","bottom","A","T","D","H","SeriesLabelDefaults","SLU","U","animObject","setOptions","composed","addEvent","extend","fireEvent","isNumber","pick","pushUnique","syncTimeout","checkClearPoint","series","bBox","checkDistance","chart","seriesLabelOptions","options","label","area","findDistanceToOthers","distToOthersSquared","Number","MAX_VALUE","distToPointSquared","dist","connectorPoint","withinRange","xDist","yDist","i","j","length","width","height","serie","points","interpolatedPoints","visible","stepY","plotHeight","chartY","plotTop","unshift","chartX","plotLeft","push","plotWidth","Math","min","pow","weight","onChartRedraw","e","renderer","delay","globalAnimation","duration","labelSeries","labelSeriesMaxSum","seriesLabelTimer","clearTimeout","forEach","labelBySeries","closest","graph","boosted","yData","sum","reduce","pv","cv","max","type","animation","plotX","animate","plotY","attr","opacity","drawSeriesLabels","s","p","dataLabels","getBBox","translateX","xAxis","pos","translateY","yAxis","getPointsOnGraph","delta","len","n","interpolated","node","element","inverted","paneLeft","paneTop","paneHeight","paneWidth","translatedThreshold","getThreshold","threshold","grid","chartCenterKey","pushDiscrete","point","key","round","getPointSpline","getPointAtLength","plotSizeX","d","toD","getTotalLength","domPoint","last","plotHigh","ctlPoint","chartCenterX","yBottom","chartCenterY","abs","ceil","labelOptions","colorClass","colorIndex","isNew","results","xData","clearPoint","best","dataExtremes","areaMin","areaMax","insidePane","leftBound","Infinity","rightBound","destroyLabel","destroy","toPixels","labelText","name","call","addClass","index","className","styledMode","color","css","getContrast","forExport","stroke","padding","zIndex","add","sort","a","b","sqrt","animationOptions","anim","anchorX","anchorY","kdNow","buildKDTree","searchPoint","symbolConnector","yOffset","lateral","compose","ChartClass","SVGRendererClass","prototype","symbols","connector","plotOptions","SeriesLabel","G","Chart","SVGRenderer"],"mappings":"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"}
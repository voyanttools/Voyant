{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v11.4.8 (2024-08-29)\n *\n * (c) 2016-2024 Highsoft AS\n * Authors: Jon Arild Nygard\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/wordcloud', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                Highcharts.win.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Series/DrawPointUtilities.js', [], function () {\n        /* *\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Handles the drawing of a component.\n         * Can be used for any type of component that reserves the graphic property,\n         * and provides a shouldDraw on its context.\n         *\n         * @private\n         *\n         * @todo add type checking.\n         * @todo export this function to enable usage\n         */\n        function draw(point, params) {\n            const { animatableAttribs, onComplete, css, renderer } = params;\n            const animation = (point.series && point.series.chart.hasRendered) ?\n                // Chart-level animation on updates\n                void 0 :\n                // Series-level animation on new points\n                (point.series &&\n                    point.series.options.animation);\n            let graphic = point.graphic;\n            params.attribs = {\n                ...params.attribs,\n                'class': point.getClassName()\n            } || {};\n            if ((point.shouldDraw())) {\n                if (!graphic) {\n                    if (params.shapeType === 'text') {\n                        graphic = renderer.text();\n                    }\n                    else if (params.shapeType === 'image') {\n                        graphic = renderer.image(params.imageUrl || '')\n                            .attr(params.shapeArgs || {});\n                    }\n                    else {\n                        graphic = renderer[params.shapeType](params.shapeArgs || {});\n                    }\n                    point.graphic = graphic;\n                    graphic.add(params.group);\n                }\n                if (css) {\n                    graphic.css(css);\n                }\n                graphic\n                    .attr(params.attribs)\n                    .animate(animatableAttribs, params.isNew ? false : animation, onComplete);\n            }\n            else if (graphic) {\n                const destroy = () => {\n                    point.graphic = graphic = (graphic && graphic.destroy());\n                    if (typeof onComplete === 'function') {\n                        onComplete();\n                    }\n                };\n                // Animate only runs complete callback if something was animated.\n                if (Object.keys(animatableAttribs).length) {\n                    graphic.animate(animatableAttribs, void 0, () => destroy());\n                }\n                else {\n                    destroy();\n                }\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const DrawPointUtilities = {\n            draw\n        };\n\n        return DrawPointUtilities;\n    });\n    _registerModule(_modules, 'Series/Wordcloud/WordcloudPoint.js', [_modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (SeriesRegistry, U) {\n        /* *\n         *\n         *  Experimental Highcharts module which enables visualization of a word cloud.\n         *\n         *  (c) 2016-2024 Highsoft AS\n         *  Authors: Jon Arild Nygard\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         * */\n        const { column: { prototype: { pointClass: ColumnPoint } } } = SeriesRegistry.seriesTypes;\n        const { extend } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        class WordcloudPoint extends ColumnPoint {\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            isValid() {\n                return true;\n            }\n        }\n        extend(WordcloudPoint.prototype, {\n            weight: 1\n        });\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return WordcloudPoint;\n    });\n    _registerModule(_modules, 'Series/Wordcloud/WordcloudSeriesDefaults.js', [], function () {\n        /* *\n         *\n         *  Experimental Highcharts module which enables visualization of a word cloud.\n         *\n         *  (c) 2016-2024 Highsoft AS\n         *  Authors: Jon Arild Nygard\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * A word cloud is a visualization of a set of words, where the size and\n         * placement of a word is determined by how it is weighted.\n         *\n         * @sample highcharts/demo/wordcloud Word Cloud chart\n         *\n         * @extends      plotOptions.column\n         * @excluding    allAreas, boostThreshold, clip, colorAxis, compare,\n         *               compareBase, crisp, cropThreshold, dataGrouping,\n         *               dataLabels, depth, dragDrop, edgeColor, findNearestPointBy,\n         *               getExtremesFromAll, grouping, groupPadding, groupZPadding,\n         *               joinBy, maxPointWidth, minPointLength, navigatorOptions,\n         *               negativeColor, pointInterval, pointIntervalUnit,\n         *               pointPadding, pointPlacement, pointRange, pointStart,\n         *               pointWidth, pointStart, pointWidth, shadow, showCheckbox,\n         *               showInNavigator, softThreshold, stacking, threshold,\n         *               zoneAxis, zones, dataSorting, boostBlending\n         * @product      highcharts\n         * @since        6.0.0\n         * @requires     modules/wordcloud\n         * @optionparent plotOptions.wordcloud\n         */\n        const WordcloudSeriesDefaults = {\n            /**\n             * If there is no space for a word on the playing field, then this\n             * option will allow the playing field to be extended to fit the word.\n             * If false then the word will be dropped from the visualization.\n             *\n             * NB! This option is currently not decided to be published in the API,\n             * and is therefore marked as private.\n             *\n             * @ignore-option\n             */\n            allowExtendPlayingField: true,\n            animation: {\n                /** @internal */\n                duration: 500\n            },\n            borderWidth: 0,\n            /**\n             * @ignore-option\n             */\n            clip: false, // Something goes wrong with clip. // @todo fix this\n            colorByPoint: true,\n            cropThreshold: Infinity,\n            /**\n             * A threshold determining the minimum font size that can be applied to\n             * a word.\n             */\n            minFontSize: 1,\n            /**\n             * The word with the largest weight will have a font size equal to this\n             * value. The font size of a word is the ratio between its weight and\n             * the largest occuring weight, multiplied with the value of\n             * maxFontSize.\n             */\n            maxFontSize: 25,\n            /**\n             * This option decides which algorithm is used for placement, and\n             * rotation of a word. The choice of algorith is therefore a crucial\n             * part of the resulting layout of the wordcloud. It is possible for\n             * users to add their own custom placement strategies for use in word\n             * cloud. Read more about it in our\n             * [documentation](https://www.highcharts.com/docs/chart-and-series-types/word-cloud-series#custom-placement-strategies)\n             *\n             * @validvalue [\"center\", \"random\"]\n             */\n            placementStrategy: 'center',\n            /**\n             * Rotation options for the words in the wordcloud.\n             *\n             * @sample highcharts/plotoptions/wordcloud-rotation\n             *         Word cloud with rotation\n             */\n            rotation: {\n                /**\n                 * The smallest degree of rotation for a word.\n                 */\n                from: 0,\n                /**\n                 * The number of possible orientations for a word, within the range\n                 * of `rotation.from` and `rotation.to`. Must be a number larger\n                 * than 0.\n                 */\n                orientations: 2,\n                /**\n                 * The largest degree of rotation for a word.\n                 */\n                to: 90\n            },\n            showInLegend: false,\n            /**\n             * Spiral used for placing a word after the initial position\n             * experienced a collision with either another word or the borders.\n             * It is possible for users to add their own custom spiralling\n             * algorithms for use in word cloud. Read more about it in our\n             * [documentation](https://www.highcharts.com/docs/chart-and-series-types/word-cloud-series#custom-spiralling-algorithm)\n             *\n             * @validvalue [\"archimedean\", \"rectangular\", \"square\"]\n             */\n            spiral: 'rectangular',\n            /**\n             * CSS styles for the words.\n             *\n             * @type    {Highcharts.CSSObject}\n             * @default {\"fontFamily\":\"sans-serif\", \"fontWeight\": \"900\"}\n             */\n            style: {\n                /** @ignore-option */\n                fontFamily: 'sans-serif',\n                /** @ignore-option */\n                fontWeight: '900',\n                /** @ignore-option */\n                whiteSpace: 'nowrap'\n            },\n            tooltip: {\n                followPointer: true,\n                pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.weight}</b><br/>'\n            }\n        };\n        /**\n         * A `wordcloud` series. If the [type](#series.wordcloud.type) option is not\n         * specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.wordcloud\n         * @exclude   dataSorting, boostThreshold, boostBlending\n         * @product   highcharts\n         * @requires  modules/wordcloud\n         * @apioption series.wordcloud\n         */\n        /**\n         * An array of data points for the series. For the `wordcloud` series type,\n         * points can be given in the following ways:\n         *\n         * 1. An array of arrays with 2 values. In this case, the values correspond to\n         *    `name,weight`.\n         *    ```js\n         *    data: [\n         *        ['Lorem', 4],\n         *        ['Ipsum', 1]\n         *    ]\n         *    ```\n         *\n         * 2. An array of objects with named values. The following snippet shows only a\n         *    few settings, see the complete options set below. If the total number of\n         *    data points exceeds the series'\n         *    [turboThreshold](#series.arearange.turboThreshold), this option is not\n         *    available.\n         *    ```js\n         *    data: [{\n         *        name: \"Lorem\",\n         *        weight: 4\n         *    }, {\n         *        name: \"Ipsum\",\n         *        weight: 1\n         *    }]\n         *    ```\n         *\n         * @type      {Array<Array<string,number>|*>}\n         * @extends   series.line.data\n         * @excluding drilldown, marker, x, y\n         * @product   highcharts\n         * @apioption series.wordcloud.data\n         */\n        /**\n         * The name decides the text for a word.\n         *\n         * @type      {string}\n         * @since     6.0.0\n         * @product   highcharts\n         * @apioption series.wordcloud.data.name\n         */\n        /**\n         * The weighting of a word. The weight decides the relative size of a word\n         * compared to the rest of the collection.\n         *\n         * @type      {number}\n         * @since     6.0.0\n         * @product   highcharts\n         * @apioption series.wordcloud.data.weight\n         */\n        ''; // Detach doclets above\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return WordcloudSeriesDefaults;\n    });\n    _registerModule(_modules, 'Series/Wordcloud/WordcloudUtils.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  Experimental Highcharts module which enables visualization of a word cloud.\n         *\n         *  (c) 2016-2024 Highsoft AS\n         *  Authors: Jon Arild Nygard\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         * */\n        const { deg2rad } = H;\n        const { extend, find, isNumber, isObject, merge } = U;\n        /* *\n         *\n         * Functions\n         *\n         * */\n        /**\n         * Detects if there is a collision between two rectangles.\n         *\n         * @private\n         * @function isRectanglesIntersecting\n         *\n         * @param {Highcharts.PolygonBoxObject} r1\n         * First rectangle.\n         *\n         * @param {Highcharts.PolygonBoxObject} r2\n         * Second rectangle.\n         *\n         * @return {boolean}\n         * Returns true if the rectangles overlap.\n         */\n        function isRectanglesIntersecting(r1, r2) {\n            return !(r2.left > r1.right ||\n                r2.right < r1.left ||\n                r2.top > r1.bottom ||\n                r2.bottom < r1.top);\n        }\n        /**\n         * Calculates the normals to a line between two points.\n         *\n         * @private\n         * @function getNormals\n         * @param {Highcharts.PolygonPointObject} p1\n         *        Start point for the line. Array of x and y value.\n         * @param {Highcharts.PolygonPointObject} p2\n         *        End point for the line. Array of x and y value.\n         * @return {Highcharts.PolygonObject}\n         *         Returns the two normals in an array.\n         */\n        function getNormals(p1, p2) {\n            const dx = p2[0] - p1[0], // X2 - x1\n            dy = p2[1] - p1[1]; // Y2 - y1\n            return [\n                [-dy, dx],\n                [dy, -dx]\n            ];\n        }\n        /**\n         * @private\n         */\n        function getAxesFromPolygon(polygon) {\n            let points, axes = polygon.axes || [];\n            if (!axes.length) {\n                axes = [];\n                points = points = polygon.concat([polygon[0]]);\n                points.reduce((p1, p2) => {\n                    const normals = getNormals(p1, p2), axis = normals[0]; // Use the left normal as axis.\n                    // Check that the axis is unique.\n                    if (!find(axes, (existing) => existing[0] === axis[0] &&\n                        existing[1] === axis[1])) {\n                        axes.push(axis);\n                    }\n                    // Return p2 to be used as p1 in next iteration.\n                    return p2;\n                });\n                polygon.axes = axes;\n            }\n            return axes;\n        }\n        /**\n         * Projects a polygon onto a coordinate.\n         *\n         * @private\n         * @function project\n         * @param {Highcharts.PolygonObject} polygon\n         * Array of points in a polygon.\n         * @param {Highcharts.PolygonPointObject} target\n         * The coordinate of pr\n         */\n        function project(polygon, target) {\n            const products = polygon.map((point) => {\n                const ax = point[0], ay = point[1], bx = target[0], by = target[1];\n                return ax * bx + ay * by;\n            });\n            return {\n                min: Math.min.apply(this, products),\n                max: Math.max.apply(this, products)\n            };\n        }\n        /**\n         * @private\n         */\n        function isPolygonsOverlappingOnAxis(axis, polygon1, polygon2) {\n            const projection1 = project(polygon1, axis), projection2 = project(polygon2, axis), isOverlapping = !(projection2.min > projection1.max ||\n                projection2.max < projection1.min);\n            return !isOverlapping;\n        }\n        /**\n         * Checks whether two convex polygons are colliding by using the Separating\n         * Axis Theorem.\n         *\n         * @private\n         * @function isPolygonsColliding\n         * @param {Highcharts.PolygonObject} polygon1\n         *        First polygon.\n         *\n         * @param {Highcharts.PolygonObject} polygon2\n         *        Second polygon.\n         *\n         * @return {boolean}\n         *         Returns true if they are colliding, otherwise false.\n         */\n        function isPolygonsColliding(polygon1, polygon2) {\n            // Get the axis from both polygons.\n            const axes1 = getAxesFromPolygon(polygon1), axes2 = getAxesFromPolygon(polygon2), axes = axes1.concat(axes2), overlappingOnAllAxes = !find(axes, (axis) => isPolygonsOverlappingOnAxis(axis, polygon1, polygon2));\n            return overlappingOnAllAxes;\n        }\n        /**\n         * Detects if a word collides with any previously placed words.\n         *\n         * @private\n         * @function intersectsAnyWord\n         *\n         * @param {Highcharts.Point} point\n         * Point which the word is connected to.\n         *\n         * @param {Array<Highcharts.Point>} points\n         * Previously placed points to check against.\n         *\n         * @return {boolean}\n         * Returns true if there is collision.\n         */\n        function intersectsAnyWord(point, points) {\n            const rect = point.rect, polygon = point.polygon, lastCollidedWith = point.lastCollidedWith, isIntersecting = function (p) {\n                let result = isRectanglesIntersecting(rect, p.rect);\n                if (result &&\n                    (point.rotation % 90 || p.rotation % 90)) {\n                    result = isPolygonsColliding(polygon, p.polygon);\n                }\n                return result;\n            };\n            let intersects = false;\n            // If the point has already intersected a different point, chances are\n            // they are still intersecting. So as an enhancement we check this\n            // first.\n            if (lastCollidedWith) {\n                intersects = isIntersecting(lastCollidedWith);\n                // If they no longer intersects, remove the cache from the point.\n                if (!intersects) {\n                    delete point.lastCollidedWith;\n                }\n            }\n            // If not already found, then check if we can find a point that is\n            // intersecting.\n            if (!intersects) {\n                intersects = !!find(points, function (p) {\n                    const result = isIntersecting(p);\n                    if (result) {\n                        point.lastCollidedWith = p;\n                    }\n                    return result;\n                });\n            }\n            return intersects;\n        }\n        /**\n         * Gives a set of cordinates for an Archimedian Spiral.\n         *\n         * @private\n         * @function archimedeanSpiral\n         *\n         * @param {number} attempt\n         * How far along the spiral we have traversed.\n         *\n         * @param {Highcharts.WordcloudSpiralParamsObject} [params]\n         * Additional parameters.\n         *\n         * @return {boolean|Highcharts.PositionObject}\n         * Resulting coordinates, x and y. False if the word should be dropped from\n         * the visualization.\n         */\n        function archimedeanSpiral(attempt, params) {\n            const field = params.field, maxDelta = (field.width * field.width) + (field.height * field.height), t = attempt * 0.8; // 0.2 * 4 = 0.8. Enlarging the spiral.\n            let result = false;\n            // Emergency brake. TODO make spiralling logic more foolproof.\n            if (attempt <= 10000) {\n                result = {\n                    x: t * Math.cos(t),\n                    y: t * Math.sin(t)\n                };\n                if (!(Math.min(Math.abs(result.x), Math.abs(result.y)) < maxDelta)) {\n                    result = false;\n                }\n            }\n            return result;\n        }\n        /**\n         * Gives a set of coordinates for an rectangular spiral.\n         *\n         * @private\n         * @function squareSpiral\n         *\n         * @param {number} attempt\n         * How far along the spiral we have traversed.\n         *\n         * @param {Highcharts.WordcloudSpiralParamsObject} [params]\n         * Additional parameters.\n         *\n         * @return {boolean|Highcharts.PositionObject}\n         * Resulting coordinates, x and y. False if the word should be dropped from\n         * the visualization.\n         */\n        function squareSpiral(attempt, \n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        params) {\n            const a = attempt * 4, k = Math.ceil((Math.sqrt(a) - 1) / 2), isBoolean = (x) => (typeof x === 'boolean');\n            let t = 2 * k + 1, m = Math.pow(t, 2), result = false;\n            t -= 1;\n            if (attempt <= 10000) {\n                if (isBoolean(result) && a >= m - t) {\n                    result = {\n                        x: k - (m - a),\n                        y: -k\n                    };\n                }\n                m -= t;\n                if (isBoolean(result) && a >= m - t) {\n                    result = {\n                        x: -k,\n                        y: -k + (m - a)\n                    };\n                }\n                m -= t;\n                if (isBoolean(result)) {\n                    if (a >= m - t) {\n                        result = {\n                            x: -k + (m - a),\n                            y: k\n                        };\n                    }\n                    else {\n                        result = {\n                            x: k,\n                            y: k - (m - a - t)\n                        };\n                    }\n                }\n                result.x *= 5;\n                result.y *= 5;\n            }\n            return result;\n        }\n        /**\n         * Gives a set of coordinates for an rectangular spiral.\n         *\n         * @private\n         * @function rectangularSpiral\n         *\n         * @param {number} attempt\n         * How far along the spiral we have traversed.\n         *\n         * @param {Highcharts.WordcloudSpiralParamsObject} [params]\n         * Additional parameters.\n         *\n         * @return {boolean|Higcharts.PositionObject}\n         * Resulting coordinates, x and y. False if the word should be dropped from\n         * the visualization.\n         */\n        function rectangularSpiral(attempt, params) {\n            const result = squareSpiral(attempt, params), field = params.field;\n            if (result) {\n                result.x *= field.ratioX;\n                result.y *= field.ratioY;\n            }\n            return result;\n        }\n        /**\n         * @private\n         * @function getRandomPosition\n         *\n         * @param {number} size\n         * Random factor.\n         *\n         * @return {number}\n         * Random position.\n         */\n        function getRandomPosition(size) {\n            return Math.round((size * (Math.random() + 0.5)) / 2);\n        }\n        /**\n         * Calculates the proper scale to fit the cloud inside the plotting area.\n         *\n         * @private\n         * @function getScale\n         *\n         * @param {number} targetWidth\n         * Width of target area.\n         *\n         * @param {number} targetHeight\n         * Height of target area.\n         *\n         * @param {Object} field\n         * The playing field.\n         *\n         * @return {number}\n         * Returns the value to scale the playing field up to the size of the target\n         * area.\n         */\n        function getScale(targetWidth, targetHeight, field) {\n            const height = Math.max(Math.abs(field.top), Math.abs(field.bottom)) * 2, width = Math.max(Math.abs(field.left), Math.abs(field.right)) * 2, scaleX = width > 0 ? 1 / width * targetWidth : 1, scaleY = height > 0 ? 1 / height * targetHeight : 1;\n            return Math.min(scaleX, scaleY);\n        }\n        /**\n         * Calculates what is called the playing field. The field is the area which\n         * all the words are allowed to be positioned within. The area is\n         * proportioned to match the target aspect ratio.\n         *\n         * @private\n         * @function getPlayingField\n         *\n         * @param {number} targetWidth\n         * Width of the target area.\n         *\n         * @param {number} targetHeight\n         * Height of the target area.\n         *\n         * @param {Array<Highcharts.Point>} data\n         * Array of points.\n         *\n         * @param {Object} data.dimensions\n         * The height and width of the word.\n         *\n         * @return {Object}\n         * The width and height of the playing field.\n         */\n        function getPlayingField(targetWidth, targetHeight, data) {\n            const info = data.reduce(function (obj, point) {\n                const dimensions = point.dimensions, x = Math.max(dimensions.width, dimensions.height);\n                // Find largest height.\n                obj.maxHeight = Math.max(obj.maxHeight, dimensions.height);\n                // Find largest width.\n                obj.maxWidth = Math.max(obj.maxWidth, dimensions.width);\n                // Sum up the total maximum area of all the words.\n                obj.area += x * x;\n                return obj;\n            }, {\n                maxHeight: 0,\n                maxWidth: 0,\n                area: 0\n            }), \n            /**\n             * Use largest width, largest height, or root of total area to give\n             * size to the playing field.\n             */\n            x = Math.max(info.maxHeight, // Have enough space for the tallest word\n            info.maxWidth, // Have enough space for the broadest word\n            // Adjust 15% to account for close packing of words\n            Math.sqrt(info.area) * 0.85), ratioX = targetWidth > targetHeight ? targetWidth / targetHeight : 1, ratioY = targetHeight > targetWidth ? targetHeight / targetWidth : 1;\n            return {\n                width: x * ratioX,\n                height: x * ratioY,\n                ratioX: ratioX,\n                ratioY: ratioY\n            };\n        }\n        /**\n         * Calculates a number of degrees to rotate, based upon a number of\n         * orientations within a range from-to.\n         *\n         * @private\n         * @function getRotation\n         *\n         * @param {number} [orientations]\n         * Number of orientations.\n         *\n         * @param {number} [index]\n         * Index of point, used to decide orientation.\n         *\n         * @param {number} [from]\n         * The smallest degree of rotation.\n         *\n         * @param {number} [to]\n         * The largest degree of rotation.\n         *\n         * @return {boolean|number}\n         * Returns the resulting rotation for the word. Returns false if invalid\n         * input parameters.\n         */\n        function getRotation(orientations, index, from, to) {\n            let result = false, // Default to false\n            range, intervals, orientation;\n            // Check if we have valid input parameters.\n            if (isNumber(orientations) &&\n                isNumber(index) &&\n                isNumber(from) &&\n                isNumber(to) &&\n                orientations > 0 &&\n                index > -1 &&\n                to > from) {\n                range = to - from;\n                intervals = range / (orientations - 1 || 1);\n                orientation = index % orientations;\n                result = from + (orientation * intervals);\n            }\n            return result;\n        }\n        /**\n         * Calculates the spiral positions and store them in scope for quick access.\n         *\n         * @private\n         * @function getSpiral\n         *\n         * @param {Function} fn\n         * The spiral function.\n         *\n         * @param {Object} params\n         * Additional parameters for the spiral.\n         *\n         * @return {Function}\n         * Function with access to spiral positions.\n         */\n        function getSpiral(fn, params) {\n            const length = 10000, arr = [];\n            for (let i = 1; i < length; i++) {\n                // @todo unnecessary amount of precalculation\n                arr.push(fn(i, params));\n            }\n            return (attempt) => (attempt <= length ? arr[attempt - 1] : false);\n        }\n        /**\n         * Detects if a word is placed outside the playing field.\n         *\n         * @private\n         * @function outsidePlayingField\n         *\n         * @param {Highcharts.PolygonBoxObject} rect\n         * The word box.\n         *\n         * @param {Highcharts.WordcloudFieldObject} field\n         * The width and height of the playing field.\n         *\n         * @return {boolean}\n         * Returns true if the word is placed outside the field.\n         */\n        function outsidePlayingField(rect, field) {\n            const playingField = {\n                left: -(field.width / 2),\n                right: field.width / 2,\n                top: -(field.height / 2),\n                bottom: field.height / 2\n            };\n            return !(playingField.left < rect.left &&\n                playingField.right > rect.right &&\n                playingField.top < rect.top &&\n                playingField.bottom > rect.bottom);\n        }\n        /**\n         * @private\n         */\n        function movePolygon(deltaX, deltaY, polygon) {\n            return polygon.map(function (point) {\n                return [\n                    point[0] + deltaX,\n                    point[1] + deltaY\n                ];\n            });\n        }\n        /**\n         * Check if a point intersects with previously placed words, or if it goes\n         * outside the field boundaries. If a collision, then try to adjusts the\n         * position.\n         *\n         * @private\n         * @function intersectionTesting\n         *\n         * @param {Highcharts.Point} point\n         * Point to test for intersections.\n         *\n         * @param {Highcharts.WordcloudTestOptionsObject} options\n         * Options object.\n         *\n         * @return {boolean|Highcharts.PositionObject}\n         * Returns an object with how much to correct the positions. Returns false\n         * if the word should not be placed at all.\n         */\n        function intersectionTesting(point, options) {\n            const placed = options.placed, field = options.field, rectangle = options.rectangle, polygon = options.polygon, spiral = options.spiral, \n            // Make a copy to update values during intersection testing.\n            rect = point.rect = extend({}, rectangle);\n            let attempt = 1, delta = {\n                x: 0,\n                y: 0\n            };\n            point.polygon = polygon;\n            point.rotation = options.rotation;\n            /* While w intersects any previously placed words:\n                do {\n                move w a little bit along a spiral path\n                } while any part of w is outside the playing field and\n                        the spiral radius is still smallish */\n            while (delta !== false &&\n                (intersectsAnyWord(point, placed) ||\n                    outsidePlayingField(rect, field))) {\n                delta = spiral(attempt);\n                if (isObject(delta)) {\n                    // Update the DOMRect with new positions.\n                    rect.left = rectangle.left + delta.x;\n                    rect.right = rectangle.right + delta.x;\n                    rect.top = rectangle.top + delta.y;\n                    rect.bottom = rectangle.bottom + delta.y;\n                    point.polygon = movePolygon(delta.x, delta.y, polygon);\n                }\n                attempt++;\n            }\n            return delta;\n        }\n        /**\n         * Extends the playing field to have enough space to fit a given word.\n         *\n         * @private\n         * @function extendPlayingField\n         *\n         * @param {Highcharts.WordcloudFieldObject} field\n         * The width, height and ratios of a playing field.\n         *\n         * @param {Highcharts.PolygonBoxObject} rectangle\n         * The bounding box of the word to add space for.\n         *\n         * @return {Highcharts.WordcloudFieldObject}\n         * Returns the extended playing field with updated height and width.\n         */\n        function extendPlayingField(field, rectangle) {\n            let height, width, ratioX, ratioY, x, extendWidth, extendHeight, result;\n            if (isObject(field) && isObject(rectangle)) {\n                height = (rectangle.bottom - rectangle.top);\n                width = (rectangle.right - rectangle.left);\n                ratioX = field.ratioX;\n                ratioY = field.ratioY;\n                // Use the same variable to extend both the height and width.\n                x = ((width * ratioX) > (height * ratioY)) ? width : height;\n                // Multiply variable with ratios to preserve aspect ratio.\n                extendWidth = x * ratioX;\n                extendHeight = x * ratioY;\n                // Calculate the size of the new field after adding\n                // space for the word.\n                result = merge(field, {\n                    // Add space on the left and right.\n                    width: field.width + (extendWidth * 2),\n                    // Add space on the top and bottom.\n                    height: field.height + (extendHeight * 2)\n                });\n            }\n            else {\n                result = field;\n            }\n            // Return the new extended field.\n            return result;\n        }\n        /**\n         * If a rectangle is outside a give field, then the boundaries of the field\n         * is adjusted accordingly. Modifies the field object which is passed as the\n         * first parameter.\n         *\n         * @private\n         * @function updateFieldBoundaries\n         *\n         * @param {Highcharts.WordcloudFieldObject} field\n         * The bounding box of a playing field.\n         *\n         * @param {Highcharts.PolygonBoxObject} rectangle\n         * The bounding box for a placed point.\n         *\n         * @return {Highcharts.WordcloudFieldObject}\n         * Returns a modified field object.\n         */\n        function updateFieldBoundaries(field, rectangle) {\n            // @todo improve type checking.\n            if (!isNumber(field.left) || field.left > rectangle.left) {\n                field.left = rectangle.left;\n            }\n            if (!isNumber(field.right) || field.right < rectangle.right) {\n                field.right = rectangle.right;\n            }\n            if (!isNumber(field.top) || field.top > rectangle.top) {\n                field.top = rectangle.top;\n            }\n            if (!isNumber(field.bottom) || field.bottom < rectangle.bottom) {\n                field.bottom = rectangle.bottom;\n            }\n            return field;\n        }\n        /**\n         * Alternative solution to correctFloat.\n         * E.g Highcharts.correctFloat(123, 2) returns 120, when it should be 123.\n         *\n         * @private\n         * @function correctFloat\n         */\n        function correctFloat(number, precision) {\n            const p = isNumber(precision) ? precision : 14, magnitude = Math.pow(10, p);\n            return Math.round(number * magnitude) / magnitude;\n        }\n        /**\n         * @private\n         */\n        function getBoundingBoxFromPolygon(points) {\n            return points.reduce(function (obj, point) {\n                const x = point[0], y = point[1];\n                obj.left = Math.min(x, obj.left);\n                obj.right = Math.max(x, obj.right);\n                obj.bottom = Math.max(y, obj.bottom);\n                obj.top = Math.min(y, obj.top);\n                return obj;\n            }, {\n                left: Number.MAX_VALUE,\n                right: -Number.MAX_VALUE,\n                bottom: -Number.MAX_VALUE,\n                top: Number.MAX_VALUE\n            });\n        }\n        /**\n         * @private\n         */\n        function getPolygon(x, y, width, height, rotation) {\n            const origin = [x, y], left = x - (width / 2), right = x + (width / 2), top = y - (height / 2), bottom = y + (height / 2), polygon = [\n                [left, top],\n                [right, top],\n                [right, bottom],\n                [left, bottom]\n            ];\n            return polygon.map(function (point) {\n                return rotate2DToPoint(point, origin, -rotation);\n            });\n        }\n        /**\n         * Rotates a point clockwise around the origin.\n         *\n         * @private\n         * @function rotate2DToOrigin\n         * @param {Highcharts.PolygonPointObject} point\n         *        The x and y coordinates for the point.\n         * @param {number} angle\n         *        The angle of rotation.\n         * @return {Highcharts.PolygonPointObject}\n         *         The x and y coordinate for the rotated point.\n         */\n        function rotate2DToOrigin(point, angle) {\n            const x = point[0], y = point[1], rad = deg2rad * -angle, cosAngle = Math.cos(rad), sinAngle = Math.sin(rad);\n            return [\n                correctFloat(x * cosAngle - y * sinAngle),\n                correctFloat(x * sinAngle + y * cosAngle)\n            ];\n        }\n        /**\n         * Rotate a point clockwise around another point.\n         *\n         * @private\n         * @function rotate2DToPoint\n         * @param {Highcharts.PolygonPointObject} point\n         *        The x and y coordinates for the point.\n         * @param {Highcharts.PolygonPointObject} origin\n         *        The point to rotate around.\n         * @param {number} angle\n         *        The angle of rotation.\n         * @return {Highcharts.PolygonPointObject}\n         *         The x and y coordinate for the rotated point.\n         */\n        function rotate2DToPoint(point, origin, angle) {\n            const x = point[0] - origin[0], y = point[1] - origin[1], rotated = rotate2DToOrigin([x, y], angle);\n            return [\n                rotated[0] + origin[0],\n                rotated[1] + origin[1]\n            ];\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const WordcloudUtils = {\n            archimedeanSpiral,\n            extendPlayingField,\n            getBoundingBoxFromPolygon,\n            getPlayingField,\n            getPolygon,\n            getRandomPosition,\n            getRotation,\n            getScale,\n            getSpiral,\n            intersectionTesting,\n            isPolygonsColliding,\n            isRectanglesIntersecting,\n            rectangularSpiral,\n            rotate2DToOrigin,\n            rotate2DToPoint,\n            squareSpiral,\n            updateFieldBoundaries\n        };\n\n        return WordcloudUtils;\n    });\n    _registerModule(_modules, 'Series/Wordcloud/WordcloudSeries.js', [_modules['Series/DrawPointUtilities.js'], _modules['Core/Globals.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js'], _modules['Series/Wordcloud/WordcloudPoint.js'], _modules['Series/Wordcloud/WordcloudSeriesDefaults.js'], _modules['Series/Wordcloud/WordcloudUtils.js']], function (DPU, H, SeriesRegistry, U, WordcloudPoint, WordcloudSeriesDefaults, WU) {\n        /* *\n         *\n         *  Experimental Highcharts module which enables visualization of a word cloud.\n         *\n         *  (c) 2016-2024 Highsoft AS\n         *  Authors: Jon Arild Nygard\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         * */\n        const { noop } = H;\n        const { column: ColumnSeries } = SeriesRegistry.seriesTypes;\n        const { extend, isArray, isNumber, isObject, merge } = U;\n        const { archimedeanSpiral, extendPlayingField, getBoundingBoxFromPolygon, getPlayingField, getPolygon, getRandomPosition, getRotation, getScale, getSpiral, intersectionTesting, isPolygonsColliding, rectangularSpiral, rotate2DToOrigin, rotate2DToPoint, squareSpiral, updateFieldBoundaries } = WU;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.wordcloud\n         *\n         * @augments Highcharts.Series\n         */\n        class WordcloudSeries extends ColumnSeries {\n            /**\n             *\n             * Functions\n             *\n             */\n            pointAttribs(point, state) {\n                const attribs = H.seriesTypes.column.prototype\n                    .pointAttribs.call(this, point, state);\n                delete attribs.stroke;\n                delete attribs['stroke-width'];\n                return attribs;\n            }\n            /**\n             * Calculates the fontSize of a word based on its weight.\n             *\n             * @private\n             * @function Highcharts.Series#deriveFontSize\n             *\n             * @param {number} [relativeWeight=0]\n             * The weight of the word, on a scale 0-1.\n             *\n             * @param {number} [maxFontSize=1]\n             * The maximum font size of a word.\n             *\n             * @param {number} [minFontSize=1]\n             * The minimum font size of a word.\n             *\n             * @return {number}\n             * Returns the resulting fontSize of a word. If minFontSize is larger then\n             * maxFontSize the result will equal minFontSize.\n             */\n            deriveFontSize(relativeWeight, maxFontSize, minFontSize) {\n                const weight = isNumber(relativeWeight) ? relativeWeight : 0, max = isNumber(maxFontSize) ? maxFontSize : 1, min = isNumber(minFontSize) ? minFontSize : 1;\n                return Math.floor(Math.max(min, weight * max));\n            }\n            drawPoints() {\n                const series = this, hasRendered = series.hasRendered, xAxis = series.xAxis, yAxis = series.yAxis, chart = series.chart, group = series.group, options = series.options, animation = options.animation, allowExtendPlayingField = options.allowExtendPlayingField, renderer = chart.renderer, placed = [], placementStrategy = series.placementStrategy[options.placementStrategy], rotation = options.rotation, weights = series.points.map(function (p) {\n                    return p.weight;\n                }), maxWeight = Math.max.apply(null, weights), \n                // `concat()` prevents from sorting the original array.\n                points = series.points.concat().sort((a, b) => (b.weight - a.weight // Sort descending\n                ));\n                let testElement = renderer.text().add(group), field;\n                // Reset the scale before finding the dimensions (#11993).\n                // SVGGRaphicsElement.getBBox() (used in SVGElement.getBBox(boolean))\n                // returns slightly different values for the same element depending on\n                // whether it is rendered in a group which has already defined scale\n                // (e.g. 6) or in the group without a scale (scale = 1).\n                series.group.attr({\n                    scaleX: 1,\n                    scaleY: 1\n                });\n                // Get the dimensions for each word.\n                // Used in calculating the playing field.\n                for (const point of points) {\n                    const relativeWeight = 1 / maxWeight * point.weight, fontSize = series.deriveFontSize(relativeWeight, options.maxFontSize, options.minFontSize), css = extend({\n                        fontSize: fontSize + 'px'\n                    }, options.style);\n                    testElement.css(css).attr({\n                        x: 0,\n                        y: 0,\n                        text: point.name\n                    });\n                    const bBox = testElement.getBBox(true);\n                    point.dimensions = {\n                        height: bBox.height,\n                        width: bBox.width\n                    };\n                }\n                // Calculate the playing field.\n                field = getPlayingField(xAxis.len, yAxis.len, points);\n                const spiral = getSpiral(series.spirals[options.spiral], {\n                    field: field\n                });\n                // Draw all the points.\n                for (const point of points) {\n                    const relativeWeight = 1 / maxWeight * point.weight, fontSize = series.deriveFontSize(relativeWeight, options.maxFontSize, options.minFontSize), css = extend({\n                        fontSize: fontSize + 'px'\n                    }, options.style), placement = placementStrategy(point, {\n                        data: points,\n                        field: field,\n                        placed: placed,\n                        rotation: rotation\n                    }), attr = extend(series.pointAttribs(point, (point.selected && 'select')), {\n                        align: 'center',\n                        'alignment-baseline': 'middle',\n                        'dominant-baseline': 'middle', // #15973: Firefox\n                        x: placement.x,\n                        y: placement.y,\n                        text: point.name,\n                        rotation: isNumber(placement.rotation) ?\n                            placement.rotation :\n                            void 0\n                    }), polygon = getPolygon(placement.x, placement.y, point.dimensions.width, point.dimensions.height, placement.rotation), rectangle = getBoundingBoxFromPolygon(polygon);\n                    let delta = intersectionTesting(point, {\n                        rectangle: rectangle,\n                        polygon: polygon,\n                        field: field,\n                        placed: placed,\n                        spiral: spiral,\n                        rotation: placement.rotation\n                    }), animate;\n                    // If there is no space for the word, extend the playing field.\n                    if (!delta && allowExtendPlayingField) {\n                        // Extend the playing field to fit the word.\n                        field = extendPlayingField(field, rectangle);\n                        // Run intersection testing one more time to place the word.\n                        delta = intersectionTesting(point, {\n                            rectangle: rectangle,\n                            polygon: polygon,\n                            field: field,\n                            placed: placed,\n                            spiral: spiral,\n                            rotation: placement.rotation\n                        });\n                    }\n                    // Check if point was placed, if so delete it, otherwise place it\n                    // on the correct positions.\n                    if (isObject(delta)) {\n                        attr.x = (attr.x || 0) + delta.x;\n                        attr.y = (attr.y || 0) + delta.y;\n                        rectangle.left += delta.x;\n                        rectangle.right += delta.x;\n                        rectangle.top += delta.y;\n                        rectangle.bottom += delta.y;\n                        field = updateFieldBoundaries(field, rectangle);\n                        placed.push(point);\n                        point.isNull = false;\n                        point.isInside = true; // #15447\n                    }\n                    else {\n                        point.isNull = true;\n                    }\n                    if (animation) {\n                        // Animate to new positions\n                        animate = {\n                            x: attr.x,\n                            y: attr.y\n                        };\n                        // Animate from center of chart\n                        if (!hasRendered) {\n                            attr.x = 0;\n                            attr.y = 0;\n                            // Or animate from previous position\n                        }\n                        else {\n                            delete attr.x;\n                            delete attr.y;\n                        }\n                    }\n                    DPU.draw(point, {\n                        animatableAttribs: animate,\n                        attribs: attr,\n                        css: css,\n                        group: group,\n                        renderer: renderer,\n                        shapeArgs: void 0,\n                        shapeType: 'text'\n                    });\n                }\n                // Destroy the element after use.\n                testElement = testElement.destroy();\n                // Scale the series group to fit within the plotArea.\n                const scale = getScale(xAxis.len, yAxis.len, field);\n                series.group.attr({\n                    scaleX: scale,\n                    scaleY: scale\n                });\n            }\n            hasData() {\n                const series = this;\n                return (isObject(series) &&\n                    series.visible === true &&\n                    isArray(series.points) &&\n                    series.points.length > 0);\n            }\n            getPlotBox() {\n                const series = this, chart = series.chart, inverted = chart.inverted, \n                // Swap axes for inverted (#2339)\n                xAxis = series[(inverted ? 'yAxis' : 'xAxis')], yAxis = series[(inverted ? 'xAxis' : 'yAxis')], width = xAxis ? xAxis.len : chart.plotWidth, height = yAxis ? yAxis.len : chart.plotHeight, x = xAxis ? xAxis.left : chart.plotLeft, y = yAxis ? yAxis.top : chart.plotTop;\n                return {\n                    translateX: x + (width / 2),\n                    translateY: y + (height / 2),\n                    scaleX: 1, // #1623\n                    scaleY: 1\n                };\n            }\n        }\n        /* *\n         *\n         *  Static properties\n         *\n         * */\n        WordcloudSeries.defaultOptions = merge(ColumnSeries.defaultOptions, WordcloudSeriesDefaults);\n        extend(WordcloudSeries.prototype, {\n            animate: noop,\n            animateDrilldown: noop,\n            animateDrillupFrom: noop,\n            isCartesian: false,\n            pointClass: WordcloudPoint,\n            setClip: noop,\n            // Strategies used for deciding rotation and initial position of a word. To\n            // implement a custom strategy, have a look at the function random for\n            // example.\n            placementStrategy: {\n                random: function (point, options) {\n                    const field = options.field, r = options.rotation;\n                    return {\n                        x: getRandomPosition(field.width) - (field.width / 2),\n                        y: getRandomPosition(field.height) - (field.height / 2),\n                        rotation: getRotation(r.orientations, point.index, r.from, r.to)\n                    };\n                },\n                center: function (point, options) {\n                    const r = options.rotation;\n                    return {\n                        x: 0,\n                        y: 0,\n                        rotation: getRotation(r.orientations, point.index, r.from, r.to)\n                    };\n                }\n            },\n            pointArrayMap: ['weight'],\n            // Spirals used for placing a word after the initial position experienced a\n            // collision with either another word or the borders. To implement a custom\n            // spiral, look at the function archimedeanSpiral for example.\n            spirals: {\n                'archimedean': archimedeanSpiral,\n                'rectangular': rectangularSpiral,\n                'square': squareSpiral\n            },\n            utils: {\n                extendPlayingField: extendPlayingField,\n                getRotation: getRotation,\n                isPolygonsColliding: isPolygonsColliding,\n                rotate2DToOrigin: rotate2DToOrigin,\n                rotate2DToPoint: rotate2DToPoint\n            }\n        });\n        SeriesRegistry.registerSeriesType('wordcloud', WordcloudSeries);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return WordcloudSeries;\n    });\n    _registerModule(_modules, 'masters/modules/wordcloud.src.js', [_modules['Core/Globals.js']], function (Highcharts) {\n\n\n        return Highcharts;\n    });\n}));\n"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","win","dispatchEvent","detail","draw","point","params","animatableAttribs","onComplete","css","renderer","animation","series","chart","hasRendered","options","graphic","attribs","getClassName","shouldDraw","shapeType","text","image","imageUrl","attr","shapeArgs","add","group","animate","isNew","destroy","Object","keys","length","SeriesRegistry","U","column","prototype","pointClass","ColumnPoint","seriesTypes","extend","WordcloudPoint","isValid","weight","allowExtendPlayingField","duration","borderWidth","clip","colorByPoint","cropThreshold","Infinity","minFontSize","maxFontSize","placementStrategy","rotation","from","orientations","to","showInLegend","spiral","style","fontFamily","fontWeight","whiteSpace","tooltip","followPointer","pointFormat","H","deg2rad","find","isNumber","isObject","merge","isRectanglesIntersecting","r1","r2","left","right","top","bottom","getAxesFromPolygon","polygon","points","axes","concat","reduce","p1","p2","axis","normals","getNormals","dx","dy","existing","push","project","target","products","map","ax","ay","min","Math","max","isPolygonsColliding","polygon1","polygon2","axes1","axes2","isPolygonsOverlappingOnAxis","projection1","projection2","squareSpiral","attempt","a","k","ceil","sqrt","t","m","pow","result","x","y","correctFloat","number","precision","magnitude","round","rotate2DToOrigin","angle","rad","cosAngle","cos","sinAngle","sin","rotate2DToPoint","origin","rotated","archimedeanSpiral","field","maxDelta","width","height","abs","extendPlayingField","rectangle","ratioX","ratioY","extendWidth","extendHeight","getBoundingBoxFromPolygon","Number","MAX_VALUE","getPlayingField","targetWidth","targetHeight","data","info","dimensions","maxHeight","maxWidth","area","getPolygon","getRandomPosition","size","random","getRotation","index","intervals","range","orientation","getScale","getSpiral","arr","i","intersectionTesting","placed","rect","delta","intersectsAnyWord","lastCollidedWith","isIntersecting","p","intersects","outsidePlayingField","playingField","movePolygon","deltaX","deltaY","rectangularSpiral","updateFieldBoundaries","DPU","WordcloudSeriesDefaults","WU","noop","ColumnSeries","isArray","WordcloudSeries","pointAttribs","state","call","stroke","deriveFontSize","relativeWeight","floor","drawPoints","xAxis","yAxis","weights","maxWeight","sort","b","testElement","scaleX","scaleY","fontSize","name","bBox","getBBox","len","spirals","placement","selected","align","isNull","isInside","scale","hasData","visible","getPlotBox","inverted","plotWidth","plotHeight","translateX","plotLeft","translateY","plotTop","defaultOptions","animateDrilldown","animateDrillupFrom","isCartesian","setClip","r","center","pointArrayMap","utils","registerSeriesType"],"mappings":"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"}
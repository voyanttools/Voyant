{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v11.4.8 (2024-08-29)\n *\n * X-range series\n *\n * (c) 2010-2024 Torstein Honsi, Lars A. V. Cabrera\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/xrange', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                Highcharts.win.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Series/XRange/XRangeSeriesDefaults.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  X-range series module\n         *\n         *  (c) 2010-2024 Torstein Honsi, Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { correctFloat, isNumber, isObject } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        /**\n         * The X-range series displays ranges on the X axis, typically time\n         * intervals with a start and end date.\n         *\n         * @sample {highcharts} highcharts/demo/x-range/\n         *         X-range\n         * @sample {highcharts} highcharts/css/x-range/\n         *         Styled mode X-range\n         * @sample {highcharts} highcharts/chart/inverted-xrange/\n         *         Inverted X-range\n         *\n         * @extends      plotOptions.column\n         * @since        6.0.0\n         * @product      highcharts highstock gantt\n         * @excluding    boostThreshold, crisp, cropThreshold, depth, edgeColor,\n         *               edgeWidth, findNearestPointBy, getExtremesFromAll,\n         *               negativeColor, pointInterval, pointIntervalUnit,\n         *               pointPlacement, pointRange, pointStart, softThreshold,\n         *               stacking, threshold, data, dataSorting, boostBlending\n         * @requires     modules/xrange\n         * @optionparent plotOptions.xrange\n         */\n        const XRangeSeriesDefaults = {\n            /**\n             * A partial fill for each point, typically used to visualize how much\n             * of a task is performed. The partial fill object can be set either on\n             * series or point level.\n             *\n             * @sample {highcharts} highcharts/demo/x-range\n             *         X-range with partial fill\n             *\n             * @product   highcharts highstock gantt\n             * @apioption plotOptions.xrange.partialFill\n             */\n            /**\n             * The fill color to be used for partial fills. Defaults to a darker\n             * shade of the point color.\n             *\n             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n             * @product   highcharts highstock gantt\n             * @apioption plotOptions.xrange.partialFill.fill\n             */\n            /**\n             * A partial fill for each point, typically used to visualize how much\n             * of a task is performed. See [completed](series.gantt.data.completed).\n             *\n             * @sample gantt/demo/progress-indicator\n             *         Gantt with progress indicator\n             *\n             * @product   gantt\n             * @apioption plotOptions.gantt.partialFill\n             */\n            /**\n             * In an X-range series, this option makes all points of the same Y-axis\n             * category the same color.\n             */\n            colorByPoint: true,\n            dataLabels: {\n                formatter: function () {\n                    let amount = this.point.partialFill;\n                    if (isObject(amount)) {\n                        amount = amount.amount;\n                    }\n                    if (isNumber(amount) && amount > 0) {\n                        return correctFloat(amount * 100) + '%';\n                    }\n                },\n                inside: true,\n                verticalAlign: 'middle',\n                style: {\n                    whiteSpace: 'nowrap'\n                }\n            },\n            tooltip: {\n                headerFormat: '<span style=\"font-size: 0.8em\">{point.x} - {point.x2}</span><br/>',\n                pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.yCategory}</b><br/>'\n            },\n            borderRadius: 3,\n            pointRange: 0\n        };\n        /* *\n         *\n         *  Export Default\n         *\n         * */\n        /* *\n         *\n         * API Options\n         *\n         * */\n        /**\n         * An `xrange` series. If the [type](#series.xrange.type) option is not\n         * specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.xrange\n         * @excluding boostThreshold, crisp, cropThreshold, depth, edgeColor, edgeWidth,\n         *            findNearestPointBy, getExtremesFromAll, negativeColor,\n         *            pointInterval, pointIntervalUnit, pointPlacement, pointRange,\n         *            pointStart, softThreshold, stacking, threshold, dataSorting,\n         *            boostBlending\n         * @product   highcharts highstock gantt\n         * @requires  modules/xrange\n         * @apioption series.xrange\n         */\n        /**\n         * An array of data points for the series. For the `xrange` series type,\n         * points can be given in the following ways:\n         *\n         * 1. An array of objects with named values. The objects are point configuration\n         *    objects as seen below.\n         *    ```js\n         *    data: [{\n         *        x: Date.UTC(2017, 0, 1),\n         *        x2: Date.UTC(2017, 0, 3),\n         *        name: \"Test\",\n         *        y: 0,\n         *        color: \"#00FF00\"\n         *    }, {\n         *        x: Date.UTC(2017, 0, 4),\n         *        x2: Date.UTC(2017, 0, 5),\n         *        name: \"Deploy\",\n         *        y: 1,\n         *        color: \"#FF0000\"\n         *    }]\n         *    ```\n         *\n         * @sample {highcharts} highcharts/series/data-array-of-objects/\n         *         Config objects\n         *\n         * @declare   Highcharts.XrangePointOptionsObject\n         * @type      {Array<*>}\n         * @extends   series.line.data\n         * @product   highcharts highstock gantt\n         * @apioption series.xrange.data\n         */\n        /**\n         * The starting X value of the range point.\n         *\n         * @sample {highcharts} highcharts/demo/x-range\n         *         X-range\n         *\n         * @type      {number}\n         * @product   highcharts highstock gantt\n         * @apioption series.xrange.data.x\n         */\n        /**\n         * The ending X value of the range point.\n         *\n         * @sample {highcharts} highcharts/demo/x-range\n         *         X-range\n         *\n         * @type      {number}\n         * @product   highcharts highstock gantt\n         * @apioption series.xrange.data.x2\n         */\n        /**\n         * The Y value of the range point.\n         *\n         * @sample {highcharts} highcharts/demo/x-range\n         *         X-range\n         *\n         * @type      {number}\n         * @product   highcharts highstock gantt\n         * @apioption series.xrange.data.y\n         */\n        /**\n         * A partial fill for each point, typically used to visualize how much of\n         * a task is performed. The partial fill object can be set either on series\n         * or point level.\n         *\n         * @sample {highcharts} highcharts/demo/x-range\n         *         X-range with partial fill\n         *\n         * @declare   Highcharts.XrangePointPartialFillOptionsObject\n         * @product   highcharts highstock gantt\n         * @apioption series.xrange.data.partialFill\n         */\n        /**\n         * The amount of the X-range point to be filled. Values can be 0-1 and are\n         * converted to percentages in the default data label formatter.\n         *\n         * @type      {number}\n         * @product   highcharts highstock gantt\n         * @apioption series.xrange.data.partialFill.amount\n         */\n        /**\n         * The fill color to be used for partial fills. Defaults to a darker shade\n         * of the point color.\n         *\n         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n         * @product   highcharts highstock gantt\n         * @apioption series.xrange.data.partialFill.fill\n         */\n        (''); // Adds doclets above to transpiled file\n\n        return XRangeSeriesDefaults;\n    });\n    _registerModule(_modules, 'Series/XRange/XRangePoint.js', [_modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (SeriesRegistry, U) {\n        /* *\n         *\n         *  X-range series module\n         *\n         *  (c) 2010-2024 Torstein Honsi, Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { column: { prototype: { pointClass: ColumnPoint } } } = SeriesRegistry.seriesTypes;\n        const { extend } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        class XRangePoint extends ColumnPoint {\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            /**\n             * Return color of a point based on its category.\n             *\n             * @private\n             * @function getColorByCategory\n             *\n             * @param {object} series\n             *        The series which the point belongs to.\n             *\n             * @param {object} point\n             *        The point to calculate its color for.\n             *\n             * @return {object}\n             *         Returns an object containing the properties color and colorIndex.\n             */\n            static getColorByCategory(series, point) {\n                const colors = series.options.colors || series.chart.options.colors, colorCount = colors ?\n                    colors.length :\n                    series.chart.options.chart.colorCount, colorIndex = point.y % colorCount, color = colors && colors[colorIndex];\n                return {\n                    colorIndex: colorIndex,\n                    color: color\n                };\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * @private\n             */\n            resolveColor() {\n                const series = this.series;\n                if (series.options.colorByPoint && !this.options.color) {\n                    const colorByPoint = XRangePoint.getColorByCategory(series, this);\n                    if (!series.chart.styledMode) {\n                        this.color = colorByPoint.color;\n                    }\n                    if (!this.options.colorIndex) {\n                        this.colorIndex = colorByPoint.colorIndex;\n                    }\n                }\n                else {\n                    this.color = this.options.color || series.color;\n                }\n            }\n            /**\n             * Extend init to have y default to 0.\n             *\n             * @private\n             */\n            constructor(series, options) {\n                super(series, options);\n                if (!this.y) {\n                    this.y = 0;\n                }\n            }\n            /**\n             * @private\n             */\n            setState() {\n                super.setState.apply(this, arguments);\n                this.series.drawPoint(this, this.series.getAnimationVerb());\n            }\n            /**\n             * Add x2 and yCategory to the available properties for tooltip formats.\n             *\n             * @private\n             */\n            getLabelConfig() {\n                const cfg = super.getLabelConfig.call(this), yCats = this.series.yAxis.categories;\n                cfg.x2 = this.x2;\n                cfg.yCategory = this.yCategory = yCats && yCats[this.y];\n                // Use 'category' as 'key' to ensure tooltip datetime formatting.\n                // Use 'name' only when 'category' is undefined.\n                cfg.key = this.category || this.name;\n                return cfg;\n            }\n            /**\n             * @private\n             */\n            isValid() {\n                return typeof this.x === 'number' &&\n                    typeof this.x2 === 'number';\n            }\n        }\n        extend(XRangePoint.prototype, {\n            ttBelow: false,\n            tooltipDateKeys: ['x', 'x2']\n        });\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Declarations\n         *\n         * */\n        /**\n         * The ending X value of the range point.\n         * @name Highcharts.Point#x2\n         * @type {number|undefined}\n         * @requires modules/xrange\n         */\n        /**\n         * Extend applyOptions so that `colorByPoint` for x-range means that one\n         * color is applied per Y axis category.\n         *\n         * @private\n         * @function Highcharts.Point#applyOptions\n         *\n         * @return {Highcharts.Series}\n         */\n        /**\n         * @interface Highcharts.PointOptionsObject in parts/Point.ts\n         */ /**\n        * The ending X value of the range point.\n        * @name Highcharts.PointOptionsObject#x2\n        * @type {number|undefined}\n        * @requires modules/xrange\n        */\n        (''); // Keeps doclets above in JS file\n\n        return XRangePoint;\n    });\n    _registerModule(_modules, 'Series/XRange/XRangeSeries.js', [_modules['Core/Globals.js'], _modules['Core/Color/Color.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js'], _modules['Series/XRange/XRangeSeriesDefaults.js'], _modules['Series/XRange/XRangePoint.js']], function (H, Color, SeriesRegistry, U, XRangeSeriesDefaults, XRangePoint) {\n        /* *\n         *\n         *  X-range series module\n         *\n         *  (c) 2010-2024 Torstein Honsi, Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { composed, noop } = H;\n        const { parse: color } = Color;\n        const { column: ColumnSeries } = SeriesRegistry.seriesTypes;\n        const { addEvent, clamp, crisp, defined, extend, find, isNumber, isObject, merge, pick, pushUnique, relativeLength } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Max x2 should be considered in xAxis extremes\n         * @private\n         */\n        function onAxisAfterGetSeriesExtremes() {\n            let dataMax, modMax;\n            if (this.isXAxis) {\n                dataMax = pick(this.dataMax, -Number.MAX_VALUE);\n                for (const series of this.series) {\n                    if (series.x2Data) {\n                        for (const val of series.x2Data) {\n                            if (val && val > dataMax) {\n                                dataMax = val;\n                                modMax = true;\n                            }\n                        }\n                    }\n                }\n                if (modMax) {\n                    this.dataMax = dataMax;\n                }\n            }\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.xrange\n         *\n         * @augments Highcharts.Series\n         */\n        class XRangeSeries extends ColumnSeries {\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            static compose(AxisClass) {\n                if (pushUnique(composed, 'Series.XRange')) {\n                    addEvent(AxisClass, 'afterGetSeriesExtremes', onAxisAfterGetSeriesExtremes);\n                }\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * @private\n             */\n            init() {\n                super.init.apply(this, arguments);\n                this.options.stacking = void 0; // #13161\n            }\n            /**\n             * Borrow the column series metrics, but with swapped axes. This gives\n             * free access to features like groupPadding, grouping, pointWidth etc.\n             * @private\n             */\n            getColumnMetrics() {\n                const swapAxes = () => {\n                    for (const series of this.chart.series) {\n                        const xAxis = series.xAxis;\n                        series.xAxis = series.yAxis;\n                        series.yAxis = xAxis;\n                    }\n                };\n                swapAxes();\n                const metrics = super.getColumnMetrics();\n                swapAxes();\n                return metrics;\n            }\n            /**\n             * Override cropData to show a point where x or x2 is outside visible range,\n             * but one of them is inside.\n             * @private\n             */\n            cropData(xData, yData, min, max) {\n                // Replace xData with x2Data to find the appropriate cropStart\n                const crop = super.cropData(this.x2Data, yData, min, max);\n                // Re-insert the cropped xData\n                crop.xData = xData.slice(crop.start, crop.end);\n                return crop;\n            }\n            /**\n             * Finds the index of an existing point that matches the given point\n             * options.\n             *\n             * @private\n             *\n             * @param {Highcharts.XRangePointOptions} options\n             *        The options of the point.\n             *\n             * @return {number|undefined}\n             *         Returns index of a matching point, or undefined if no match is\n             *         found.\n             */\n            findPointIndex(options) {\n                const { cropStart, points } = this;\n                const { id } = options;\n                let pointIndex;\n                if (id) {\n                    const point = find(points, (point) => point.id === id);\n                    pointIndex = point ? point.index : void 0;\n                }\n                if (typeof pointIndex === 'undefined') {\n                    const point = find(points, (point) => (point.x === options.x &&\n                        point.x2 === options.x2 &&\n                        !point.touched));\n                    pointIndex = point ? point.index : void 0;\n                }\n                // Reduce pointIndex if data is cropped\n                if (this.cropped &&\n                    isNumber(pointIndex) &&\n                    isNumber(cropStart) &&\n                    pointIndex >= cropStart) {\n                    pointIndex -= cropStart;\n                }\n                return pointIndex;\n            }\n            alignDataLabel(point) {\n                const oldPlotX = point.plotX;\n                point.plotX = pick(point.dlBox && point.dlBox.centerX, point.plotX);\n                if (point.dataLabel && point.shapeArgs?.width) {\n                    point.dataLabel.css({\n                        width: `${point.shapeArgs.width}px`\n                    });\n                }\n                super.alignDataLabel.apply(this, arguments);\n                point.plotX = oldPlotX;\n            }\n            /**\n             * @private\n             */\n            translatePoint(point) {\n                const xAxis = this.xAxis, yAxis = this.yAxis, metrics = this.columnMetrics, options = this.options, minPointLength = options.minPointLength || 0, oldColWidth = (point.shapeArgs && point.shapeArgs.width || 0) / 2, seriesXOffset = this.pointXOffset = metrics.offset, posX = pick(point.x2, point.x + (point.len || 0)), borderRadius = options.borderRadius, plotTop = this.chart.plotTop, plotLeft = this.chart.plotLeft;\n                let plotX = point.plotX, plotX2 = xAxis.translate(posX, 0, 0, 0, 1);\n                const length = Math.abs(plotX2 - plotX), inverted = this.chart.inverted, borderWidth = pick(options.borderWidth, 1);\n                let widthDifference, partialFill, yOffset = metrics.offset, pointHeight = Math.round(metrics.width), dlLeft, dlRight, dlWidth, clipRectWidth;\n                if (minPointLength) {\n                    widthDifference = minPointLength - length;\n                    if (widthDifference < 0) {\n                        widthDifference = 0;\n                    }\n                    plotX -= widthDifference / 2;\n                    plotX2 += widthDifference / 2;\n                }\n                plotX = Math.max(plotX, -10);\n                plotX2 = clamp(plotX2, -10, xAxis.len + 10);\n                // Handle individual pointWidth\n                if (defined(point.options.pointWidth)) {\n                    yOffset -= ((Math.ceil(point.options.pointWidth) - pointHeight) / 2);\n                    pointHeight = Math.ceil(point.options.pointWidth);\n                }\n                // Apply pointPlacement to the Y axis\n                if (options.pointPlacement &&\n                    isNumber(point.plotY) &&\n                    yAxis.categories) {\n                    point.plotY = yAxis.translate(point.y, 0, 1, 0, 1, options.pointPlacement);\n                }\n                const x = crisp(Math.min(plotX, plotX2), borderWidth), x2 = crisp(Math.max(plotX, plotX2), borderWidth), width = x2 - x;\n                const r = Math.min(relativeLength((typeof borderRadius === 'object' ?\n                    borderRadius.radius :\n                    borderRadius || 0), pointHeight), Math.min(width, pointHeight) / 2);\n                const shapeArgs = {\n                    x,\n                    y: crisp((point.plotY || 0) + yOffset, borderWidth),\n                    width,\n                    height: pointHeight,\n                    r\n                };\n                point.shapeArgs = shapeArgs;\n                // Move tooltip to default position\n                if (!inverted) {\n                    point.tooltipPos[0] -= oldColWidth +\n                        seriesXOffset -\n                        shapeArgs.width / 2;\n                }\n                else {\n                    point.tooltipPos[1] += seriesXOffset +\n                        oldColWidth;\n                }\n                // Align data labels inside the shape and inside the plot area\n                dlLeft = shapeArgs.x;\n                dlRight = dlLeft + shapeArgs.width;\n                if (dlLeft < 0 || dlRight > xAxis.len) {\n                    dlLeft = clamp(dlLeft, 0, xAxis.len);\n                    dlRight = clamp(dlRight, 0, xAxis.len);\n                    dlWidth = dlRight - dlLeft;\n                    point.dlBox = merge(shapeArgs, {\n                        x: dlLeft,\n                        width: dlRight - dlLeft,\n                        centerX: dlWidth ? dlWidth / 2 : null\n                    });\n                }\n                else {\n                    point.dlBox = null;\n                }\n                // Tooltip position\n                const tooltipPos = point.tooltipPos;\n                const xIndex = !inverted ? 0 : 1;\n                const yIndex = !inverted ? 1 : 0;\n                const tooltipYOffset = (this.columnMetrics ?\n                    this.columnMetrics.offset :\n                    -metrics.width / 2);\n                // Centering tooltip position (#14147)\n                if (inverted) {\n                    tooltipPos[xIndex] += shapeArgs.width / 2;\n                }\n                else {\n                    tooltipPos[xIndex] = clamp(tooltipPos[xIndex] +\n                        (xAxis.reversed ? -1 : 0) * shapeArgs.width, xAxis.left - plotLeft, xAxis.left + xAxis.len - plotLeft - 1);\n                }\n                tooltipPos[yIndex] = clamp(tooltipPos[yIndex] + ((inverted ? -1 : 1) * tooltipYOffset), yAxis.top - plotTop, yAxis.top + yAxis.len - plotTop - 1);\n                // Add a partShapeArgs to the point, based on the shapeArgs property\n                partialFill = point.partialFill;\n                if (partialFill) {\n                    // Get the partial fill amount\n                    if (isObject(partialFill)) {\n                        partialFill = partialFill.amount;\n                    }\n                    // If it was not a number, assume 0\n                    if (!isNumber(partialFill)) {\n                        partialFill = 0;\n                    }\n                    point.partShapeArgs = merge(shapeArgs);\n                    clipRectWidth = Math.max(Math.round(length * partialFill + point.plotX -\n                        plotX), 0);\n                    point.clipRectArgs = {\n                        x: xAxis.reversed ? // #10717\n                            shapeArgs.x + length - clipRectWidth :\n                            shapeArgs.x,\n                        y: shapeArgs.y,\n                        width: clipRectWidth,\n                        height: shapeArgs.height\n                    };\n                }\n            }\n            /**\n             * @private\n             */\n            translate() {\n                super.translate.apply(this, arguments);\n                for (const point of this.points) {\n                    this.translatePoint(point);\n                }\n            }\n            /**\n             * Draws a single point in the series. Needed for partial fill.\n             *\n             * This override turns point.graphic into a group containing the\n             * original graphic and an overlay displaying the partial fill.\n             *\n             * @private\n             *\n             * @param {Highcharts.Point} point\n             *        An instance of Point in the series.\n             *\n             * @param {\"animate\"|\"attr\"} verb\n             *        'animate' (animates changes) or 'attr' (sets options)\n             */\n            drawPoint(point, verb) {\n                const seriesOpts = this.options, renderer = this.chart.renderer, type = point.shapeType, shapeArgs = point.shapeArgs, partShapeArgs = point.partShapeArgs, clipRectArgs = point.clipRectArgs, pointState = point.state, stateOpts = (seriesOpts.states[pointState || 'normal'] ||\n                    {}), pointStateVerb = typeof pointState === 'undefined' ?\n                    'attr' : verb, pointAttr = this.pointAttribs(point, pointState), animation = pick(this.chart.options.chart.animation, stateOpts.animation);\n                let graphic = point.graphic, pfOptions = point.partialFill;\n                if (!point.isNull && point.visible !== false) {\n                    // Original graphic\n                    if (graphic) { // Update\n                        graphic.rect[verb](shapeArgs);\n                    }\n                    else {\n                        point.graphic = graphic = renderer.g('point')\n                            .addClass(point.getClassName())\n                            .add(point.group || this.group);\n                        graphic.rect = renderer[type](merge(shapeArgs))\n                            .addClass(point.getClassName())\n                            .addClass('highcharts-partfill-original')\n                            .add(graphic);\n                    }\n                    // Partial fill graphic\n                    if (partShapeArgs) {\n                        if (graphic.partRect) {\n                            graphic.partRect[verb](merge(partShapeArgs));\n                            graphic.partialClipRect[verb](merge(clipRectArgs));\n                        }\n                        else {\n                            graphic.partialClipRect = renderer.clipRect(clipRectArgs.x, clipRectArgs.y, clipRectArgs.width, clipRectArgs.height);\n                            graphic.partRect =\n                                renderer[type](partShapeArgs)\n                                    .addClass('highcharts-partfill-overlay')\n                                    .add(graphic)\n                                    .clip(graphic.partialClipRect);\n                        }\n                    }\n                    // Presentational\n                    if (!this.chart.styledMode) {\n                        graphic\n                            .rect[verb](pointAttr, animation)\n                            .shadow(seriesOpts.shadow);\n                        if (partShapeArgs) {\n                            // Ensure pfOptions is an object\n                            if (!isObject(pfOptions)) {\n                                pfOptions = {};\n                            }\n                            if (isObject(seriesOpts.partialFill)) {\n                                pfOptions = merge(seriesOpts.partialFill, pfOptions);\n                            }\n                            const fill = (pfOptions.fill ||\n                                color(pointAttr.fill).brighten(-0.3).get() ||\n                                color(point.color || this.color)\n                                    .brighten(-0.3).get());\n                            pointAttr.fill = fill;\n                            graphic\n                                .partRect[pointStateVerb](pointAttr, animation)\n                                .shadow(seriesOpts.shadow);\n                        }\n                    }\n                }\n                else if (graphic) {\n                    point.graphic = graphic.destroy(); // #1269\n                }\n            }\n            /**\n             * @private\n             */\n            drawPoints() {\n                const verb = this.getAnimationVerb();\n                // Draw the columns\n                for (const point of this.points) {\n                    this.drawPoint(point, verb);\n                }\n            }\n            /**\n             * Returns \"animate\", or \"attr\" if the number of points is above the\n             * animation limit.\n             *\n             * @private\n             */\n            getAnimationVerb() {\n                return (this.chart.pointCount < (this.options.animationLimit || 250) ?\n                    'animate' :\n                    'attr');\n            }\n            /**\n             * @private\n             */\n            isPointInside(point) {\n                const shapeArgs = point.shapeArgs, plotX = point.plotX, plotY = point.plotY;\n                if (!shapeArgs) {\n                    return super.isPointInside.apply(this, arguments);\n                }\n                const isInside = typeof plotX !== 'undefined' &&\n                    typeof plotY !== 'undefined' &&\n                    plotY >= 0 &&\n                    plotY <= this.yAxis.len &&\n                    (shapeArgs.x || 0) + (shapeArgs.width || 0) >= 0 &&\n                    plotX <= this.xAxis.len;\n                return isInside;\n            }\n        }\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        XRangeSeries.defaultOptions = merge(ColumnSeries.defaultOptions, XRangeSeriesDefaults);\n        extend(XRangeSeries.prototype, {\n            pointClass: XRangePoint,\n            pointArrayMap: ['x2', 'y'],\n            getExtremesFromAll: true,\n            parallelArrays: ['x', 'x2', 'y'],\n            requireSorting: false,\n            type: 'xrange',\n            animate: SeriesRegistry.series.prototype.animate,\n            autoIncrement: noop,\n            buildKDTree: noop\n        });\n        SeriesRegistry.registerSeriesType('xrange', XRangeSeries);\n        /* *\n         *\n         * Default Export\n         *\n         * */\n\n        return XRangeSeries;\n    });\n    _registerModule(_modules, 'masters/modules/xrange.src.js', [_modules['Core/Globals.js'], _modules['Series/XRange/XRangeSeries.js']], function (Highcharts, XRangeSeries) {\n\n        const G = Highcharts;\n        XRangeSeries.compose(G.Axis);\n\n        return Highcharts;\n    });\n}));\n"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","win","dispatchEvent","detail","U","correctFloat","isNumber","isObject","colorByPoint","dataLabels","formatter","amount","point","partialFill","inside","verticalAlign","style","whiteSpace","tooltip","headerFormat","pointFormat","borderRadius","pointRange","SeriesRegistry","column","prototype","pointClass","ColumnPoint","seriesTypes","extend","XRangePoint","getColorByCategory","series","colors","options","chart","colorCount","length","colorIndex","y","color","resolveColor","styledMode","constructor","setState","arguments","drawPoint","getAnimationVerb","getLabelConfig","cfg","call","yCats","yAxis","categories","x2","yCategory","key","category","name","isValid","x","ttBelow","tooltipDateKeys","H","Color","XRangeSeriesDefaults","composed","noop","parse","ColumnSeries","addEvent","clamp","crisp","defined","find","merge","pick","pushUnique","relativeLength","onAxisAfterGetSeriesExtremes","dataMax","modMax","isXAxis","Number","MAX_VALUE","x2Data","val","XRangeSeries","compose","AxisClass","init","stacking","getColumnMetrics","swapAxes","xAxis","metrics","cropData","xData","yData","min","max","crop","slice","start","end","findPointIndex","pointIndex","cropStart","points","id","index","touched","cropped","alignDataLabel","oldPlotX","plotX","dlBox","centerX","dataLabel","shapeArgs","width","css","translatePoint","columnMetrics","minPointLength","oldColWidth","seriesXOffset","pointXOffset","offset","posX","len","plotTop","plotLeft","plotX2","translate","Math","abs","inverted","borderWidth","widthDifference","yOffset","pointHeight","round","dlLeft","dlRight","dlWidth","clipRectWidth","pointWidth","ceil","pointPlacement","plotY","r","radius","height","tooltipPos","xIndex","yIndex","tooltipYOffset","reversed","left","top","partShapeArgs","clipRectArgs","verb","seriesOpts","renderer","type","shapeType","pointState","state","stateOpts","states","pointStateVerb","pointAttr","pointAttribs","animation","graphic","pfOptions","isNull","visible","destroy","rect","g","addClass","getClassName","add","group","partRect","partialClipRect","clipRect","clip","shadow","fill","brighten","get","drawPoints","pointCount","animationLimit","isPointInside","defaultOptions","pointArrayMap","getExtremesFromAll","parallelArrays","requireSorting","animate","autoIncrement","buildKDTree","registerSeriesType","G","Axis"],"mappings":"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"}